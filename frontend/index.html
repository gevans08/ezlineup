<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EZ Lineup - Sports Team Manager</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Easy lineup management for youth sports teams">
    <meta name="theme-color" content="#004E89">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EZ Lineup">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Apple Touch Icon (inline SVG as data URL) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%23004E89' width='180' height='180' rx='20'/><text x='90' y='120' font-size='90' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold'>EZ</text></svg>">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%23004E89' width='32' height='32' rx='4'/><text x='16' y='23' font-size='18' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold'>EZ</text></svg>">
    
    <!-- Configuration (edit config.js to switch backends) -->
    <script src="config.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #e8f4fc 0%, #ffffff 50%, #d6eaf8 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Navigation Bar */
        .nav-bar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            z-index: 100;
        }

        .nav-bar-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .nav-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #004E89;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 10px 16px;
            border-radius: 8px;
            transition: all 0.3s;
            position: relative;
            background: rgba(0, 78, 137, 0.08);
            border: 2px solid rgba(0, 78, 137, 0.2);
        }

        .nav-title:hover {
            background: rgba(0, 78, 137, 0.15);
            border-color: rgba(0, 78, 137, 0.4);
        }

        .nav-title::after {
            content: 'â–¼';
            font-size: 0.7rem;
            margin-left: 8px;
            padding: 4px 6px;
            background: rgba(0, 78, 137, 0.15);
            border-radius: 4px;
            transition: transform 0.2s;
        }

        .nav-title:hover::after {
            background: rgba(0, 78, 137, 0.25);
        }

        .team-selector-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 280px;
            max-width: 400px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .team-selector-dropdown.show {
            display: block;
        }

        .team-selector-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.2s;
        }

        .team-selector-item:hover {
            background: #f8f9fa;
        }

        .team-selector-item:last-child {
            border-bottom: none;
        }

        .team-selector-item.active {
            background: rgba(0, 78, 137, 0.1);
            font-weight: 600;
        }

        .team-selector-item .team-card-sport {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .team-selector-item-info {
            flex: 1;
            min-width: 0;
        }

        .team-selector-item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .team-selector-item-details {
            font-size: 0.85rem;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .team-selector-add {
            padding: 12px 16px;
            border-top: 2px solid #f0f0f0;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #004E89;
            transition: background 0.2s;
        }

        .team-selector-add:hover {
            background: #e9ecef;
        }

        .nav-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-link {
            padding: 10px 20px;
            background: #f0f0f0;
            color: #333;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: #004E89;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .nav-link.active {
            background: #004E89;
            color: white;
            border-color: #003d6b;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Page Navigation */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .nav-button {
            background: white;
            color: #004E89;
            border: 2px solid #004E89;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }

        .nav-button:hover {
            background: #004E89;
            color: white;
        }

        .back-button {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .back-button:hover {
            background: #5a6268;
        }

        /* Team Selection Page Styles */
        .team-selection-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .team-selection-title {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .team-selection-subtitle {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        .teams-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .team-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .team-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.15);
            border-color: #004E89;
        }

        .team-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .team-card-name {
            font-size: 1.4rem;
            font-weight: bold;
            color: #004E89;
            margin: 0;
        }

        .team-card-sport {
            background: #004E89;
            color: white;
            padding: 6px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }
        
        .team-card-sport-icon {
            display: block;
        }

        .team-card-info {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .team-card-info-item {
            margin-bottom: 8px;
        }

        /* Team Info Page Styles */
        .team-info-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }

        .team-info-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #004E89 0%, #003d6b 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 4px 12px rgba(0, 78, 137, 0.3);
        }

        .team-info-title {
            flex: 1;
        }

        .team-info-title h3 {
            font-size: 1.8rem;
            color: #333;
            margin: 0 0 8px 0;
        }

        .team-info-title p {
            color: #666;
            margin: 0;
            font-size: 1.1rem;
        }

        .team-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .team-info-stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid #e9ecef;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .team-info-stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .team-info-stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #004E89;
            margin-bottom: 8px;
        }

        .team-info-stat-label {
            color: #666;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .team-info-details {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .team-info-details h4 {
            color: #333;
            margin: 0 0 15px 0;
            font-size: 1.1rem;
        }

        .team-info-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .team-info-detail-row:last-child {
            border-bottom: none;
        }

        .team-info-detail-label {
            color: #666;
            font-weight: 500;
        }

        .team-info-detail-value {
            color: #333;
            font-weight: 600;
        }

        .team-info-record {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .team-info-record-wins {
            color: #28a745;
            font-weight: bold;
        }

        .team-info-record-losses {
            color: #dc3545;
            font-weight: bold;
        }

        .team-info-record-ties {
            color: #6c757d;
            font-weight: bold;
        }

        .team-info-actions {
            margin-top: 30px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .team-info-action-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1rem;
        }

        .team-info-action-btn.primary {
            background: #004E89;
            color: white;
        }

        .team-info-action-btn.primary:hover {
            background: #003d6b;
        }

        .team-info-action-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .team-info-action-btn.secondary:hover {
            background: #e0e0e0;
        }

        .team-info-action-btn.danger {
            background: #fff;
            color: #dc3545;
            border: 2px solid #dc3545;
        }

        .team-info-action-btn.danger:hover {
            background: #dc3545;
            color: white;
        }

        .team-card-info-label {
            font-weight: 600;
            color: #333;
        }

        .add-team-btn {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            display: block;
            padding: 18px 30px;
            background: white;
            color: #004E89;
            border: 3px dashed #004E89;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .add-team-btn:hover {
            background: #004E89;
            color: white;
            border-color: white;
            transform: scale(1.02);
        }

        .archived-teams-title {
            color: white;
            margin-top: 50px;
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .team-card-archive-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }

        .team-card-archive-btn:hover {
            background: #5a6268;
        }

        /* Team Header Bar */
        .team-header-bar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .team-switcher-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .team-switcher-btn {
            background: #004E89;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }

        .team-switcher-btn:hover {
            background: #003d6b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .team-switcher-arrow {
            font-size: 0.8rem;
        }

        .dashboard-card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        .dashboard-card h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #004E89;
        }

        .dashboard-card p {
            color: #666;
            margin-bottom: 0;
        }

        .game-list-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
        }

        .game-list-item:hover {
            background: #f8f9fa;
            transform: translateX(5px);
        }

        .game-list-item.in-progress {
            border-left: 4px solid #ffc107;
            background: #fffdf5;
        }

        .game-list-item.in-progress:hover {
            background: #fff9e6;
        }

        .game-list-item h4 {
            color: #004E89;
            margin-bottom: 10px;
        }

        .game-list-item .game-meta {
            flex: 1;
            color: #666;
            font-size: 0.9rem;
        }

        .game-list-item .game-info-right {
            text-align: right;
            min-width: 200px;
        }

        .game-list-item .game-score-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
        }

        .game-list-item .game-score {
            font-weight: bold;
            color: #004E89;
            font-size: 1.5rem;
            margin: 0;
            line-height: 1.3;
        }

        .game-list-item .game-score.win {
            color: #28a745;
        }

        .game-list-item .game-score.win .team-score {
            font-size: 1.8rem;
            font-weight: 900;
        }

        .game-list-item .game-comments {
            color: #666;
            font-size: 0.85rem;
            font-style: italic;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 8px;
            text-align: right;
        }

        .delete-game-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .delete-game-btn:hover {
            background: #c82333;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        .delete-game-btn:active {
            transform: scale(0.95);
        }

        .roster-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .roster-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #333;
        }

        .roster-title-with-record {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .team-record {
            background: #004E89;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: bold;
        }

        .team-record:empty {
            display: none;
        }

        .player-card {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            transition: all 0.3s;
        }

        .player-card.present {
            background: #d4edda;
            border-color: #28a745;
        }

        .player-card.absent {
            background: #f5f5f5;
            border-color: #ddd;
            opacity: 0.6;
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .edit-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            color: #666;
            padding: 2px 5px;
        }

        .edit-btn:hover {
            color: #004E89;
        }

        .player-name-input {
            font-size: 1.2rem;
            font-weight: bold;
            padding: 5px;
            border: 2px solid #004E89;
            border-radius: 4px;
            width: 150px;
        }

        .presence-checkbox {
            margin-left: auto;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .star-btn {
            background: #ffc107;
            border: 2px solid #ff9800;
            color: #333;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .star-btn.active {
            background: #ffc107;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .star-btn:not(.active) {
            background: #e0e0e0;
            border-color: #ccc;
            color: #999;
        }

        .positions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .position-btn {
            background: #e0e0e0;
            border: 2px solid #ccc;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 40px;
        }

        .position-btn.active {
            background: #FF6B35;
            border-color: #e55a2b;
            color: white;
        }

        .player-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .add-player-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
        }

        .add-player-btn:hover {
            background: #218838;
        }

        .generate-btn {
            background: #004E89;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        .generate-btn:hover {
            background: #003d6b;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .save-btn, .load-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s;
        }

        .save-btn:hover {
            background: #218838;
        }

        .load-btn {
            background: #17a2b8;
        }

        .load-btn:hover {
            background: #138496;
        }

        .saved-games-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .saved-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: #f5f5f5;
            border-radius: 6px;
            border: 1px solid #ddd;
        }

        .saved-game-item:hover {
            background: #e9e9e9;
        }

        .saved-game-info {
            flex: 1;
        }

        .saved-game-name {
            font-weight: bold;
            color: #333;
        }

        .saved-game-date {
            font-size: 0.85rem;
            color: #666;
            margin-top: 4px;
        }

        .saved-game-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.85rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-load {
            background: #17a2b8;
            color: white;
        }

        .btn-load:hover {
            background: #138496;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-delete:hover {
            background: #c82333;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .lineup-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
        }

        .lineup-section.show {
            display: block;
        }

        .lineup-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            overflow-x: auto;
            display: block;
        }

        .lineup-table thead {
            background: #004E89;
            color: white;
        }

        .lineup-table th,
        .lineup-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
            min-width: 80px;
        }

        .lineup-table tbody tr:nth-child(even) {
            background: #f9f9f9;
        }

        .lineup-table .player-name-col {
            text-align: left;
            font-weight: bold;
            background: #2c3e50;
            color: white;
            position: sticky;
            left: 0;
            z-index: 1;
        }

        .lineup-table .position-cell {
            background: #FF6B35;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .lineup-table .position-cell:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .lineup-table .position-cell.edited {
            background: #28a745;
            border: 2px solid #155724;
        }

        .lineup-table .position-cell.edited.saved-edit {
            background: #20c997;
            border: 2px solid #0d9488;
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        .lineup-table .position-cell.edited.new-edit {
            background: #28a745;
            border: 2px solid #155724;
            box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.5);
        }

        .lineup-table .sit-cell.edited {
            background: #ffc107;
            border: 2px solid #856404;
        }

        .lineup-table .sit-cell.edited.saved-edit {
            background: #ff9800;
            border: 2px solid #e65100;
            box-shadow: 0 0 0 2px rgba(229, 81, 0, 0.3);
        }

        .lineup-table .sit-cell.edited.new-edit {
            background: #ffc107;
            border: 2px solid #856404;
            box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.5);
        }

        /* Accordion styles for playtime history */
        .playtime-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .playtime-row:hover {
            background-color: #f0f0f0 !important;
        }

        .playtime-row.expanded {
            background-color: #e8f4f8 !important;
        }

        .playtime-detail-row {
            display: none;
            background-color: #f8f9fa;
        }

        .playtime-detail-row.show {
            display: table-row;
        }

        .playtime-detail-row td {
            padding: 12px;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
        }

        .playtime-detail-cell {
            text-align: left !important;
            padding-left: 40px !important;
        }

        .playtime-game-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .playtime-game-opponent {
            font-weight: 600;
            color: #004E89;
            min-width: 120px;
        }

        .playtime-game-date {
            color: #666;
            font-size: 0.85rem;
            min-width: 100px;
        }

        .accordion-icon {
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.3s;
            font-weight: bold;
        }

        .playtime-row.expanded .accordion-icon {
            transform: rotate(90deg);
        }

        /* Accordion styles for stats history */
        .stats-history-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .stats-history-row:hover {
            background-color: #f0f0f0 !important;
        }

        .stats-history-row.expanded {
            background-color: #e8f4f8 !important;
        }

        .stats-history-detail-row {
            display: none;
            background-color: #f8f9fa;
        }

        .stats-history-detail-row.show {
            display: table-row;
        }

        .stats-history-detail-row td {
            padding: 12px;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
        }

        .stats-history-row.expanded .accordion-icon {
            transform: rotate(90deg);
        }

        .lineup-table .sit-cell {
            background: #e0e0e0;
            color: #999;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .lineup-table .sit-cell:hover {
            background: #d0d0d0;
            transform: scale(1.05);
        }

        .lineup-table .sit-cell.edited {
            background: #ffc107;
            border: 2px solid #856404;
        }

        .lineup-table .total-cell {
            background: #ffc107;
            font-weight: bold;
        }

        .position-selector {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: white;
            border: 2px solid #004E89;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            position: absolute;
            z-index: 1000;
        }

        .position-option {
            width: 35px;
            height: 35px;
            border: 2px solid #004E89;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .position-option:hover {
            background: #004E89;
            color: white;
        }

        .position-option.clear {
            background: #dc3545;
            border-color: #c82333;
            color: white;
        }

        .position-option.clear:hover {
            background: #c82333;
        }

        /* Modal Dialog */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-dialog {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .stats-modal-dialog {
            max-width: 95%;
            width: 95%;
            padding: 20px;
        }

        .stats-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 20px 0;
            width: 100%;
            position: relative;
            background: white;
        }

        .stats-table {
            width: 100%;
            min-width: 800px;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .stats-table th {
            background: #004E89 !important;
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stats-table th.player-name-col {
            text-align: left;
            padding-left: 10px;
            padding-right: 10px;
            min-width: 100px;
            max-width: 100px;
            width: 100px;
        }

        .stats-table th.number-col {
            min-width: 45px;
            max-width: 45px;
            width: 45px;
        }

        .stats-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            border-right: 1px solid #e6e6e6;
            background: white;
        }
        
        .stats-table tbody tr:nth-child(even) td:not(.player-name-col):not(.number-col) {
            background: #fafafa;
        }

        .stats-table td.player-name-col {
            text-align: left;
            padding-left: 10px;
            padding-right: 10px;
            font-weight: 500;
            background: #2c3e50;
            color: white;
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-table td.number-col {
            background: #f1f3f5;
            font-weight: 600;
            color: #333;
            min-width: 45px;
            max-width: 45px;
            width: 45px;
        }

        .stats-table th.player-name-col,
        .stats-table td.player-name-col {
            position: sticky;
            left: 0;
            z-index: 100;
            background: #004E89 !important;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        }

        .stats-table th.player-name-col {
            background: #004E89 !important;
            z-index: 101;
        }

        .stats-table td.player-name-col {
            background: #2c3e50 !important;
            z-index: 100;
        }

        .stats-table th.number-col,
        .stats-table td.number-col {
            position: sticky;
            left: 100px;
            z-index: 98;
            background: #004E89 !important;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        }

        .stats-table th.number-col {
            background: #004E89 !important;
            z-index: 99;
        }

        .stats-table td.number-col {
            background: #f1f3f5 !important;
            z-index: 98;
        }
        
        /* Ensure all other cells stay behind sticky columns */
        .stats-table td:not(.player-name-col):not(.number-col) {
            position: relative;
            z-index: 1;
            background: white;
        }
        
        .stats-table th:not(.player-name-col):not(.number-col) {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #004E89 !important;
        }
        
        .stats-table tbody tr:nth-child(even) td:not(.player-name-col):not(.number-col) {
            background: #fafafa;
        }
        
        @media (max-width: 768px) {
            .stats-table-wrapper {
                margin: 20px -20px;
                padding: 0 20px;
            }
            
            .stats-table {
                font-size: 0.85rem;
            }
            
            .stats-table th,
            .stats-table td {
                padding: 8px 6px;
            }
            
            .stats-table th.player-name-col,
            .stats-table td.player-name-col {
                min-width: 90px;
                max-width: 90px;
                width: 90px;
                padding-left: 8px;
                padding-right: 8px;
            }
            
            .stats-table th.number-col,
            .stats-table td.number-col {
                left: 90px;
                min-width: 40px;
                max-width: 40px;
                width: 40px;
            }
        }

        .stats-table tr:hover td:not(.player-name-col):not(.number-col) {
            background: #f8f9fa !important;
        }
        
        .stats-table tr:hover td.player-name-col {
            background: #34495e !important;
        }
        
        .stats-table tr:hover td.number-col {
            background: #e9ecef !important;
        }

        .stats-table td:last-child,
        .stats-table th:last-child {
            border-right: none;
        }

        /* Box Score Table Styles */
        .box-score-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.95rem;
            background: white;
        }

        .box-score-table thead {
            border-bottom: 1px solid #e0e0e0;
        }

        .box-score-table th {
            padding: 12px 8px;
            text-align: center;
            font-weight: 500;
            background: white;
            border: none;
        }

        .box-score-team-label {
            text-align: left;
            padding-left: 0;
        }

        .box-score-period-header {
            color: #999;
            font-weight: 400;
            font-size: 0.9rem;
        }

        .box-score-total-header {
            color: #000;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .box-score-table tbody tr {
            border-bottom: 1px solid #e0e0e0;
        }

        .box-score-table tbody tr:last-child {
            border-bottom: none;
        }

        .box-score-table td {
            padding: 12px 8px;
            text-align: center;
            border: none;
            background: white;
        }

        .box-score-team-name {
            text-align: left;
            padding-left: 0;
            color: #333;
            font-weight: 500;
        }

        .box-score-period-value {
            color: #333;
            font-weight: 400;
        }

        .box-score-total-value {
            color: #000;
            font-weight: 600;
        }

        .stats-total-row td {
            background: #fff7e6;
            font-weight: bold;
            border-top: 2px solid #f0c36d;
        }

        .stats-total-cell {
            color: #e65100;
            font-size: 1.1rem;
            text-align: center;
        }

        .stat-leader-green {
            background: linear-gradient(90deg, #e8f5e9 0%, #c8e6c9 100%);
            color: #1b5e20;
            font-weight: 700;
        }

        .stat-leader-red {
            background: linear-gradient(90deg, #ffebee 0%, #ffcdd2 100%);
            color: #b71c1c;
            font-weight: 700;
        }

        .sortable-header {
            cursor: pointer;
            user-select: none;
        }

        .sortable-header:hover {
            background-color: #e9ecef;
        }

        .sortable-header span {
            font-size: 0.8rem;
            margin-left: 4px;
            color: #666;
        }

        .stat-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .stat-value {
            min-width: 40px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #004E89;
        }

        .stat-btn {
            background: #004E89;
            color: white;
            border: none;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-btn:hover {
            background: #003d6b;
            transform: scale(1.1);
        }

        .stat-btn:active {
            transform: scale(0.95);
        }

        .stat-btn.decrement {
            background: #dc3545;
        }

        .stat-btn.decrement:hover {
            background: #c82333;
        }

        .dnp-badge {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 0.75rem;
            background: #fdecea;
            color: #b71c1c;
            font-weight: 600;
        }

        .gp-toggle {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .modal-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h2 {
            color: #004E89;
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 5px 10px;
        }

        .modal-close:hover {
            color: #004E89;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #004E89;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .score-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .score-group input {
            flex: 1;
        }

        .score-group span {
            color: #666;
            font-size: 1.2rem;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-btn-primary {
            background: #28a745;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #218838;
        }

        .modal-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .modal-btn-secondary:hover {
            background: #5a6268;
        }

        .victory-message {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .game-info-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .game-info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .game-info-row:last-child {
            border-bottom: none;
        }

        .game-info-label {
            font-weight: 600;
            color: #666;
        }

        .game-info-value {
            color: #333;
        }

        .game-comments {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            color: #333;
            white-space: pre-wrap;
            line-height: 1.6;
        }

        /* Live Stats Page Styles */
        #live-stats-page {
            background: white;
            min-height: 100vh;
            padding: 0;
        }

        /* Hide nav-bar on live stats page */
        body:has(#live-stats-page.active) .nav-bar {
            display: none;
        }
        
        /* Make live-stats-page full screen */
        #live-stats-page {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: auto;
            background: white;
            z-index: 1000;
        }
        
        body:has(#live-stats-page.active) {
            padding: 0;
            overflow: hidden;
        }
        
        body:has(#live-stats-page.active) .container {
            max-width: 100%;
            margin: 0;
        }

        .live-stats-header {
            background: white;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .game-title-bar {
            background: #424242;
            color: white;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 1rem;
            position: relative;
        }
        
        .game-title-bar span {
            flex: 1;
            text-align: center;
        }

        /* Hamburger Menu Button */
        .hamburger-menu-btn {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            width: 44px;
            height: 44px;
            background: #1a1a1a;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            padding: 10px;
            z-index: 1001;
            margin-right: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .hamburger-menu-btn span {
            width: 24px;
            height: 4px;
            background: white;
            border-radius: 4px;
            transition: all 0.3s;
            display: block;
        }

        .hamburger-menu-btn:hover {
            background: #333;
        }

        .hamburger-menu-btn:active {
            transform: scale(0.95);
        }

        /* Hamburger Menu Overlay */
        .hamburger-menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            animation: fadeIn 0.2s;
        }

        .hamburger-menu-overlay.show {
            display: flex;
        }

        .hamburger-menu-content {
            background: white;
            width: 280px;
            height: 100%;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s;
        }

        .hamburger-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #004E89;
            color: white;
        }

        .hamburger-menu-header h2 {
            margin: 0;
            font-size: 1.3rem;
        }

        .hamburger-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .hamburger-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hamburger-menu-links {
            display: flex;
            flex-direction: column;
            padding: 20px 0;
        }

        .hamburger-menu-link {
            padding: 15px 20px;
            color: #333;
            text-decoration: none;
            font-size: 1.1rem;
            font-weight: 500;
            transition: all 0.2s;
            border-left: 4px solid transparent;
            cursor: pointer;
        }

        .hamburger-menu-link:hover {
            background: #f0f7ff;
            border-left-color: #004E89;
            color: #004E89;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
            }
            to {
                transform: translateX(0);
            }
        }

        .live-stats-nav-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: white;
        }

        .exit-stats-btn {
            background: none;
            border: none;
            color: #004E89;
            font-size: 1rem;
            cursor: pointer;
            padding: 5px 0;
            font-weight: 600;
        }

        .exit-stats-btn:hover {
            color: #003d6b;
        }

        .period-selector-container {
            position: relative;
            display: flex;
            justify-content: center;
        }

        .period-selector-btn {
            background: #004E89;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.95rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .period-icon {
            font-size: 1rem;
        }

        .dropdown-arrow {
            font-size: 0.8rem;
        }

        .period-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 5px;
            display: none;
            z-index: 1000;
            min-width: 150px;
        }

        .period-dropdown.show {
            display: block;
        }

        .period-option {
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .period-option:hover {
            background: #f0f0f0;
        }

        .period-option-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 8px 0;
        }

        .period-option-end {
            color: #dc3545;
            font-weight: 600;
        }

        .period-option-end:hover {
            background: #fff5f5;
        }

        .game-status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .game-status-badge.in-progress {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }

        .game-status-badge.completed {
            background: #d4edda;
            color: #155724;
            border: 1px solid #28a745;
        }

        .simplified-scoreboard {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            padding: 20px;
            background: white;
            max-width: 100%;
        }

        .scoreboard-team-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            color: #333;
            font-weight: 500;
            justify-self: start;
        }

        .scoreboard-team-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            color: #333;
            font-weight: 500;
            flex-direction: row-reverse;
            justify-self: end;
        }

        .scoreboard-scores-simple {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-self: center;
        }

        .basketball-icon-outline {
            font-size: 1.1rem;
            opacity: 0.7;
        }

        .basketball-icon-filled {
            font-size: 1.1rem;
            color: #FF6B35;
        }

        .scoreboard-scores-simple {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .main-score-simple {
            font-size: 2.8rem;
            font-weight: bold;
            color: #000;
            line-height: 1;
        }

        .score-separator-simple {
            font-size: 2.8rem;
            font-weight: bold;
            color: #000;
            line-height: 1;
        }

        .stats-tabs {
            display: flex;
            border-top: 1px solid #e0e0e0;
            background: white;
            padding: 0;
        }

        .stats-tab {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: #999;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .stats-tab.active {
            color: #004E89;
            border-bottom-color: #004E89;
        }

        .stats-tab-content {
            display: none;
            padding: 20px;
            background: white;
            min-height: calc(100vh - 200px);
        }

        /* Mobile optimizations for Live Stats page - iPhone and small screens */
        @media (max-width: 480px) and (max-height: 900px) {
            /* Hide the gray title bar with hamburger menu on all tabs for mobile */
            #live-stats-page .game-title-bar {
                display: none !important;
            }

            /* Reduce header padding (for other tabs) */
            .game-title-bar {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .hamburger-menu-btn {
                width: 36px;
                height: 36px;
                padding: 8px;
                margin-right: 8px;
            }

            .hamburger-menu-btn span {
                width: 20px;
                height: 3px;
            }

            /* Reduce nav row padding */
            .live-stats-nav-row {
                padding: 8px 12px;
            }

            .exit-stats-btn {
                font-size: 0.9rem;
                padding: 3px 0;
            }

            /* Compact scoreboard */
            .simplified-scoreboard {
                padding: 8px 12px;
            }

            .scoreboard-team-left,
            .scoreboard-team-right {
                font-size: 0.85rem;
            }

            .main-score-simple {
                font-size: 1.8rem;
            }

            /* Compact tabs - consistent across all tabs */
            .stats-tabs {
                padding: 0;
            }

            .stats-tab {
                padding: 12px 14px;
                font-size: 0.9rem;
            }

            /* Ensure active tab has same padding/font as inactive tabs */
            .stats-tab.active {
                padding: 12px 14px;
                font-size: 0.9rem;
            }

            /* Reduce tab content padding */
            .stats-tab-content {
                padding: 12px;
            }

            /* Even more compact for scoring tab */
            #scoring-tab-content {
                padding: 8px 12px;
            }

            #live-stats-page.scoring-tab-active #scoring-tab-content {
                padding: 6px 10px;
            }

            /* Compact team action sections - moderate spacing */
            .team-actions-section {
                margin-bottom: 10px;
            }

            /* Reduce space between opponent and home team sections */
            .team-actions-section:first-of-type {
                margin-bottom: 10px;
            }

            /* Even more compact for scoring tab */
            #live-stats-page.scoring-tab-active .team-actions-section {
                margin-bottom: 8px;
            }

            .team-actions-header {
                padding: 10px 14px;
                margin-bottom: 10px;
                font-size: 0.95rem;
            }

            /* Even more compact for scoring tab */
            #live-stats-page.scoring-tab-active .team-actions-header {
                padding: 8px 12px;
                margin-bottom: 8px;
                font-size: 0.9rem;
            }

            .basketball-icon-small {
                font-size: 0.9rem;
            }

            /* Reduce button padding - compact but readable */
            .action-btn {
                padding: 12px 10px;
                font-size: 0.85rem;
                border-radius: 10px;
            }

            .action-btn-large {
                padding: 16px 14px;
                font-size: 0.95rem;
                border-radius: 12px;
            }

            .action-btn-medium {
                padding: 14px 12px;
                font-size: 0.9rem;
                border-radius: 11px;
            }

            .action-btn-small {
                padding: 10px 8px;
                font-size: 0.8rem;
                border-radius: 8px;
            }

            /* Even more compact for scoring tab */
            #live-stats-page.scoring-tab-active .action-btn {
                padding: 11px 9px;
                font-size: 0.8rem;
            }

            #live-stats-page.scoring-tab-active .action-btn-large {
                padding: 14px 12px;
                font-size: 0.9rem;
            }

            #live-stats-page.scoring-tab-active .action-btn-medium {
                padding: 12px 10px;
                font-size: 0.85rem;
            }

            #live-stats-page.scoring-tab-active .action-btn-small {
                padding: 9px 7px;
                font-size: 0.75rem;
            }

            /* Make scoring buttons square - ensure combined height doesn't exceed block/foul section */
            .fg-2pt-btn-large,
            .miss-2pt-btn-large,
            .fg-3pt-btn-large,
            .miss-3pt-btn-large {
                width: 100%;
                height: 48px;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.85rem;
            }

            /* Make home team +2PT FG button taller to align bottom with rebound button */
            .action-column-left > .fg-2pt-btn-large {
                height: calc(9px + 9px + 0.75rem * 1.2);
                /* Match height of one small button row (padding top + bottom + line-height) */
            }

            /* Reduce grid gaps - moderate spacing */
            .action-buttons-grid {
                gap: 8px;
            }

            .opponent-actions {
                padding: 12px;
                gap: 8px;
            }

            .scoring-actions {
                gap: 8px;
            }

            .scoring-team-section {
                padding: 12px;
            }

            .action-column-left,
            .action-column-right,
            .action-column-center {
                gap: 8px;
            }

            .action-grid-small {
                gap: 8px;
            }

            /* Even tighter for scoring tab */
            #live-stats-page.scoring-tab-active .action-buttons-grid {
                gap: 7px;
            }

            #live-stats-page.scoring-tab-active .opponent-actions {
                padding: 10px;
                gap: 7px;
            }

            #live-stats-page.scoring-tab-active .scoring-actions {
                gap: 7px;
            }

            #live-stats-page.scoring-tab-active .scoring-team-section {
                padding: 10px;
            }

            #live-stats-page.scoring-tab-active .action-column-left,
            #live-stats-page.scoring-tab-active .action-column-right,
            #live-stats-page.scoring-tab-active .action-column-center {
                gap: 7px;
            }

            /* Ensure scoring button columns match height of center column */
            .action-column-left,
            .action-column-right {
                justify-content: flex-start;
            }

            #live-stats-page.scoring-tab-active .action-grid-small {
                gap: 7px;
            }

            /* Reduce period selector size */
            .period-selector-btn {
                padding: 6px 12px;
                font-size: 0.85rem;
            }

            .period-icon {
                font-size: 0.9rem;
            }

            /* Compact on-court players section */
            .on-court-players {
                gap: 6px;
                margin-bottom: 0;
            }

            /* Inline sub button styling */
            .inline-sub-btn {
                margin-left: auto;
                flex-shrink: 0;
            }

            /* Even more compact for scoring tab */
            #live-stats-page.scoring-tab-active .on-court-players {
                gap: 4px;
                margin-bottom: 0;
            }

            .on-court-player {
                gap: 3px;
            }

            .player-number {
                font-size: 1.1rem;
            }

            .player-name-small {
                font-size: 0.65rem;
                max-width: 70px;
            }

            .foul-badge {
                padding: 3px 8px;
                font-size: 0.7rem;
            }

            /* Compact substitution button */
            .substitution-btn,
            .sub-btn {
                padding: 10px 16px;
                font-size: 0.85rem;
            }

            .swap-players-btn {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }

            /* Ensure substitutions section is visible */
            #scoring-tab-content {
                padding-bottom: 10px; /* Minimal bottom padding */
            }

            /* Compact on-court section - add slight padding from scoring tools */
            .on-court-section {
                margin-top: 10px;
                padding: 8px 10px;
            }

            /* Hide header completely - button is now inline with players */
            .on-court-header {
                display: none !important;
            }

            /* Compact substitution button */
            .compact-sub-btn {
                width: auto !important;
                height: 32px !important;
                padding: 6px 10px !important;
                font-size: 0.75rem !important;
            }

            .sub-btn-text {
                font-size: 0.75rem;
            }

            .player-count-badge {
                font-size: 0.7rem;
                padding: 1px 5px;
            }

            /* Even tighter for scoring tab but keep some spacing */
            #live-stats-page.scoring-tab-active .on-court-section {
                margin-top: 8px;
                padding: 6px 8px;
            }

            #live-stats-page.scoring-tab-active .compact-sub-btn {
                height: 28px !important;
                padding: 5px 8px !important;
                font-size: 0.7rem !important;
            }

            .on-court-header {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .player-count {
                font-size: 0.85rem;
            }
        }

        .stats-tab-content.active {
            display: block;
        }

        /* Play-By-Play Styles */
        .plays-display-container {
            padding: 10px 0;
        }

        .pbp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .pbp-header-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: #333;
        }

        .pbp-undo-last-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pbp-undo-last-btn:hover {
            background: #5a6268;
        }

        .pbp-undo-last-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .pbp-quarter-section {
            margin-bottom: 15px;
        }

        .pbp-quarter-header {
            background: #004E89;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            font-size: 1rem;
        }

        .pbp-quarter-header:hover {
            background: #003d6b;
        }

        .pbp-quarter-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .pbp-quarter-section.collapsed .pbp-quarter-toggle {
            transform: rotate(-90deg);
        }

        .pbp-quarter-section.collapsed .pbp-plays-list {
            display: none;
        }

        .pbp-plays-list {
            padding: 10px 0;
        }

        .pbp-entry {
            display: flex;
            align-items: center;
            padding: 10px 14px;
            margin: 6px 0;
            border-radius: 6px;
            font-size: 0.95rem;
            max-width: 85%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pbp-entry:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .pbp-entry.team-play {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            margin-left: auto;
            margin-right: 0;
            text-align: right;
        }

        .pbp-entry.opponent-play {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            margin-left: 0;
            margin-right: auto;
            text-align: left;
        }

        .pbp-entry-text {
            flex: 1;
        }

        .pbp-empty-message {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Sortable Stats Table Styles */
        .stats-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .stats-table th.sortable:hover {
            background: #003d6b !important;
        }

        .stats-table th.sortable .sort-indicator {
            font-size: 0.7em;
            margin-left: 2px;
            opacity: 0.5;
        }

        .stats-table th.sortable.sort-asc .sort-indicator,
        .stats-table th.sortable.sort-desc .sort-indicator {
            opacity: 1;
        }

        /* Ensure sticky columns maintain their position and z-index with sortable */
        .stats-table th.player-name-col.sortable,
        .stats-table th.number-col.sortable {
            position: sticky;
        }

        .stats-table th.player-name-col.sortable {
            left: 0;
            z-index: 101;
        }

        .stats-table th.number-col.sortable {
            left: 100px;
            z-index: 99;
        }

        @media (max-width: 768px) {
            .stats-table th.number-col.sortable {
                left: 90px;
            }
        }

        .stat-zero {
            color: #bbb !important;
        }

        .stat-leader-good {
            background: #d4edda !important;
            color: #000 !important;
            font-weight: bold !important;
        }

        .stat-leader-bad {
            background: #f8d7da !important;
            color: #000 !important;
            font-weight: bold !important;
        }

        .team-actions-section {
            margin-bottom: 30px;
        }

        .team-actions-header {
            background: #f5f5f5;
            padding: 12px 16px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            color: #333;
        }

        .basketball-icon-small {
            font-size: 1rem;
        }

        .team-selector {
            background: none;
            border: none;
            color: #004E89;
            font-weight: 600;
            cursor: pointer;
            margin-left: auto;
        }

        .action-buttons-grid {
            display: grid;
            gap: 10px;
        }

        .opponent-actions {
            grid-template-columns: repeat(3, 1fr);
            background: #f5f5f5;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }

        .scoring-actions {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .scoring-team-section {
            background: rgba(0, 78, 137, 0.03);
            padding: 15px;
            border-radius: 12px;
        }

        .action-column-left,
        .action-column-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .action-column-center {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .action-grid-small {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .action-btn {
            padding: 15px 10px;
            border: none;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #333;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.15),
                0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.3) 0%, transparent 100%);
            pointer-events: none;
            border-radius: 12px 12px 0 0;
        }

        .free-throw-btn {
            background: linear-gradient(180deg, #e6b894 0%, #d4a574 100%);
            color: white;
            box-shadow: 
                0 5px 10px rgba(212, 165, 116, 0.35),
                0 2px 5px rgba(212, 165, 116, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.35),
                inset 0 -1px 0 rgba(0, 0, 0, 0.12);
        }

        .free-throw-btn::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
        }

        .fg-2pt-btn {
            background: linear-gradient(180deg, #34ce57 0%, #28a745 100%);
            color: white;
            box-shadow: 
                0 5px 10px rgba(40, 167, 69, 0.35),
                0 2px 5px rgba(40, 167, 69, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.35),
                inset 0 -1px 0 rgba(0, 0, 0, 0.12);
        }
        
        .fg-2pt-btn-large {
            background: linear-gradient(180deg, #34ce57 0%, #28a745 100%);
            color: white;
            box-shadow: 
                0 6px 12px rgba(40, 167, 69, 0.4),
                0 3px 6px rgba(40, 167, 69, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -2px 0 rgba(0, 0, 0, 0.1);
        }

        .fg-2pt-btn::before, .fg-2pt-btn-large::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
        }

        .fg-3pt-btn {
            background: linear-gradient(180deg, #34ce57 0%, #28a745 100%);
            color: white;
            box-shadow: 
                0 5px 10px rgba(40, 167, 69, 0.35),
                0 2px 5px rgba(40, 167, 69, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.35),
                inset 0 -1px 0 rgba(0, 0, 0, 0.12);
        }
        
        .fg-3pt-btn-large {
            background: linear-gradient(180deg, #34ce57 0%, #28a745 100%);
            color: white;
            box-shadow: 
                0 6px 12px rgba(40, 167, 69, 0.4),
                0 3px 6px rgba(40, 167, 69, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -2px 0 rgba(0, 0, 0, 0.1);
        }

        .fg-3pt-btn::before, .fg-3pt-btn-large::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
        }

        .foul-btn {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 5px 10px rgba(108, 117, 125, 0.35),
                0 2px 5px rgba(108, 117, 125, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        
        .foul-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .foul-btn::before, .foul-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .rebound-btn {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 5px 10px rgba(108, 117, 125, 0.35),
                0 2px 5px rgba(108, 117, 125, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        
        .rebound-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .rebound-btn::before, .rebound-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .turnover-btn {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 5px 10px rgba(108, 117, 125, 0.35),
                0 2px 5px rgba(108, 117, 125, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        
        .turnover-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .turnover-btn::before, .turnover-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .turnover-btn.animate-highlight {
            background: #dc3545 !important;
            color: white !important;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.6);
        }

        .turnover-btn.animate-highlight::after {
            content: '(+1)';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #dc3545;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
            white-space: nowrap;
            animation: fadeInOut 1.5s ease-in-out;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-5px);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-5px);
            }
        }

        .action-btn-large {
            padding: 25px 15px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 14px;
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.15),
                0 3px 6px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -2px 0 rgba(0, 0, 0, 0.1);
        }

        .miss-2pt-btn-large,
        .miss-3pt-btn-large {
            background: linear-gradient(180deg, #e84d5f 0%, #dc3545 100%);
            color: white;
            box-shadow: 
                0 6px 12px rgba(220, 53, 69, 0.4),
                0 3px 6px rgba(220, 53, 69, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -2px 0 rgba(0, 0, 0, 0.15);
        }

        .miss-2pt-btn-large::before,
        .miss-3pt-btn-large::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.35) 0%, transparent 100%);
        }

        .free-throw-btn-medium {
            padding: 20px 15px;
            background: linear-gradient(180deg, #e6b894 0%, #d4a574 100%);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 13px;
            box-shadow: 
                0 5px 10px rgba(212, 165, 116, 0.35),
                0 2px 5px rgba(212, 165, 116, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.35),
                inset 0 -1px 0 rgba(0, 0, 0, 0.12);
        }

        .free-throw-btn-medium::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
        }

        .action-btn-small {
            padding: 12px 10px;
            font-size: 0.85rem;
            border-radius: 10px;
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.12),
                0 1px 3px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .block-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .block-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .assist-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .assist-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .steal-btn-small {
            background: linear-gradient(180deg, #7d8790 0%, #6c757d 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(108, 117, 125, 0.3),
                0 1px 3px rgba(108, 117, 125, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }

        .steal-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, transparent 100%);
        }

        .timeout-btn-small {
            background: linear-gradient(180deg, #ffb347 0%, #ff9800 100%);
            color: white;
            box-shadow: 
                0 3px 6px rgba(255, 152, 0, 0.35),
                0 1px 3px rgba(255, 152, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.12);
        }

        .timeout-btn-small::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.35) 0%, transparent 100%);
        }

        .action-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.15),
                0 3px 8px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .action-btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .action-btn:active::before {
            opacity: 0.5;
        }

        .on-court-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .on-court-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-weight: 600;
            color: #666;
        }

        .player-count {
            background: #004E89;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.9rem;
        }

        /* Compact substitution button - replaces header on mobile */
        .compact-sub-btn {
            width: auto !important;
            height: auto !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            display: flex !important;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .sub-btn-text {
            font-size: 0.85rem;
        }

        .player-count-badge {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
        }

        .swap-players-btn {
            background: #004E89;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .swap-players-btn:hover {
            background: #003d6b;
            transform: scale(1.1);
        }

        .swap-icon {
            font-size: 1.2rem;
        }

        .on-court-players {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        /* Inline substitution button - appears with players */
        .inline-sub-btn {
            align-self: center;
        }

        .on-court-player {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .player-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: #004E89;
        }

        .player-name-small {
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .foul-badge {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .foul-badge-yellow {
            background: #fff9c4;
            color: #f57f17;
        }

        .foul-badge-red {
            background: #ffebee;
            color: #c62828;
        }

        .stats-display-container {
            padding: 20px 0;
        }

        .stats-section {
            margin-bottom: 30px;
        }

        .stats-section h3 {
            color: #004E89;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .player-selection-dialog,
        .substitution-dialog {
            max-width: 500px;
        }

        .player-selection-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .player-selection-item {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-selection-item:hover {
            border-color: #004E89;
            background: #f0f7ff;
        }

        .player-selection-item.active-player {
            border-color: #28a745;
            background: #e8f5e9;
        }

        .player-selection-item .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-selection-item .player-number {
            background: #004E89;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: bold;
        }

        .substitution-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .substitution-section {
            flex: 1;
        }

        #fouled-out-section {
            width: 100%;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        #fouled-out-section h3 {
            color: #dc3545;
            margin-bottom: 12px;
            font-size: 1rem;
        }

        .substitution-section h3 {
            color: #004E89;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .substitution-players-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .substitution-player-item {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .substitution-player-item:hover {
            border-color: #004E89;
            background: #f0f7ff;
        }

        .substitution-player-item.selected {
            border-color: #28a745;
            background: #e8f5e9;
        }

        .substitution-player-item.selected-out {
            border-color: #dc3545;
            background: #ffebee;
        }

        .substitution-player-item.selected-in {
            border-color: #28a745;
            background: #e8f5e9;
        }

        .substitution-player-item.fouled-out-player {
            border-color: #dc3545;
            background: #ffebee;
            opacity: 0.9;
        }

        .substitution-player-item.fouled-out-player.selected-out {
            border-color: #dc3545;
            background: #ffcdd2;
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.3);
        }

        .substitution-player-item.required-substitution {
            border-color: #dc3545 !important;
            background: #ffcdd2 !important;
            position: relative;
        }

        .substitution-player-item.required-substitution::after {
            content: 'Out';
            position: absolute;
            top: 4px;
            right: 8px;
            background: #dc3545;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: bold;
        }

        .substitution-player-item.foul-warning-yellow {
            border-color: #f57f17 !important;
            background: #fff9c4 !important;
        }

        .substitution-player-item.foul-warning-yellow.selected-out {
            border-color: #f57f17 !important;
            background: #ffe082 !important;
        }

        .substitution-player-item.foul-warning-yellow.selected-in {
            border-color: #f57f17 !important;
            background: #ffe082 !important;
        }

        .substitution-player-item.foul-warning-red {
            border-color: #c62828 !important;
            background: #ffebee !important;
        }

        .substitution-player-item.foul-warning-red.selected-out {
            border-color: #c62828 !important;
            background: #ffcdd2 !important;
        }

        .substitution-player-item.foul-warning-red.selected-in {
            border-color: #c62828 !important;
            background: #ffcdd2 !important;
        }

        .substitution-pf-badge {
            margin-left: 8px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .substitution-pf-badge.normal {
            background: #e3f2fd;
            color: #1976d2;
        }

        .substitution-pf-badge.warning {
            background: #fff9c4;
            color: #f57f17;
        }

        .substitution-pf-badge.danger {
            background: #ffebee;
            color: #c62828;
        }

        /* Darker badge colors when player is selected for better visibility */
        .substitution-player-item.selected-out .substitution-pf-badge.warning,
        .substitution-player-item.selected-in .substitution-pf-badge.warning {
            background: #ffc107;
            color: #f57f17;
            border: 1px solid #f57f17;
        }

        .substitution-player-item.selected-out .substitution-pf-badge.danger,
        .substitution-player-item.selected-in .substitution-pf-badge.danger {
            background: #ffcdd2;
            color: #c62828;
            border: 1px solid #c62828;
        }

        /* Starting Lineup Modal Styles */
        .starting-lineup-dialog {
            max-width: 600px;
        }

        .starting-lineup-container {
            margin-bottom: 20px;
        }

        .starting-lineup-players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .starting-lineup-player-item {
            padding: 15px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            background: white;
        }

        .starting-lineup-player-item:hover {
            border-color: #004E89;
            background: #f0f7ff;
        }

        .starting-lineup-player-item.selected {
            border-color: #004E89;
            background: #e3f2fd;
        }

        .starting-lineup-selected {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .selected-count {
            font-size: 1.1rem;
            font-weight: 600;
            color: #004E89;
        }

        /* Assist Assignment Modal Styles */
        .assist-assignment-dialog {
            max-width: 500px;
        }

        .assist-scorer-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 20px;
        }

        .assist-back-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #666;
            cursor: pointer;
            padding: 5px;
        }

        .assist-back-btn:hover {
            color: #004E89;
        }

        .assist-scorer-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .assist-scorer-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .assist-scorer-details {
            flex: 1;
        }

        .assist-scorer-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .assist-scorer-action {
            font-size: 0.95rem;
            color: #666;
        }

        .assist-assignment-section {
            padding: 0 20px 20px;
        }

        .assist-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            color: #333;
        }

        .assist-section-header .team-name {
            color: #004E89;
        }

        .assist-quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .assist-no-assist-btn {
            flex: 1;
            padding: 12px 20px;
            background: white;
            border: 2px solid #dc3545;
            border-radius: 8px;
            color: #dc3545;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .assist-no-assist-btn:hover {
            background: #dc3545;
            color: white;
        }

        .assist-assign-later-btn {
            flex: 1;
            padding: 12px 20px;
            background: white;
            border: 2px solid #6c757d;
            border-radius: 8px;
            color: #333;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .assist-assign-later-btn:hover {
            background: #6c757d;
            color: white;
        }

        .assist-players-section {
            margin-bottom: 25px;
        }

        .assist-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .assist-players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
        }

        .assist-player-item {
            padding: 15px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            background: white;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .assist-player-item:hover {
            border-color: #004E89;
            background: #f0f7ff;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .assist-player-item.on-court {
            border-color: #2196F3;
            border-width: 2px;
            background: #e3f2fd;
        }

        .assist-player-item.on-court:hover {
            border-color: #1976D2;
            background: #bbdefb;
        }

        .assist-player-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: #004E89;
            margin-bottom: 8px;
            line-height: 1;
        }

        .assist-player-item.on-court .assist-player-number {
            color: #1976D2;
        }

        .assist-player-name {
            font-size: 0.9rem;
            color: #333;
            line-height: 1.2;
        }

        /* Free Throw Modals */
        .freethrow-count-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .freethrow-count-btn {
            padding: 20px;
            border: 2px solid #004E89;
            border-radius: 12px;
            background: white;
            color: #004E89;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .freethrow-count-btn:hover {
            background: #004E89;
            color: white;
        }

        .freethrow-shots-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .freethrow-shot-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .freethrow-shot-label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
        }

        .freethrow-shot-buttons {
            display: flex;
            gap: 12px;
            flex: 1;
        }

        .freethrow-shot-btn {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .freethrow-shot-btn.miss {
            border-color: #dc3545;
            background: white;
            color: #dc3545;
        }

        .freethrow-shot-btn.miss:hover,
        .freethrow-shot-btn.miss.selected {
            background: #dc3545;
            color: white;
        }

        .freethrow-shot-btn.make {
            border-color: #28a745;
            background: white;
            color: #28a745;
        }

        .freethrow-shot-btn.make:hover,
        .freethrow-shot-btn.make.selected {
            background: #28a745;
            color: white;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            .player-card {
                padding: 12px;
            }

            .lineup-table {
                font-size: 0.9rem;
            }

            .lineup-table th,
            .lineup-table td {
                padding: 8px 6px;
                min-width: 60px;
            }

            .nav-bar {
                padding: 12px 15px;
                position: relative;
                top: 0;
            }

            .nav-bar-content {
                flex-direction: column;
                align-items: stretch;
            }

            .nav-title {
                font-size: 1.1rem;
                margin-bottom: 10px;
                text-align: center;
            }

            .nav-links {
                justify-content: center;
                width: 100%;
            }

            .nav-link {
                flex: 1;
                min-width: 120px;
                justify-content: center;
                padding: 10px 15px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation Bar -->
        <nav class="nav-bar">
            <div class="nav-bar-content">
                <div class="nav-title" id="nav-title" onclick="toggleTeamSelector()">
                    <span id="nav-title-text">Select a Team</span>
                    <div class="team-selector-dropdown" id="team-selector-dropdown">
                        <div id="team-selector-list"></div>
                        <div class="team-selector-add" onclick="event.stopPropagation(); closeTeamSelector(); openCreateTeamModal();">
                            <span>+</span>
                            <span>Add Team</span>
                        </div>
                    </div>
                </div>
                <div class="nav-links">
                    <a class="nav-link" id="nav-info" onclick="navigateTo('team-info-page')">
                        â„¹ï¸ Info
                    </a>
                    <a class="nav-link" id="nav-roster" onclick="navigateTo('edit-roster-page')">
                        âœï¸ Roster
                    </a>
                    <a class="nav-link" id="nav-games" onclick="navigateTo('games-list-page')">
                        ðŸ“‹ Games
                    </a>
                    <a class="nav-link" id="nav-new-game" onclick="navigateTo('new-game-page')">
                        ðŸ€ New Game
                    </a>
                    <a class="nav-link" id="nav-history" onclick="navigateTo('playtime-history-page')">
                        ðŸ“Š History
                    </a>
                </div>
            </div>
        </nav>

        <h1 style="display: none;">ðŸ€ Basketball Lineup Rotation Manager</h1>

        <!-- Team Selection Page -->
        <div id="team-selection-page" class="page">
            <div class="team-selection-container">
                <h1 class="team-selection-title">Select a Team</h1>
                <p class="team-selection-subtitle">Choose a team to manage, or create a new one</p>
                
                <div id="teams-list-container" class="teams-list-container">
                    <!-- Teams will be dynamically added here -->
                </div>
                
                <button class="add-team-btn" onclick="openCreateTeamModal()">+ Add New Team</button>
                
                <div id="archived-teams-section" style="display: none;">
                    <h2 class="archived-teams-title">Archived Teams</h2>
                    <div id="archived-teams-list" class="teams-list-container"></div>
                </div>
            </div>
        </div>

        <!-- Team Info Page -->
        <div id="team-info-page" class="page">
            <div class="roster-section">
                <h2 class="roster-title">Team Information</h2>
                <div id="team-info-container"></div>
            </div>
        </div>

        <!-- Edit Roster Page -->
        <div id="edit-roster-page" class="page">
            <div class="roster-section">
                <h2 class="roster-title">Edit Roster</h2>
                <p style="color: #666; margin-bottom: 20px;">Edit player names and positions they can play</p>
                <div id="roster-edit-container"></div>
                <button class="add-player-btn" onclick="addPlayer()">+ Add Player</button>
            </div>
        </div>

        <!-- Games List Page -->
        <div id="games-list-page" class="page">
            <div class="roster-section">
                <div class="roster-title-with-record">
                    <h2 class="roster-title" style="margin: 0;">Saved Games</h2>
                    <div id="team-record-display" class="team-record"></div>
                </div>
                <div id="games-list-container"></div>
            </div>
        </div>

        <!-- New Game Page -->
        <div id="new-game-page" class="page">
            
            <div class="roster-section">
                <h2 class="roster-title">Select Players Present</h2>
                <p style="color: #666; margin-bottom: 20px;">Mark which players are present for this game</p>
                <div id="game-roster-container"></div>
            </div>

            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button class="generate-btn" onclick="generateLineup()">Generate Lineup</button>
                <button class="generate-btn" id="keep-stats-btn" onclick="startStatsOnlyGame()" style="background: #28a745;">ðŸ“Š Keep Stats</button>
                <button class="generate-btn" onclick="createTestGame()" style="background: #6c757d; border: 2px dashed #004E89;">ðŸ§ª Test Game</button>
            </div>
            <div id="error-message" class="error-message"></div>

            <div id="lineup-section" class="lineup-section">
                <div class="action-buttons">
                    <button class="save-btn" onclick="saveCurrentLineup()">ðŸ’¾ Save Game</button>
                </div>
                <h2 class="roster-title">Generated Lineup</h2>
                <div style="overflow-x: auto;">
                    <table class="lineup-table">
                        <thead>
                            <tr>
                                <th class="player-name-col">Player</th>
                                <th>Q1</th>
                                <th>Q2</th>
                                <th>Q3</th>
                                <th>Q4</th>
                                <th class="total-cell">Total</th>
                            </tr>
                        </thead>
                        <tbody id="lineup-tbody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- View Game Page -->
        <div id="view-game-page" class="page">
            <button class="back-button" onclick="navigateTo('games-list-page')">â† Back to Games</button>
            <div class="roster-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
                    <h2 class="roster-title" id="view-game-title" style="margin: 0;">Game Details</h2>
                    <div style="display: flex; gap: 10px;">
                        <button class="save-btn" id="view-game-info-btn" onclick="openEditGameInfoModal()" style="background: #17a2b8;">ðŸ“ Edit Info</button>
                        <button class="save-btn" id="view-game-stats-btn" onclick="openEditStatsModal()" style="background: #28a745;">ðŸ“Š Edit Stats</button>
                        <button class="save-btn" id="view-game-delete-btn" onclick="deleteCurrentGame()" style="background: #dc3545;">ðŸ—‘ï¸ Delete Game</button>
                    </div>
                </div>
                <div id="view-game-meta" style="color: #666; margin-bottom: 20px;"></div>
                <div style="margin-bottom: 15px;">
                    <button class="save-btn" id="view-game-edit-btn" onclick="editGameMode()" style="background: #004E89;">âœï¸ Edit Lineup</button>
                    <div id="view-game-actions" style="display: none; gap: 10px; margin-top: 10px;">
                        <button class="modal-btn modal-btn-secondary" onclick="cancelEditGame()">Cancel</button>
                        <button class="modal-btn modal-btn-primary" onclick="saveEditedGame()">ðŸ’¾ Save Changes</button>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table class="lineup-table">
                        <thead>
                            <tr>
                                <th class="player-name-col">Player</th>
                                <th>Q1</th>
                                <th>Q2</th>
                                <th>Q3</th>
                                <th>Q4</th>
                                <th class="total-cell">Total</th>
                            </tr>
                        </thead>
                        <tbody id="view-game-tbody"></tbody>
                    </table>
                </div>
                <div id="view-game-legend" class="edit-legend" style="margin-top: 16px;"></div>
            </div>
        </div>

        <!-- Edit Stats Modal -->
        <div id="edit-stats-modal" class="modal-overlay" onclick="closeStatsModalIfOutside(event)">
            <div class="modal-dialog stats-modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeEditStatsModal()">&times;</button>
                <div class="modal-header">
                    <h2>ðŸ“Š Edit Game Stats</h2>
                    <p style="color: #666; font-size: 0.9rem;">Track individual player statistics</p>
                </div>
                <div style="background: #fff3cd; color: #856404; padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; font-size: 0.9rem;">
                    Lineup is the authoritative source for games played. DNP stats wonâ€™t affect per-game averages unless you enable â€œCount GPâ€.
                </div>
                <div style="overflow-x: auto; max-height: 70vh;">
                    <table class="stats-table">
                        <thead>
                            <tr>
                                <th class="player-name-col">Player</th>
                                <th class="number-col">No.</th>
                                <th>Count GP</th>
                                <th>Points</th>
                                <th>Assists</th>
                                <th>Rebounds</th>
                                <th>Blocks</th>
                                <th>Steals</th>
                                <th>Turnovers</th>
                            </tr>
                        </thead>
                        <tbody id="stats-tbody"></tbody>
                        <tfoot>
                            <tr class="stats-total-row">
                                <td class="player-name-col">Total Points</td>
                                <td></td>
                                <td></td>
                                <td id="stats-total-points" class="stats-total-cell">0</td>
                                <td colspan="5"></td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-secondary" onclick="closeEditStatsModal()">Cancel</button>
                    <button type="button" class="modal-btn modal-btn-primary" onclick="saveGameStats()">ðŸ’¾ Save Stats</button>
                </div>
            </div>
        </div>

        <!-- Edit Game Modal -->
        <div id="edit-game-modal" class="modal-overlay" onclick="closeEditModalIfOutside(event)">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeEditGameModal()">&times;</button>
                <div class="modal-header">
                    <h2>âœï¸ Edit Game Information</h2>
                </div>
                <form id="edit-game-form" onsubmit="handleEditGameInfo(event)">
                    <div class="form-group">
                        <label for="edit-opponent-input">Opponent *</label>
                        <input type="text" id="edit-opponent-input" required placeholder="e.g., Lakers, Team A">
                    </div>
                    <div class="form-group">
                        <label for="edit-game-date-input">Game Date *</label>
                        <input type="date" id="edit-game-date-input" required oninput="updateEditGameDateDisplay(this.value)">
                        <div id="edit-game-date-display" style="margin-top: 6px; color: #666; font-size: 0.85rem;"></div>
                    </div>
                    <div class="form-group">
                        <label>Score</label>
                        <div class="score-group">
                            <input type="number" id="edit-team-score-input" min="0" placeholder="Team">
                            <span>vs</span>
                            <input type="number" id="edit-opponent-score-input" min="0" placeholder="Opponent">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="edit-game-comments-input">Game Comments</label>
                        <textarea id="edit-game-comments-input" placeholder="Notes about the game, lineup performance, etc."></textarea>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="modal-btn modal-btn-secondary" onclick="closeEditGameModal()">Cancel</button>
                        <button type="submit" class="modal-btn modal-btn-primary">Save Changes</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Playtime History Page -->
        <!-- Live Stats Tracking Page -->
        <div id="live-stats-page" class="page">
            <!-- Header Section -->
            <div class="live-stats-header">
                <!-- Game Title Bar -->
                <div class="game-title-bar">
                    <button class="hamburger-menu-btn" onclick="toggleHamburgerMenu()" aria-label="Menu">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <span id="live-game-title">Practice Game</span>
                </div>
                
                <!-- Navigation Row -->
                <div class="live-stats-nav-row">
                    <button class="exit-stats-btn" onclick="exitLiveStats()">Exit</button>
                    <div class="period-selector-container">
                        <button class="period-selector-btn" id="period-selector-btn" onclick="togglePeriodSelector()">
                            <span class="period-icon">ðŸ•</span>
                            <span id="current-period-display">Period 1</span>
                            <span class="dropdown-arrow">â–¾</span>
                        </button>
                        <div class="period-dropdown" id="period-dropdown">
                            <div class="period-option" onclick="selectPeriod(1)">Period 1</div>
                            <div class="period-option" onclick="selectPeriod(2)">Period 2</div>
                            <div class="period-option" onclick="selectPeriod(3)">Period 3</div>
                            <div class="period-option" onclick="selectPeriod(4)">Period 4</div>
                            <div class="period-option" onclick="selectPeriod(5)">Overtime</div>
                            <div class="period-option-divider"></div>
                            <div class="period-option period-option-end" onclick="endGame()">ðŸ End Game</div>
                        </div>
                    </div>
                </div>
                
                <!-- Simplified Score Display -->
                <div class="simplified-scoreboard">
                    <div class="scoreboard-team-left">
                        <span class="basketball-icon-outline">ðŸ€</span>
                        <span id="opponent-team-name">Opponent Team</span>
                    </div>
                    <div class="scoreboard-scores-simple">
                        <span class="main-score-simple" id="opponent-main-score">0</span>
                        <span class="score-separator-simple">-</span>
                        <span class="main-score-simple" id="team-main-score">0</span>
                    </div>
                    <div class="scoreboard-team-right">
                        <span id="scoring-team-name">Scoring Team</span>
                        <span class="basketball-icon-filled">ðŸ€</span>
                    </div>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="stats-tabs">
                <button class="stats-tab active" id="scoring-tab" onclick="switchStatsTab('scoring')">Scoring</button>
                <button class="stats-tab" id="plays-tab" onclick="switchStatsTab('plays')">Plays</button>
                <button class="stats-tab" id="stats-tab" onclick="switchStatsTab('stats')">Stats</button>
                <button class="stats-tab" id="roster-tab" onclick="switchStatsTab('roster')">Roster</button>
            </div>

            <!-- Scoring Tab Content -->
            <div id="scoring-tab-content" class="stats-tab-content active">
                <!-- Opponent Team Actions -->
                <div class="team-actions-section">
                    <div class="team-actions-header">
                        <span class="basketball-icon-small">ðŸ€</span>
                        <span id="opponent-team-header">Opponent Team</span>
                    </div>
                    <div class="action-buttons-grid opponent-actions">
                        <button class="action-btn-medium free-throw-btn-medium" onclick="recordOpponentAction('freeThrow')">Free Throw</button>
                        <button class="action-btn-large fg-2pt-btn-large" onclick="recordOpponentAction('fg2pt')">+2 PT FG</button>
                        <button class="action-btn-large fg-3pt-btn-large" onclick="recordOpponentAction('fg3pt')">+3 PT FG</button>
                        <button class="action-btn-small foul-btn-small" onclick="recordOpponentAction('foul')">Foul</button>
                        <button class="action-btn-small rebound-btn-small" onclick="recordOpponentAction('rebound')">REB</button>
                        <button class="action-btn-small turnover-btn-small" id="opponent-turnover-btn" onclick="recordOpponentAction('turnover')">TO</button>
                    </div>
                </div>

                <!-- Scoring Team Actions -->
                <div class="team-actions-section scoring-team-section">
                    <div class="team-actions-header">
                        <span class="basketball-icon-small">ðŸ€</span>
                        <span id="scoring-team-header">Scoring Team</span>
                    </div>
                    <div class="action-buttons-grid scoring-actions">
                        <div class="action-column-left">
                            <button class="action-btn-large fg-2pt-btn-large" onclick="recordTeamAction('fg2pt')">+2 PT FG</button>
                            <button class="action-btn-large miss-2pt-btn-large" onclick="recordTeamAction('miss2pt')">2PT Miss</button>
                        </div>
                        <div class="action-column-center">
                            <button class="action-btn-medium free-throw-btn-medium" onclick="recordTeamAction('freeThrow')">Free Throw</button>
                            <div class="action-grid-small">
                                <button class="action-btn-small rebound-btn-small" onclick="recordTeamAction('rebound')">REB</button>
                                <button class="action-btn-small assist-btn-small" onclick="recordTeamAction('assist')">AST</button>
                                <button class="action-btn-small turnover-btn-small" onclick="recordTeamAction('turnover')">TO</button>
                                <button class="action-btn-small steal-btn-small" onclick="recordTeamAction('steal')">STL</button>
                                <button class="action-btn-small block-btn-small" onclick="recordTeamAction('block')">BLK</button>
                                <button class="action-btn-small foul-btn-small" onclick="recordTeamAction('foul')">Foul</button>
                            </div>
                        </div>
                        <div class="action-column-right">
                            <button class="action-btn-large fg-3pt-btn-large" onclick="recordTeamAction('fg3pt')">+3 PT FG</button>
                            <button class="action-btn-large miss-3pt-btn-large" onclick="recordTeamAction('miss3pt')">3PT Miss</button>
                        </div>
                    </div>
                </div>

                <!-- On the Court Section -->
                <div class="on-court-section">
                    <div class="on-court-players" id="on-court-players">
                        <!-- Players will be dynamically added here -->
                        <button class="swap-players-btn compact-sub-btn inline-sub-btn" onclick="openSubstitutionDialog()" title="Substitute Players">
                            <span class="swap-icon">â‡„</span>
                            <span class="sub-btn-text">Sub</span>
                            <span class="player-count-badge" id="on-court-count">5</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Stats Tab Content -->
            <div id="stats-tab-content" class="stats-tab-content">
                <div class="stats-display-container">
                    <!-- Box Score by Period -->
                    <div class="stats-section">
                        <h3>Box Score by Period</h3>
                        <div id="box-score-by-period"></div>
                    </div>
                    <!-- Player Stats -->
                    <div class="stats-section">
                        <h3>Player Statistics</h3>
                        <div class="stats-table-wrapper">
                            <div id="player-stats-table"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Play-By-Play Tab Content -->
            <div id="plays-tab-content" class="stats-tab-content">
                <div class="plays-display-container">
                    <div class="pbp-header">
                        <span class="pbp-header-title">Play-By-Play</span>
                        <button class="pbp-undo-last-btn" id="pbp-undo-last-btn" onclick="undoLastPlay()">â†© Undo Last</button>
                    </div>
                    <div id="play-by-play-list"></div>
                </div>
            </div>

            <!-- Roster Tab Content -->
            <div id="roster-tab-content" class="stats-tab-content">
                <div class="roster-display-container">
                    <h3>Game Roster</h3>
                    <div id="live-stats-roster-list"></div>
                </div>
            </div>
        </div>

        <!-- Hamburger Menu Overlay -->
        <div id="hamburger-menu-overlay" class="hamburger-menu-overlay" onclick="closeHamburgerMenu()">
            <div class="hamburger-menu-content" onclick="event.stopPropagation()">
                <div class="hamburger-menu-header">
                    <h2>Menu</h2>
                    <button class="hamburger-close-btn" onclick="closeHamburgerMenu()">&times;</button>
                </div>
                <div class="hamburger-menu-links">
                    <a class="hamburger-menu-link" onclick="navigateTo('team-info-page'); closeHamburgerMenu();">
                        â„¹ï¸ Info
                    </a>
                    <a class="hamburger-menu-link" onclick="navigateTo('edit-roster-page'); closeHamburgerMenu();">
                        âœï¸ Roster
                    </a>
                    <a class="hamburger-menu-link" onclick="navigateTo('games-list-page'); closeHamburgerMenu();">
                        ðŸ“‹ Games
                    </a>
                    <a class="hamburger-menu-link" onclick="navigateTo('new-game-page'); closeHamburgerMenu();">
                        ðŸ€ New Game
                    </a>
                    <a class="hamburger-menu-link" onclick="navigateTo('playtime-history-page'); closeHamburgerMenu();">
                        ðŸ“Š History
                    </a>
                    <div style="border-top: 1px solid #e0e0e0; margin: 10px 0;"></div>
                    <a class="hamburger-menu-link" onclick="toggleTeamSelector(); closeHamburgerMenu();">
                        ðŸ”„ Switch Team
                    </a>
                </div>
            </div>
        </div>

        <!-- Exit Game Modal -->
        <div id="exit-game-modal" class="modal-overlay" onclick="closeExitGameModal()">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeExitGameModal()">&times;</button>
                <div class="modal-header">
                    <h2>Exit Game</h2>
                </div>
                <p style="color: #333; margin-bottom: 20px; font-size: 1.1rem;">Do you want to save this game before exiting?</p>
                <p style="color: #666; margin-bottom: 25px;">If you save, you can resume tracking stats later. If you don't save, this game will be deleted.</p>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-secondary" onclick="exitGameWithoutSaving()" style="background: #dc3545;">Don't Save</button>
                    <button type="button" class="modal-btn modal-btn-primary" onclick="exitGameWithSave()">Save & Exit</button>
                </div>
            </div>
        </div>

        <!-- Generic Confirmation Modal -->
        <div id="confirm-modal" class="modal-overlay" onclick="closeConfirmModal()">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeConfirmModal()">&times;</button>
                <div class="modal-header">
                    <h2 id="confirm-modal-title">Confirm</h2>
                </div>
                <p id="confirm-modal-message" style="color: #333; margin-bottom: 20px; font-size: 1.1rem;"></p>
                <p id="confirm-modal-submessage" style="color: #666; margin-bottom: 25px;"></p>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-secondary" id="confirm-modal-cancel" onclick="closeConfirmModal()">Cancel</button>
                    <button type="button" class="modal-btn modal-btn-primary" id="confirm-modal-confirm" onclick="confirmModalAction()">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Free Throw Modal -->
        <div id="free-throw-modal" class="modal-overlay">
            <div class="modal-dialog" onclick="event.stopPropagation()" style="text-align: center;">
                <div class="modal-header">
                    <h2>ðŸ€ Free Throw</h2>
                </div>
                <p id="free-throw-player-name" style="color: #333; margin-bottom: 25px; font-size: 1.2rem; font-weight: bold;"></p>
                <div class="modal-actions" style="justify-content: center;">
                    <button type="button" class="modal-btn" onclick="recordFreeThrowResult(false)" style="background: #dc3545; color: white; min-width: 120px;">Missed</button>
                    <button type="button" class="modal-btn" onclick="recordFreeThrowResult(true)" style="background: #28a745; color: white; min-width: 120px;">Made</button>
                </div>
            </div>
        </div>

        <!-- Delete Play Modal -->
        <div id="delete-play-modal" class="modal-overlay" onclick="closeDeletePlayModal()">
            <div class="modal-dialog" onclick="event.stopPropagation()" style="text-align: center;">
                <button class="modal-close" onclick="closeDeletePlayModal()">&times;</button>
                <div class="modal-header">
                    <h2>Delete Play</h2>
                </div>
                <p id="delete-play-description" style="color: #333; margin-bottom: 15px; font-size: 1.1rem;"></p>
                <p style="color: #666; margin-bottom: 25px; font-size: 0.9rem;">This will remove the play and reverse the stats.</p>
                <div class="modal-actions" style="justify-content: center;">
                    <button type="button" class="modal-btn modal-btn-secondary" onclick="closeDeletePlayModal()">Cancel</button>
                    <button type="button" class="modal-btn" onclick="confirmDeletePlay()" style="background: #dc3545; color: white;">Delete Play</button>
                </div>
            </div>
        </div>

        <!-- Start Stats Game Modal (simplified - no score/comments) -->
        <div id="start-stats-modal" class="modal-overlay" onclick="closeStartStatsModalIfOutside(event)">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeStartStatsModal()">&times;</button>
                <div class="modal-header">
                    <h2>ðŸ“Š Start Stats Tracking</h2>
                    <p style="color: #666; font-size: 0.9rem;">Set up game info to begin tracking stats</p>
                </div>
                <form id="start-stats-form" onsubmit="handleStartStatsGame(event)">
                    <div class="form-group">
                        <label for="stats-opponent-input">Opponent *</label>
                        <input type="text" id="stats-opponent-input" required placeholder="e.g., Lakers, Team A">
                    </div>
                    <div class="form-group">
                        <label for="stats-game-date-input">Game Date *</label>
                        <input type="date" id="stats-game-date-input" required>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="modal-btn modal-btn-secondary" onclick="closeStartStatsModal()">Cancel</button>
                        <button type="submit" class="modal-btn modal-btn-primary">Start Game</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- End Game Modal (with final score and comments) -->
        <div id="end-game-modal" class="modal-overlay" onclick="closeEndGameModalIfOutside(event)">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeEndGameModal()">&times;</button>
                <div class="modal-header">
                    <h2>ðŸ End Game</h2>
                    <p style="color: #666; font-size: 0.9rem;">Review final score and add comments</p>
                </div>
                <div id="end-game-opponent-display" style="text-align: center; margin-bottom: 20px; font-size: 1.1rem; color: #333;"></div>
                <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 25px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 5px;">Your Team</div>
                        <div id="end-game-team-score" style="font-size: 2.5rem; font-weight: bold; color: #004E89;"></div>
                    </div>
                    <div style="font-size: 1.5rem; color: #999;">vs</div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 5px;">Opponent</div>
                        <div id="end-game-opponent-score" style="font-size: 2.5rem; font-weight: bold; color: #dc3545;"></div>
                    </div>
                </div>
                <div id="end-game-result" style="text-align: center; font-size: 1.3rem; font-weight: bold; margin-bottom: 20px;"></div>
                <div class="form-group">
                    <label for="end-game-comments">Game Comments</label>
                    <textarea id="end-game-comments" placeholder="Notes about the game, key plays, areas to improve, etc." style="min-height: 100px;"></textarea>
                </div>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-secondary" onclick="closeEndGameModal()">Go Back</button>
                    <button type="button" class="modal-btn modal-btn-primary" onclick="saveAndEndGame()">Save & Finish</button>
                </div>
            </div>
        </div>

        <!-- Create Team Modal -->
        <div id="create-team-modal" class="modal-overlay" onclick="closeCreateTeamModal()">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeCreateTeamModal()">&times;</button>
                <div class="modal-header">
                    <h2>Create New Team</h2>
                </div>
                <form id="create-team-form" onsubmit="handleCreateTeam(event)">
                    <div class="form-group">
                        <label for="create-team-sport">Sport *</label>
                        <select id="create-team-sport" required>
                            <option value="">Select Sport</option>
                            <option value="Basketball">Basketball</option>
                            <option value="Lacrosse">Lacrosse</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="create-team-league">League *</label>
                        <input type="text" id="create-team-league" required placeholder="e.g., Vienna Basketball 10U">
                    </div>
                    <div class="form-group">
                        <label for="create-team-season">Season *</label>
                        <input type="text" id="create-team-season" required placeholder="e.g., 2025-2026">
                    </div>
                    <div class="form-group">
                        <label for="create-team-name">Team Name *</label>
                        <input type="text" id="create-team-name" required placeholder="e.g., Blue Devils">
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="modal-btn modal-btn-secondary" onclick="closeCreateTeamModal()">Cancel</button>
                        <button type="submit" class="modal-btn modal-btn-primary">Create Team</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Player Selection Dialog -->
        <div id="player-selection-modal" class="modal-overlay" onclick="closePlayerSelectionIfOutside(event)">
            <div class="modal-dialog assist-assignment-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closePlayerSelection()">&times;</button>
                
                <!-- Action Header -->
                <div class="assist-scorer-header">
                    <button class="assist-back-btn" onclick="closePlayerSelection()">â†</button>
                    <div class="assist-scorer-info">
                        <div class="assist-scorer-avatar">ðŸ€</div>
                        <div class="assist-scorer-details">
                            <div class="assist-scorer-name" id="player-selection-title">Select Player</div>
                            <div class="assist-scorer-action" id="player-selection-action">Scoring Team</div>
                        </div>
                    </div>
                </div>

                <!-- Player Selection Section -->
                <div class="assist-assignment-section">
                    <!-- On the Court Players -->
                    <div class="assist-players-section">
                        <h3 class="assist-section-title" id="player-selection-on-court-title">On the Court (0)</h3>
                        <div class="assist-players-list" id="player-selection-on-court-list">
                            <!-- On-court players will be added here -->
                        </div>
                    </div>

                    <!-- Bench Players -->
                    <div class="assist-players-section">
                        <h3 class="assist-section-title" id="player-selection-bench-title">Bench (0)</h3>
                        <div class="assist-players-list" id="player-selection-bench-list">
                            <!-- Bench players will be added here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Assist Assignment Dialog -->
        <div id="assist-assignment-modal" class="modal-overlay" onclick="closeAssistAssignmentIfOutside(event)">
            <div class="modal-dialog assist-assignment-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeAssistAssignment()">&times;</button>
                
                <!-- Scorer Information Header -->
                <div class="assist-scorer-header">
                    <button class="assist-back-btn" onclick="closeAssistAssignment()">â†</button>
                    <div class="assist-scorer-info">
                        <div class="assist-scorer-avatar">ðŸ‘¤</div>
                        <div class="assist-scorer-details">
                            <div class="assist-scorer-name" id="assist-scorer-name">Player Name</div>
                            <div class="assist-scorer-action" id="assist-scorer-action">3-point FG made</div>
                        </div>
                    </div>
                </div>

                <!-- Assist Assignment Section -->
                <div class="assist-assignment-section">
                    <div class="assist-section-header">
                        <span class="basketball-icon-small">ðŸ€</span>
                        <span>Assist by</span>
                        <span class="team-name" id="assist-team-name">Scoring Team</span>
                    </div>
                    
                    <div class="assist-quick-actions">
                        <button class="assist-no-assist-btn" onclick="recordNoAssist()">No Assist</button>
                        <button class="assist-assign-later-btn" onclick="assignAssistLater()">Assign Later</button>
                    </div>

                    <!-- On the Court Players -->
                    <div class="assist-players-section">
                        <h3 class="assist-section-title" id="on-court-title">On the Court (0)</h3>
                        <div class="assist-players-list" id="assist-on-court-list">
                            <!-- On-court players will be added here -->
                        </div>
                    </div>

                    <!-- Bench Players -->
                    <div class="assist-players-section">
                        <h3 class="assist-section-title" id="bench-title">Bench (0)</h3>
                        <div class="assist-players-list" id="assist-bench-list">
                            <!-- Bench players will be added here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Starting Lineup Dialog -->
        <div id="starting-lineup-modal" class="modal-overlay">
            <div class="modal-dialog starting-lineup-dialog" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h2>Set Starting Lineup</h2>
                    <p style="color: #666; font-size: 0.9rem;">Select 5 players to start the game</p>
                </div>
                <div class="starting-lineup-container">
                    <div class="starting-lineup-players-list" id="starting-lineup-players-list"></div>
                    <div class="starting-lineup-selected">
                        <div class="selected-count" id="starting-lineup-count">0 / 5 selected</div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-primary" id="confirm-starting-lineup-btn" onclick="confirmStartingLineup()" disabled>Start Game</button>
                </div>
            </div>
        </div>

        <!-- Free Throw Assignment Dialog -->
        <div id="freethrow-assignment-modal" class="modal-overlay" onclick="closeFreeThrowAssignmentIfOutside(event)">
            <div class="modal-dialog assist-assignment-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeFreeThrowAssignment()">&times;</button>
                
                <!-- Player Information Header -->
                <div class="assist-scorer-header">
                    <button class="assist-back-btn" onclick="closeFreeThrowAssignment()">â†</button>
                    <div class="assist-scorer-info">
                        <div class="assist-scorer-avatar">ðŸ‘¤</div>
                        <div class="assist-scorer-details">
                            <div class="assist-scorer-name" id="freethrow-player-name">Player Name</div>
                            <div class="assist-scorer-action">Free Throw</div>
                        </div>
                    </div>
                </div>

                <!-- Free Throw Count Selection -->
                <div class="assist-assignment-section">
                    <div class="assist-section-header">
                        <span class="basketball-icon-small">ðŸ€</span>
                        <span>How many free throws?</span>
                    </div>
                    
                    <div class="freethrow-count-options">
                        <button class="freethrow-count-btn" onclick="selectFreeThrowCount('1and1')">1:1</button>
                        <button class="freethrow-count-btn" onclick="selectFreeThrowCount('1')">1</button>
                        <button class="freethrow-count-btn" onclick="selectFreeThrowCount('2')">2</button>
                        <button class="freethrow-count-btn" onclick="selectFreeThrowCount('3')">3</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Free Throw Shots Dialog -->
        <div id="freethrow-shots-modal" class="modal-overlay" onclick="closeFreeThrowShotsIfOutside(event)">
            <div class="modal-dialog assist-assignment-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeFreeThrowShots()">&times;</button>
                
                <!-- Player Information Header -->
                <div class="assist-scorer-header">
                    <button class="assist-back-btn" onclick="goBackToFreeThrowCount()">â†</button>
                    <div class="assist-scorer-info">
                        <div class="assist-scorer-avatar">ðŸ‘¤</div>
                        <div class="assist-scorer-details">
                            <div class="assist-scorer-name" id="freethrow-shots-player-name">Player Name</div>
                            <div class="assist-scorer-action" id="freethrow-shots-count-display">Free Throw</div>
                        </div>
                    </div>
                </div>

                <!-- Free Throw Shots Selection -->
                <div class="assist-assignment-section">
                    <div class="assist-section-header">
                        <span class="basketball-icon-small">ðŸ€</span>
                        <span>Record each shot</span>
                    </div>
                    
                    <div class="freethrow-shots-container" id="freethrow-shots-container">
                        <!-- Shot buttons will be dynamically added here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Substitution Dialog -->
        <div id="substitution-modal" class="modal-overlay" onclick="closeSubstitutionIfOutside(event)">
            <div class="modal-dialog substitution-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeSubstitutionDialog()">&times;</button>
                <div class="modal-header">
                    <h2>Substitute Players</h2>
                    <p style="color: #666; font-size: 0.9rem;" id="substitution-instruction">Select players to sub out, then select equal number to sub in</p>
                </div>
                <div class="substitution-container">
                    <div class="substitution-section">
                        <h3>On the Court</h3>
                        <div class="substitution-players-list" id="sub-out-players-list"></div>
                    </div>
                    <div class="substitution-section">
                        <h3>Available</h3>
                        <div class="substitution-players-list" id="sub-in-players-list"></div>
                    </div>
                </div>
                <div class="substitution-section" id="fouled-out-section" style="display: none;">
                    <h3 style="color: #dc3545;">Fouled Out</h3>
                    <div class="substitution-players-list" id="fouled-out-players-list"></div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="modal-btn modal-btn-secondary" onclick="closeSubstitutionDialog()">Cancel</button>
                    <button type="button" class="modal-btn modal-btn-primary" onclick="confirmSubstitution()" id="confirm-sub-btn">Confirm</button>
                </div>
            </div>
        </div>

        <div id="playtime-history-page" class="page">
            <div class="roster-section">
                <h2 class="roster-title">History</h2>
                <p style="color: #666; margin-bottom: 20px;">Playtime and stats aggregated from all saved games</p>
                <h3 style="margin: 0 0 10px; color: #004E89;">Stats Summary</h3>
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button class="modal-btn modal-btn-primary" id="stats-view-total-btn" onclick="setStatsViewMode('total')" style="padding: 6px 12px;">Totals</button>
                    <button class="modal-btn modal-btn-secondary" id="stats-view-per-game-btn" onclick="setStatsViewMode('per-game')" style="padding: 6px 12px;">Per Game</button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="lineup-table">
                        <thead>
                            <tr>
                                <th class="player-name-col sortable-header" onclick="setStatsSort('name')">Player <span id="stats-sort-name"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('gamesPlayed')">GP <span id="stats-sort-gp"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('points')">PTS <span id="stats-sort-pts"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('assists')">AST <span id="stats-sort-ast"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('rebounds')">REB <span id="stats-sort-reb"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('blocks')">BLK <span id="stats-sort-blk"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('steals')">STL <span id="stats-sort-stl"></span></th>
                                <th class="sortable-header" onclick="setStatsSort('turnovers')">TO <span id="stats-sort-to"></span></th>
                            </tr>
                        </thead>
                        <tbody id="stats-history-tbody"></tbody>
                    </table>
                </div>
                <div style="height: 24px;"></div>
                <h3 style="margin: 0 0 10px; color: #004E89;">Playtime Summary</h3>
                <div style="overflow-x: auto;">
                    <table class="lineup-table">
                        <thead>
                            <tr>
                                <th class="player-name-col sortable-header" onclick="setPlaytimeSort('name')">Player <span id="playtime-sort-name"></span></th>
                                <th class="sortable-header" onclick="setPlaytimeSort('totalQuarters')">Total Quarters <span id="playtime-sort-total"></span></th>
                                <th class="sortable-header" onclick="setPlaytimeSort('gamesPlayed')">Games Played <span id="playtime-sort-played"></span></th>
                                <th class="sortable-header" onclick="setPlaytimeSort('gamesAbsent')">Games Absent <span id="playtime-sort-absent"></span></th>
                                <th class="sortable-header" onclick="setPlaytimeSort('avgQuarters')">Avg Quarters/Game <span id="playtime-sort-avg"></span></th>
                            </tr>
                        </thead>
                        <tbody id="playtime-history-tbody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Save Game Modal -->
        <div id="save-game-modal" class="modal-overlay" onclick="closeModalIfOutside(event)">
            <div class="modal-dialog" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeSaveModal()">&times;</button>
                <div class="modal-header">
                    <h2>ðŸ’¾ Save Game</h2>
                    <p style="color: #666; font-size: 0.9rem;">Save this lineup and game information</p>
                </div>
                <form id="save-game-form" onsubmit="handleSaveGame(event)">
                    <div class="form-group">
                        <label for="opponent-input">Opponent *</label>
                        <input type="text" id="opponent-input" required placeholder="e.g., Lakers, Team A">
                    </div>
                    <div class="form-group">
                        <label for="game-date-input">Game Date *</label>
                        <input type="date" id="game-date-input" required>
                    </div>
                    <div class="form-group">
                        <label>Score</label>
                        <div class="score-group">
                            <input type="number" id="team-score-input" min="0" placeholder="Team">
                            <span>vs</span>
                            <input type="number" id="opponent-score-input" min="0" placeholder="Opponent">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="game-comments-input">Game Comments</label>
                        <textarea id="game-comments-input" placeholder="Notes about the game, lineup performance, etc."></textarea>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="modal-btn modal-btn-secondary" onclick="closeSaveModal()">Cancel</button>
                        <button type="submit" class="modal-btn modal-btn-primary">Save Game</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // STORAGE SERVICE - Abstraction layer for saving/loading lineups
        // Can easily swap localStorage implementation for D1/API later
        // ============================================================================
        
        // ============================================================================
        // TEAM MANAGEMENT
        // ============================================================================
        let currentTeamId = null;
        
        const TeamService = {
            // Get all teams (active and archived)
            async getAllTeams() {
                // Check if using API backend
                if (StorageService.backend === 'api') {
                    try {
                        const response = await fetch(`${StorageService.apiBaseUrl}/api/teams`);
                        if (!response.ok) return {};
                        const result = await response.json();
                        // Convert array to object format expected by rest of code
                        const teamsObj = {};
                        (result.teams || []).forEach(team => {
                            teamsObj[team.id] = {
                                id: team.id,
                                name: team.name,
                                teamName: team.name,  // Alias for compatibility
                                sport: team.sport,
                                league: team.league || '',
                                season: team.season || '',
                                archived: team.archived === 1,
                                createdAt: team.created_at,
                                archivedAt: team.archived === 1 ? team.updated_at : null
                            };
                        });
                        return teamsObj;
                    } catch (error) {
                        console.error('Error loading teams from API:', error);
                        return {};
                    }
                } else {
                    // localStorage backend
                    try {
                        const stored = localStorage.getItem('teams');
                        return stored ? JSON.parse(stored) : {};
                    } catch (error) {
                        console.error('Error loading teams:', error);
                        return {};
                    }
                }
            },
            
            // Get active teams only
            async getActiveTeams() {
                const allTeams = await this.getAllTeams();
                return Object.values(allTeams).filter(team => !team.archived);
            },
            
            // Get archived teams
            async getArchivedTeams() {
                const allTeams = await this.getAllTeams();
                return Object.values(allTeams).filter(team => team.archived);
            },
            
            // Create a new team
            createTeam(teamData) {
                try {
                    const teams = this.getAllTeams();
                    const teamId = `team_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const team = {
                        id: teamId,
                        sport: teamData.sport,
                        league: teamData.league,
                        season: teamData.season,
                        teamName: teamData.teamName,
                        createdAt: new Date().toISOString(),
                        archived: false
                    };
                    teams[teamId] = team;
                    localStorage.setItem('teams', JSON.stringify(teams));
                    return { success: true, id: teamId, team: team };
                } catch (error) {
                    console.error('Error creating team:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // Archive a team
            archiveTeam(teamId) {
                try {
                    const teams = this.getAllTeams();
                    if (teams[teamId]) {
                        teams[teamId].archived = true;
                        teams[teamId].archivedAt = new Date().toISOString();
                        localStorage.setItem('teams', JSON.stringify(teams));
                        return { success: true };
                    }
                    return { success: false, error: 'Team not found' };
                } catch (error) {
                    console.error('Error archiving team:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // Unarchive a team
            unarchiveTeam(teamId) {
                try {
                    const teams = this.getAllTeams();
                    if (teams[teamId]) {
                        teams[teamId].archived = false;
                        delete teams[teamId].archivedAt;
                        localStorage.setItem('teams', JSON.stringify(teams));
                        return { success: true };
                    }
                    return { success: false, error: 'Team not found' };
                } catch (error) {
                    console.error('Error unarchiving team:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // Get current team ID
            getCurrentTeamId() {
                return localStorage.getItem('currentTeamId');
            },
            
            // Set current team ID
            setCurrentTeamId(teamId) {
                localStorage.setItem('currentTeamId', teamId);
                currentTeamId = teamId;
            },
            
            // Get current team
            async getCurrentTeam() {
                const teamId = this.getCurrentTeamId();
                if (!teamId) return null;
                const teams = await this.getAllTeams();
                return teams[teamId] || null;
            }
        };
        
        // Initialize current team ID
        currentTeamId = TeamService.getCurrentTeamId();

        const StorageService = {
            // Configuration loaded from config.js (edit that file to switch backends)
            get backend() { return CONFIG.backend; },
            get apiBaseUrl() { return CONFIG.apiBaseUrl; },
            
            // Get team-scoped storage key
            _getTeamKey(baseKey) {
                const teamId = TeamService.getCurrentTeamId();
                return teamId ? `${teamId}_${baseKey}` : baseKey;
            },
            
            // Save a game lineup
            async saveGame(gameName, lineupData, metadata = {}) {
                const gameData = {
                    id: this.generateId(),
                    name: gameName,
                    lineup: lineupData,
                    metadata: {
                        ...metadata,
                        savedAt: new Date().toISOString()
                    }
                };
                
                if (this.backend === 'localStorage') {
                    return this._saveToLocalStorage(gameData);
                } else if (this.backend === 'api') {
                    return this._saveToAPI(gameData);
                }
            },
            
            // Load a specific game by ID
            async loadGame(gameId) {
                if (this.backend === 'localStorage') {
                    return this._loadFromLocalStorage(gameId);
                } else if (this.backend === 'api') {
                    return this._loadFromAPI(gameId);
                }
            },
            
            // List all saved games
            async listGames() {
                if (this.backend === 'localStorage') {
                    return this._listFromLocalStorage();
                } else if (this.backend === 'api') {
                    return this._listFromAPI();
                }
            },
            
            // Update an existing game
            async updateGame(gameId, gameData) {
                if (this.backend === 'localStorage') {
                    return this._updateFromLocalStorage(gameId, gameData);
                } else if (this.backend === 'api') {
                    return this._updateFromAPI(gameId, gameData);
                }
            },

            // Delete a game
            async deleteGame(gameId) {
                if (this.backend === 'localStorage') {
                    return this._deleteFromLocalStorage(gameId);
                } else if (this.backend === 'api') {
                    return this._deleteFromAPI(gameId);
                }
            },
            
            // ===== LOCALSTORAGE IMPLEMENTATION (Current) =====
            _saveToLocalStorage(gameData) {
                try {
                    const games = this._getAllGames();
                    games[gameData.id] = gameData;
                    const key = this._getTeamKey('lineup_games');
                    localStorage.setItem(key, JSON.stringify(games));
                    return { success: true, id: gameData.id };
                } catch (error) {
                    console.error('Error saving game:', error);
                    return { success: false, error: error.message };
                }
            },
            
            _loadFromLocalStorage(gameId) {
                try {
                    const games = this._getAllGames();
                    return games[gameId] || null;
                } catch (error) {
                    console.error('Error loading game:', error);
                    return null;
                }
            },
            
            _listFromLocalStorage() {
                try {
                    const games = this._getAllGames();
                    return Object.values(games).sort((a, b) => 
                        new Date(b.metadata.savedAt) - new Date(a.metadata.savedAt)
                    );
                } catch (error) {
                    console.error('Error listing games:', error);
                    return [];
                }
            },
            
            _updateFromLocalStorage(gameId, gameData) {
                try {
                    const games = this._getAllGames();
                    if (games[gameId]) {
                        // Preserve the original ID and savedAt timestamp
                        gameData.id = gameId;
                        if (!gameData.metadata.savedAt && games[gameId].metadata.savedAt) {
                            gameData.metadata.savedAt = games[gameId].metadata.savedAt;
                        }
                        games[gameId] = gameData;
                        const key = this._getTeamKey('lineup_games');
                        localStorage.setItem(key, JSON.stringify(games));
                        return { success: true };
                    } else {
                        return { success: false, error: 'Game not found' };
                    }
                } catch (error) {
                    console.error('Error updating game:', error);
                    return { success: false, error: error.message };
                }
            },

            _deleteFromLocalStorage(gameId) {
                try {
                    const games = this._getAllGames();
                    delete games[gameId];
                    const key = this._getTeamKey('lineup_games');
                    localStorage.setItem(key, JSON.stringify(games));
                    return { success: true };
                } catch (error) {
                    console.error('Error deleting game:', error);
                    return { success: false, error: error.message };
                }
            },
            
            _getAllGames() {
                const key = this._getTeamKey('lineup_games');
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : {};
            },

            // ===== MIGRATIONS =====
            // Migrate legacy statsGpOverrides -> statsPlayed
            _migrateStatsOverridesToPlayed() {
                try {
                    const games = this._getAllGames();
                    let updated = false;

                    Object.keys(games).forEach(gameId => {
                        const game = games[gameId];
                        if (!game || !game.metadata) return;

                        if (game.metadata.statsGpOverrides && !game.metadata.statsPlayed) {
                            game.metadata.statsPlayed = {...game.metadata.statsGpOverrides};
                            delete game.metadata.statsGpOverrides;
                            games[gameId] = game;
                            updated = true;
                        }
                    });

                    if (updated) {
                        const key = this._getTeamKey('lineup_games');
                        localStorage.setItem(key, JSON.stringify(games));
                    }
                    return { success: true, updated };
                } catch (error) {
                    console.error('Migration error:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // ===== API IMPLEMENTATION (Cloudflare Workers + D1) =====
            async _saveToAPI(gameData) {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) {
                        return { success: false, error: 'No team selected' };
                    }
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/games`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: gameData.id,
                            name: gameData.name,
                            lineup: gameData.lineup,
                            metadata: gameData.metadata
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        return { success: false, error: error.error || 'Failed to save game' };
                    }
                    
                    const result = await response.json();
                    return { success: true, id: result.game.id };
                } catch (error) {
                    console.error('Error saving to API:', error);
                    return { success: false, error: error.message };
                }
            },
            
            async _loadFromAPI(gameId) {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) return null;
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/games/${encodeURIComponent(gameId)}`);
                    
                    if (!response.ok) return null;
                    
                    const result = await response.json();
                    // Transform API response to match localStorage format
                    const game = result.game;
                    return {
                        id: game.id,
                        name: game.name,
                        lineup: game.lineup,
                        metadata: game.metadata,
                        savedAt: game.updated_at
                    };
                } catch (error) {
                    console.error('Error loading from API:', error);
                    return null;
                }
            },
            
            async _listFromAPI() {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) return [];
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/games`);
                    
                    if (!response.ok) return [];
                    
                    const result = await response.json();
                    // Transform to array format expected by UI
                    return (result.games || []).map(game => ({
                        id: game.id,
                        name: game.name,
                        lineup: game.lineup,
                        metadata: game.metadata,
                        savedAt: game.updated_at
                    }));
                } catch (error) {
                    console.error('Error listing from API:', error);
                    return [];
                }
            },
            
            async _updateFromAPI(gameId, gameData) {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) {
                        return { success: false, error: 'No team selected' };
                    }
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/games/${encodeURIComponent(gameId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: gameData.name,
                            lineup: gameData.lineup,
                            metadata: gameData.metadata
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        return { success: false, error: error.error || 'Failed to update game' };
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('Error updating in API:', error);
                    return { success: false, error: error.message };
                }
            },

            async _deleteFromAPI(gameId) {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) {
                        return { success: false, error: 'No team selected' };
                    }
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/games/${encodeURIComponent(gameId)}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        return { success: false, error: error.error || 'Failed to delete game' };
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('Error deleting from API:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // Helper to generate unique IDs
            generateId() {
                return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            },

            // ===== ROSTER STORAGE =====
            // Save roster (for future games - affects new games going forward)
            async saveRoster(rosterData) {
                if (this.backend === 'localStorage') {
                    return this._saveRosterToLocalStorage(rosterData);
                } else if (this.backend === 'api') {
                    return this._saveRosterToAPI(rosterData);
                }
            },

            // Load roster
            async loadRoster() {
                if (this.backend === 'localStorage') {
                    return this._loadRosterFromLocalStorage();
                } else if (this.backend === 'api') {
                    return this._loadRosterFromAPI();
                }
            },

            // Update player names across all saved games (for name changes)
            async updatePlayerNamesInAllGames(playerNameMap) {
                // playerNameMap: { playerId: newName }
                if (this.backend === 'localStorage') {
                    return this._updatePlayerNamesInLocalStorage(playerNameMap);
                } else if (this.backend === 'api') {
                    return this._updatePlayerNamesInAPI(playerNameMap);
                }
            },

            // ===== ROSTER LOCALSTORAGE IMPLEMENTATION =====
            _saveRosterToLocalStorage(rosterData) {
                try {
                    const key = this._getTeamKey('lineup_roster');
                    localStorage.setItem(key, JSON.stringify(rosterData));
                    return { success: true };
                } catch (error) {
                    console.error('Error saving roster:', error);
                    return { success: false, error: error.message };
                }
            },

            _loadRosterFromLocalStorage() {
                try {
                    const key = this._getTeamKey('lineup_roster');
                    const stored = localStorage.getItem(key);
                    return stored ? JSON.parse(stored) : null;
                } catch (error) {
                    console.error('Error loading roster:', error);
                    return null;
                }
            },

            _updatePlayerNamesInLocalStorage(playerNameMap) {
                try {
                    const games = this._getAllGames();
                    let updatedCount = 0;

                    Object.keys(games).forEach(gameId => {
                        const game = games[gameId];
                        if (game.metadata && game.metadata.roster) {
                            let needsUpdate = false;
                            game.metadata.roster.forEach(player => {
                                if (playerNameMap[player.id] && player.name !== playerNameMap[player.id]) {
                                    player.name = playerNameMap[player.id];
                                    needsUpdate = true;
                                }
                            });
                            if (needsUpdate) {
                                games[gameId] = game;
                                updatedCount++;
                            }
                        }
                    });

                    if (updatedCount > 0) {
                        const key = this._getTeamKey('lineup_games');
                        localStorage.setItem(key, JSON.stringify(games));
                    }
                    return { success: true, updatedCount: updatedCount };
                } catch (error) {
                    console.error('Error updating player names:', error);
                    return { success: false, error: error.message };
                }
            },

            // ===== ROSTER API IMPLEMENTATION (Cloudflare Workers + D1) =====
            async _saveRosterToAPI(rosterData) {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) {
                        return { success: false, error: 'No team selected' };
                    }
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/roster`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            players: rosterData.players || []
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        return { success: false, error: error.error || 'Failed to save roster' };
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('Error saving roster to API:', error);
                    return { success: false, error: error.message };
                }
            },

            async _loadRosterFromAPI() {
                try {
                    const teamId = TeamService.getCurrentTeamId();
                    if (!teamId) return null;
                    
                    const response = await fetch(`${this.apiBaseUrl}/api/teams/${encodeURIComponent(teamId)}/roster`);
                    
                    if (!response.ok) return null;
                    
                    const result = await response.json();
                    // Transform API response to match localStorage format
                    return {
                        players: result.roster.players || [],
                        lastUpdated: result.roster.updated_at
                    };
                } catch (error) {
                    console.error('Error loading roster from API:', error);
                    return null;
                }
            },

            async _updatePlayerNamesInAPI(playerNameMap) {
                // For API backend, we need to update names in all games
                // This is more complex - fetch all games, update names, save back
                try {
                    const games = await this._listFromAPI();
                    let updatedCount = 0;
                    
                    for (const game of games) {
                        if (game.metadata && game.metadata.roster) {
                            let needsUpdate = false;
                            game.metadata.roster.forEach(player => {
                                if (playerNameMap[player.id] && player.name !== playerNameMap[player.id]) {
                                    player.name = playerNameMap[player.id];
                                    needsUpdate = true;
                                }
                            });
                            
                            if (needsUpdate) {
                                await this._updateFromAPI(game.id, game);
                                updatedCount++;
                            }
                        }
                    }
                    
                    return { success: true, updatedCount };
                } catch (error) {
                    console.error('Error updating player names in API:', error);
                    return { success: false, error: error.message };
                }
            },

        };
        
        // ============================================================================
        // APPLICATION CODE
        // ============================================================================
        
        // Default players - will be loaded from storage or use defaults
        const defaultPlayers = [
            { id: 1, name: 'Noah', number: '', present: true, star: false, positions: [2,3,4,5] },
            { id: 2, name: 'Reyansh', number: '', present: true, star: false, positions: [1,2,3] },
            { id: 3, name: 'Colin', number: '', present: true, star: true, positions: [3,4,5] },
            { id: 4, name: 'John', number: '', present: true, star: true, positions: [1,2,3,4] },
            { id: 5, name: 'Iskandar', number: '', present: true, star: false, positions: [1,2,3] },
            { id: 6, name: 'Arjun', number: '', present: true, star: true, positions: [1,2,3,4] },
            { id: 7, name: 'Jacob O', number: '', present: true, star: false, positions: [1,2,3] },
            { id: 8, name: 'Spencer', number: '', present: true, star: false, positions: [3,4,5] },
            { id: 9, name: 'Aarav', number: '', present: true, star: false, positions: [2,3,4] },
            { id: 10, name: 'Jacob S', number: '', present: true, star: false, positions: [2,3,4,5] }
        ];

        let players = [];
        let nextPlayerId = 11;
        let editingPlayerId = null;
        let currentLineupData = null; // Store current lineup for editing
        let currentViewingGameId = null; // Track which game is being viewed
        let currentViewingGame = null; // Store the full game data
        let viewGameEditMode = false; // Track if we're in edit mode
        let viewGameEditedCells = {}; // Track edited cells in view game mode

        // ============================================================================
        // NAVIGATION FUNCTIONS
        // ============================================================================

        function navigateTo(pageId) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            // Update navigation active state
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Map page IDs to nav link IDs
            const navMap = {
                'team-selection-page': null,
                'team-info-page': 'nav-info',
                'edit-roster-page': 'nav-roster',
                'games-list-page': 'nav-games',
                'new-game-page': 'nav-new-game',
                'playtime-history-page': 'nav-history',
                'view-game-page': 'nav-games', // View game is part of games
                'live-stats-page': null
            };
            
            const navLinkId = navMap[pageId];
            if (navLinkId) {
                const navLink = document.getElementById(navLinkId);
                if (navLink) {
                    navLink.classList.add('active');
                }
            }
            
            // Show target page
            const targetPage = document.getElementById(pageId);
            if (targetPage) {
                targetPage.classList.add('active');
                
                // Scroll to top of page, window, body, and html
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
                targetPage.scrollTop = 0;
                
                // Update navigation title based on current team (except on team selection page)
                if (pageId === 'team-selection-page') {
                    const navTitle = document.getElementById('nav-title');
                    if (navTitle) {
                        navTitle.textContent = 'Select a Team';
                    }
                } else {
                    updateTeamDisplay();
                }
                
                // Load page-specific content
                if (pageId === 'team-selection-page') {
                    renderTeamSelection().catch(err => console.error('Error rendering team selection:', err));
                } else if (pageId === 'team-info-page') {
                    renderTeamInfo().catch(err => console.error('Error rendering team info:', err));
                } else if (pageId === 'edit-roster-page') {
                    // Ensure roster is loaded for current team before rendering
                    loadRoster().then(() => {
                        renderRosterEdit().catch(err => console.error('Error rendering roster:', err));
                    });
                } else if (pageId === 'games-list-page') {
                    renderGamesList();
                } else if (pageId === 'new-game-page') {
                    // Ensure roster is loaded for current team before rendering
                    loadRoster().then(() => {
                        renderGameRoster().catch(err => console.error('Error rendering game roster:', err));
                        const keepStatsBtn = document.getElementById('keep-stats-btn');
                        if (keepStatsBtn) {
                            keepStatsBtn.style.display = forceUpdateGame ? 'none' : 'inline-block';
                        }
                    });
                } else if (pageId === 'playtime-history-page') {
                    // Ensure roster is loaded for current team before rendering
                    loadRoster().then(() => {
                        renderPlaytimeHistory();
                    });
                } else if (pageId === 'live-stats-page') {
                    // Ensure live stats page scrolls to top
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                        document.documentElement.scrollTop = 0;
                        document.body.scrollTop = 0;
                        targetPage.scrollTop = 0;
                        // Set scoring-tab-active class if scoring tab is active
                        const scoringTabContent = document.getElementById('scoring-tab-content');
                        const liveStatsPage = document.getElementById('live-stats-page');
                        if (scoringTabContent && scoringTabContent.classList.contains('active')) {
                            liveStatsPage.classList.add('scoring-tab-active');
                        }
                    }, 100);
                }
            }
        }
        
        // ============================================================================
        // TEAM MANAGEMENT FUNCTIONS
        // ============================================================================
        
        async function renderTeamSelection() {
            const container = document.getElementById('teams-list-container');
            const archivedContainer = document.getElementById('archived-teams-list');
            const archivedSection = document.getElementById('archived-teams-section');
            
            const activeTeams = await TeamService.getActiveTeams();
            const archivedTeams = await TeamService.getArchivedTeams();
            
            // Render active teams
            container.innerHTML = '';
            if (activeTeams.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.8); grid-column: 1/-1; padding: 40px;">No teams yet. Create your first team to get started!</p>';
            } else {
                activeTeams.forEach(team => {
                    const sportIcon = getSportIcon(team.sport);
                    const card = document.createElement('div');
                    card.className = 'team-card';
                    card.onclick = () => selectTeam(team.id);
                    const teamName = team.name || team.teamName || 'Unnamed Team';
                    card.innerHTML = `
                        <div class="team-card-header">
                            <h3 class="team-card-name">${escapeHtml(teamName)}</h3>
                            <span class="team-card-sport" title="${escapeHtml(team.sport)}">${sportIcon}</span>
                        </div>
                        <div class="team-card-info">
                            <div class="team-card-info-item">
                                <span class="team-card-info-label">League:</span> ${escapeHtml(team.league || 'N/A')}
                            </div>
                            <div class="team-card-info-item">
                                <span class="team-card-info-label">Season:</span> ${escapeHtml(team.season || 'N/A')}
                            </div>
                        </div>
                        <button class="team-card-archive-btn" onclick="event.stopPropagation(); archiveTeam('${team.id}')">Archive</button>
                    `;
                    container.appendChild(card);
                });
            }
            
            // Render archived teams
            if (archivedTeams.length > 0) {
                archivedSection.style.display = 'block';
                archivedContainer.innerHTML = '';
                archivedTeams.forEach(team => {
                    const sportIcon = getSportIcon(team.sport);
                    const card = document.createElement('div');
                    card.className = 'team-card';
                    card.style.opacity = '0.7';
                    card.onclick = () => selectTeam(team.id);
                    const teamName = team.name || team.teamName || 'Unnamed Team';
                    card.innerHTML = `
                        <div class="team-card-header">
                            <h3 class="team-card-name">${escapeHtml(teamName)}</h3>
                            <span class="team-card-sport" title="${escapeHtml(team.sport)}">${sportIcon}</span>
                        </div>
                        <div class="team-card-info">
                            <div class="team-card-info-item">
                                <span class="team-card-info-label">League:</span> ${escapeHtml(team.league || 'N/A')}
                            </div>
                            <div class="team-card-info-item">
                                <span class="team-card-info-label">Season:</span> ${escapeHtml(team.season || 'N/A')}
                            </div>
                            <div class="team-card-info-item" style="color: #999; font-style: italic;">
                                Archived
                            </div>
                        </div>
                        <button class="team-card-archive-btn" onclick="event.stopPropagation(); unarchiveTeam('${team.id}')">Unarchive</button>
                    `;
                    archivedContainer.appendChild(card);
                });
            } else {
                archivedSection.style.display = 'none';
            }
        }
        
        async function selectTeam(teamId) {
            // Check if there's an active game
            if (currentViewingGame && currentViewingGame.metadata.liveStats) {
                showConfirmModal({
                    title: 'Active Game In Progress',
                    message: 'You have an active game. You must exit the game before switching teams.',
                    submessage: 'Your current game progress will be saved and you can resume it later.',
                    confirmText: 'Exit Game',
                    cancelText: 'Stay',
                    onConfirm: async () => {
                        await autoSaveGame();
                        currentViewingGame = null;
                        currentViewingGameId = null;
                        await completeTeamSelection(teamId);
                    }
                });
                return;
            }
            
            await completeTeamSelection(teamId);
        }

        async function completeTeamSelection(teamId) {
            TeamService.setCurrentTeamId(teamId);
            currentTeamId = teamId;
            
            // Restore Blue Devils roster if this is the Blue Devils team
            restoreBlueDevilsRoster();
            
            // Clear current game state
            currentViewingGame = null;
            currentViewingGameId = null;
            
            // Reload roster for the new team
            await loadRoster();
            
            updateTeamDisplay();
            // Navigate to team info page as default
            navigateTo('team-info-page');
        }
        
        function getSportIcon(sport) {
            if (!sport) return 'âš½';
            switch(sport.toLowerCase()) {
                case 'basketball':
                    return 'ðŸ€';
                case 'lacrosse':
                    return 'ðŸ¥';
                default:
                    return 'âš½';
            }
        }
        
        async function updateTeamDisplay() {
            const currentTeam = await TeamService.getCurrentTeam();
            const teamDisplay = document.getElementById('current-team-display');
            const navTitle = document.getElementById('nav-title');
            
            // Update team switcher button
            if (teamDisplay && currentTeam) {
                const sportIcon = getSportIcon(currentTeam.sport);
                const teamName = currentTeam.name || currentTeam.teamName || 'Unnamed Team';
                teamDisplay.innerHTML = `${sportIcon} ${teamName}`;
            } else if (teamDisplay) {
                teamDisplay.textContent = 'Select Team';
            }
            
            // Update navigation title text (only the text span, not the whole element)
            const navTitleText = document.getElementById('nav-title-text');
            if (navTitleText && currentTeam) {
                const sportIcon = getSportIcon(currentTeam.sport);
                const teamName = currentTeam.name || currentTeam.teamName || 'Unnamed Team';
                navTitleText.innerHTML = `${sportIcon} ${teamName}`;
            } else if (navTitleText) {
                navTitleText.textContent = 'Select a Team';
            }
            
            // Update team selector dropdown if it's open
            const dropdown = document.getElementById('team-selector-dropdown');
            if (dropdown && dropdown.classList.contains('show')) {
                renderTeamSelectorDropdown().catch(err => console.error('Error rendering team selector:', err));
            }
        }
        
        function toggleTeamSelector() {
            const dropdown = document.getElementById('team-selector-dropdown');
            if (dropdown) {
                dropdown.classList.toggle('show');
                if (dropdown.classList.contains('show')) {
                    renderTeamSelectorDropdown().catch(err => console.error('Error rendering team selector:', err));
                }
            }
        }

        function closeTeamSelector() {
            const dropdown = document.getElementById('team-selector-dropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
        }

        async function renderTeamSelectorDropdown() {
            const container = document.getElementById('team-selector-list');
            if (!container) return;

            container.innerHTML = '<div class="team-selector-item" style="padding: 20px; text-align: center; color: #999;">Loading teams...</div>';

            try {
                const activeTeams = await TeamService.getActiveTeams();
                const currentTeamId = TeamService.getCurrentTeamId();

            if (activeTeams.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'team-selector-item';
                emptyItem.style.padding = '20px';
                emptyItem.style.textAlign = 'center';
                emptyItem.style.color = '#999';
                emptyItem.textContent = 'No teams yet. Click "Add Team" to create one.';
                container.appendChild(emptyItem);
                return;
            }

            activeTeams.forEach(team => {
                const item = document.createElement('div');
                item.className = 'team-selector-item';
                if (team.id === currentTeamId) {
                    item.classList.add('active');
                }

                const sportIcon = getSportIcon(team.sport);
                const teamName = team.teamName || team.name || 'Unnamed Team';
                const league = team.league || 'N/A';
                const season = team.season || 'N/A';

                item.innerHTML = `
                    <span class="team-card-sport" title="${escapeHtml(team.sport || '')}">${sportIcon}</span>
                    <div class="team-selector-item-info">
                        <div class="team-selector-item-name">${escapeHtml(teamName)}</div>
                        <div class="team-selector-item-details">${escapeHtml(league)} â€¢ ${escapeHtml(season)}</div>
                    </div>
                `;

                item.onclick = (e) => {
                    e.stopPropagation();
                    if (team.id !== currentTeamId) {
                        selectTeam(team.id);
                    }
                    closeTeamSelector();
                };

                container.appendChild(item);
            });
            } catch (error) {
                console.error('Error rendering team selector:', error);
                container.innerHTML = '<div class="team-selector-item" style="padding: 20px; text-align: center; color: #dc3545;">Error loading teams. Please refresh the page.</div>';
            }
        }

        function switchToTeamSelection() {
            // Check if there's an active game
            if (currentViewingGame && currentViewingGame.metadata.liveStats) {
                showConfirmModal({
                    title: 'Active Game In Progress',
                    message: 'You have an active game. You must exit the game before switching teams.',
                    submessage: 'Your current game progress will be saved and you can resume it later.',
                    confirmText: 'Exit Game',
                    cancelText: 'Stay',
                    onConfirm: async () => {
                        await autoSaveGame();
                        currentViewingGame = null;
                        currentViewingGameId = null;
                        toggleTeamSelector();
                    }
                });
                return;
            }
            toggleTeamSelector();
        }
        
        function archiveTeam(teamId) {
            showConfirmModal({
                title: 'Archive Team',
                message: 'Are you sure you want to archive this team?',
                submessage: 'You can unarchive it later from the team selection screen.',
                confirmText: 'Archive',
                cancelText: 'Cancel',
                onConfirm: () => {
                    const result = TeamService.archiveTeam(teamId);
                    if (result.success) {
                        // If archiving current team, switch to team selection
                        if (currentTeamId === teamId) {
                            TeamService.setCurrentTeamId(null);
                            currentTeamId = null;
                            navigateTo('team-selection-page');
                        } else {
                            renderTeamSelection();
                        }
                    } else {
                        showError(`Failed to archive team: ${result.error}`);
                    }
                }
            });
        }
        
        function unarchiveTeam(teamId) {
            const result = TeamService.unarchiveTeam(teamId);
            if (result.success) {
                renderTeamSelection();
            } else {
                alert(`Failed to unarchive team: ${result.error}`);
            }
        }
        
        function openCreateTeamModal() {
            document.getElementById('create-team-modal').classList.add('show');
            document.getElementById('create-team-sport').focus();
        }
        
        function closeCreateTeamModal() {
            document.getElementById('create-team-modal').classList.remove('show');
            document.getElementById('create-team-form').reset();
        }
        
        async function handleCreateTeam(event) {
            event.preventDefault();
            
            const sport = document.getElementById('create-team-sport').value.trim();
            const league = document.getElementById('create-team-league').value.trim();
            const season = document.getElementById('create-team-season').value.trim();
            const teamName = document.getElementById('create-team-name').value.trim();
            
            if (!sport || !league || !season || !teamName) {
                alert('Please fill in all fields');
                return;
            }
            
            const result = TeamService.createTeam({
                sport,
                league,
                season,
                teamName
            });
            
            if (result.success) {
                closeCreateTeamModal();
                closeTeamSelector();
                // Select the newly created team
                await selectTeam(result.id);
            } else {
                alert(`Failed to create team: ${result.error}`);
            }
        }
        
        // Migration function - migrate existing data to default team
        function migrateExistingDataToDefaultTeam() {
            // Check if migration has already been done
            if (localStorage.getItem('dataMigratedToTeams') === 'true') {
                return;
            }
            
            // Create default team
            const defaultTeam = TeamService.createTeam({
                sport: 'Basketball',
                league: 'Vienna Basketball 3rd',
                season: '2025-2026',
                teamName: 'Blue Devils'
            });
            
            if (defaultTeam.success) {
                // Set as current team
                TeamService.setCurrentTeamId(defaultTeam.id);
                currentTeamId = defaultTeam.id;
                
                // Migrate existing roster
                const oldRoster = localStorage.getItem('lineup_roster');
                const rosterKey = `${defaultTeam.id}_lineup_roster`;
                
                if (oldRoster) {
                    // Use existing roster if available
                    localStorage.setItem(rosterKey, oldRoster);
                } else {
                    // If no old roster, use default players for Blue Devils
                    const defaultRosterData = {
                        players: defaultPlayers.map(p => ({
                            id: p.id,
                            name: p.name,
                            number: p.number || '',
                            star: p.star,
                            positions: p.positions
                        })),
                        nextPlayerId: 11,
                        lastUpdated: new Date().toISOString()
                    };
                    localStorage.setItem(rosterKey, JSON.stringify(defaultRosterData));
                }
                
                // Migrate existing games
                const oldGames = localStorage.getItem('lineup_games');
                if (oldGames) {
                    const gamesKey = `${defaultTeam.id}_lineup_games`;
                    localStorage.setItem(gamesKey, oldGames);
                }
                
                // Mark migration as complete
                localStorage.setItem('dataMigratedToTeams', 'true');
                
                console.log('Data migrated to default team:', defaultTeam.id);
            }
        }
        
        // Function to restore Blue Devils roster if it's missing
        function restoreBlueDevilsRoster() {
            const teams = TeamService.getAllTeams();
            const blueDevilsTeam = Object.values(teams).find(t => 
                t.teamName === 'Blue Devils' && 
                t.league === 'Vienna Basketball 3rd' && 
                t.season === '2025-2026'
            );
            
            if (blueDevilsTeam) {
                const rosterKey = `${blueDevilsTeam.id}_lineup_roster`;
                const existingRoster = localStorage.getItem(rosterKey);
                
                // If roster is missing or empty, restore default players
                if (!existingRoster || JSON.parse(existingRoster).players.length === 0) {
                    const defaultRosterData = {
                        players: defaultPlayers.map(p => ({
                            id: p.id,
                            name: p.name,
                            number: p.number || '',
                            star: p.star,
                            positions: p.positions
                        })),
                        nextPlayerId: 11,
                        lastUpdated: new Date().toISOString()
                    };
                    localStorage.setItem(rosterKey, JSON.stringify(defaultRosterData));
                    console.log('Restored Blue Devils default roster');
                }
            }
        }

        // ============================================================================
        // TEAM INFO PAGE
        // ============================================================================

        async function renderTeamInfo() {
            const container = document.getElementById('team-info-container');
            if (!container) return;

            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Please select a team first.</p>';
                return;
            }

            // Get team statistics
            const games = StorageService._getAllGames();
            const gamesList = Object.values(games);
            const totalGames = gamesList.length;

            // Calculate record
            let wins = 0, losses = 0, ties = 0;
            gamesList.forEach(game => {
                if (game.metadata && game.metadata.result) {
                    if (game.metadata.result === 'win') wins++;
                    else if (game.metadata.result === 'loss') losses++;
                    else if (game.metadata.result === 'tie') ties++;
                }
            });

            // Get roster count
            const roster = StorageService._loadRosterFromLocalStorage();
            const playerCount = roster && roster.players ? roster.players.length : 0;

            // Calculate total points scored
            let totalPointsScored = 0;
            let totalPointsAllowed = 0;
            gamesList.forEach(game => {
                if (game.metadata && game.metadata.liveStats) {
                    totalPointsScored += game.metadata.liveStats.teamScore || 0;
                    totalPointsAllowed += game.metadata.liveStats.opponentScore || 0;
                }
            });

            const sportIcon = getSportIcon(currentTeam.sport);
            const teamName = currentTeam.name || currentTeam.teamName || 'Unnamed Team';

            container.innerHTML = `
                <div class="team-info-header">
                    <div class="team-info-icon">${sportIcon}</div>
                    <div class="team-info-title">
                        <h3>${escapeHtml(teamName)}</h3>
                        <p>${escapeHtml(currentTeam.league || 'N/A')} â€¢ ${escapeHtml(currentTeam.season || 'N/A')}</p>
                    </div>
                </div>

                <div class="team-info-grid">
                    <div class="team-info-stat-card">
                        <div class="team-info-stat-value">${playerCount}</div>
                        <div class="team-info-stat-label">Players</div>
                    </div>
                    <div class="team-info-stat-card">
                        <div class="team-info-stat-value">${totalGames}</div>
                        <div class="team-info-stat-label">Games Played</div>
                    </div>
                    <div class="team-info-stat-card">
                        <div class="team-info-stat-value">
                            <span class="team-info-record-wins">${wins}</span>-<span class="team-info-record-losses">${losses}</span>${ties > 0 ? `-<span class="team-info-record-ties">${ties}</span>` : ''}
                        </div>
                        <div class="team-info-stat-label">Record (W-L${ties > 0 ? '-T' : ''})</div>
                    </div>
                    <div class="team-info-stat-card">
                        <div class="team-info-stat-value">${totalPointsScored}</div>
                        <div class="team-info-stat-label">Points Scored</div>
                    </div>
                </div>

                <div class="team-info-details">
                    <h4>Team Details</h4>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Sport</span>
                        <span class="team-info-detail-value">${escapeHtml(currentTeam.sport)}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">League</span>
                        <span class="team-info-detail-value">${escapeHtml(currentTeam.league)}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Season</span>
                        <span class="team-info-detail-value">${escapeHtml(currentTeam.season)}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Team Name</span>
                        <span class="team-info-detail-value">${escapeHtml(currentTeam.teamName)}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Win Percentage</span>
                        <span class="team-info-detail-value">${totalGames > 0 ? ((wins / totalGames) * 100).toFixed(1) + '%' : 'N/A'}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Points Per Game</span>
                        <span class="team-info-detail-value">${totalGames > 0 ? (totalPointsScored / totalGames).toFixed(1) : 'N/A'}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Points Allowed Per Game</span>
                        <span class="team-info-detail-value">${totalGames > 0 ? (totalPointsAllowed / totalGames).toFixed(1) : 'N/A'}</span>
                    </div>
                    <div class="team-info-detail-row">
                        <span class="team-info-detail-label">Point Differential</span>
                        <span class="team-info-detail-value" style="color: ${totalPointsScored - totalPointsAllowed >= 0 ? '#28a745' : '#dc3545'}">${totalPointsScored - totalPointsAllowed >= 0 ? '+' : ''}${totalPointsScored - totalPointsAllowed}</span>
                    </div>
                </div>

                <div class="team-info-actions">
                    <button class="team-info-action-btn primary" onclick="navigateTo('new-game-page')">ðŸ€ Start New Game</button>
                    <button class="team-info-action-btn secondary" onclick="navigateTo('edit-roster-page')">âœï¸ Edit Roster</button>
                    <button class="team-info-action-btn danger" onclick="archiveCurrentTeam()">ðŸ“¦ Archive Team</button>
                </div>
            `;
        }

        async function archiveCurrentTeam() {
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) return;
            
            const teamName = currentTeam.name || currentTeam.teamName || 'this team';
            showConfirmModal({
                title: 'Archive Team',
                message: `Are you sure you want to archive "${teamName}"?`,
                submessage: 'You can unarchive it later from the team selection screen.',
                confirmText: 'Archive',
                cancelText: 'Cancel',
                onConfirm: () => {
                    const result = TeamService.archiveTeam(currentTeam.id);
                    if (result.success) {
                        TeamService.setCurrentTeamId(null);
                        currentTeamId = null;
                        updateTeamDisplay().catch(err => console.error('Error updating team display:', err));
                        navigateTo('team-selection-page');
                    }
                }
            });
        }

        // ============================================================================
        // ROSTER RENDERING - Different views for different pages
        // ============================================================================

        async function renderRosterEdit() {
            const container = document.getElementById('roster-edit-container');
            // Save scroll position before clearing
            const scrollPosition = window.scrollY || document.documentElement.scrollTop;
            container.innerHTML = '';
            
            // Check current team sport
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Please select a team first.</p>';
                return;
            }
            
            // Show placeholder for Lacrosse
            if (currentTeam.sport && currentTeam.sport.toLowerCase() === 'lacrosse') {
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #666;">
                        <div style="font-size: 4rem; margin-bottom: 20px;">ðŸ¥</div>
                        <h3 style="color: #004E89; margin-bottom: 10px;">Lacrosse Roster Coming Soon</h3>
                        <p>Lacrosse roster management is under development.</p>
                    </div>
                `;
                return;
            }

            // Ensure players array exists and is initialized
            if (!players || !Array.isArray(players)) {
                players = [];
            }

            if (players.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No players in roster. Add players below.</p>';
            }

            players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.setAttribute('data-player-id', player.id); // Add data attribute for easy lookup
                
                const isEditing = editingPlayerId === player.id;
                
                // Ensure positions array exists
                if (!player.positions || !Array.isArray(player.positions)) {
                    player.positions = [1,2,3,4,5]; // Default to all positions
                }
                
                card.innerHTML = `
                    <div class="player-header">
                        ${isEditing 
                            ? `<input type="text" class="player-name-input" value="${escapeHtml(player.name || '')}" 
                                     onblur="savePlayerName('${player.id}', this.value)" 
                                     onkeypress="if(event.key==='Enter') { savePlayerName('${player.id}', this.value); this.blur(); }"
                                     autofocus>` 
                            : `<span class="player-name">
                                 ${escapeHtml(player.name || '')} ${player.star ? 'â­' : ''}
                               </span>
                               <button class="edit-btn" onclick="editPlayerName('${player.id}')">âœï¸</button>`
                        }
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 0.85rem; color: #666;">#</span>
                            <input type="text" value="${escapeHtml(player.number || '')}" 
                                   onblur="savePlayerNumber('${player.id}', this.value)"
                                   inputmode="numeric"
                                   maxlength="3"
                                   style="width: 48px; padding: 4px 6px; border: 1px solid #ccc; border-radius: 6px; text-align: center;">
                        </div>
                        <button class="star-btn ${player.star ? 'active' : ''}" onclick="toggleStar('${player.id}')">
                            â­
                        </button>
                    </div>
                    <div class="positions">
                        ${[1,2,3,4,5].map(pos => `
                            <button class="position-btn ${player.positions && player.positions.includes(pos) ? 'active' : ''}" 
                                    data-position="${pos}"
                                    onclick="togglePosition('${player.id}', ${pos})">
                                ${pos}
                            </button>
                        `).join('')}
                    </div>
                    <div class="player-actions">
                        <button class="remove-btn" onclick="removePlayer('${player.id}')">Remove</button>
                    </div>
                `;
                
                container.appendChild(card);
            });
            
            // Restore scroll position after render (only if we saved it)
            if (typeof scrollPosition !== 'undefined') {
                requestAnimationFrame(() => {
                    window.scrollTo(0, scrollPosition);
                });
            }
        }
        
        // Helper function to update just the position buttons for a specific player
        function updatePlayerPositions(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const playerCard = document.querySelector(`[data-player-id="${playerId}"]`);
            if (!playerCard) return;
            
            const positionsContainer = playerCard.querySelector('.positions');
            if (!positionsContainer) return;
            
            // Update position buttons
            [1,2,3,4,5].forEach(pos => {
                const btn = positionsContainer.querySelector(`[data-position="${pos}"]`);
                if (btn) {
                    if (player.positions && player.positions.includes(pos)) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }
        
        // Helper function to update just the star button for a specific player
        function updatePlayerStar(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const playerCard = document.querySelector(`[data-player-id="${playerId}"]`);
            if (!playerCard) return;
            
            const starBtn = playerCard.querySelector('.star-btn');
            if (starBtn) {
                if (player.star) {
                    starBtn.classList.add('active');
                } else {
                    starBtn.classList.remove('active');
                }
            }
            
            // Also update star icon in name
            const playerName = playerCard.querySelector('.player-name');
            if (playerName) {
                const nameText = player.name || '';
                playerName.innerHTML = `${escapeHtml(nameText)} ${player.star ? 'â­' : ''}`;
            }
        }

        async function renderGameRoster() {
            // Check current team sport
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                const container = document.getElementById('game-roster-container');
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Please select a team first.</p>';
                return;
            }
            
            // Show placeholder for Lacrosse
            if (currentTeam.sport && currentTeam.sport.toLowerCase() === 'lacrosse') {
                const container = document.getElementById('game-roster-container');
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #666;">
                        <div style="font-size: 4rem; margin-bottom: 20px;">ðŸ¥</div>
                        <h3 style="color: #004E89; margin-bottom: 10px;">Lacrosse Games Coming Soon</h3>
                        <p>Lacrosse game creation is under development.</p>
                    </div>
                `;
                // Hide buttons
                const generateBtn = document.querySelector('.generate-btn');
                const keepStatsBtn = document.getElementById('keep-stats-btn');
                const testBtn = document.querySelector('.generate-btn[onclick="createTestGame()"]');
                if (generateBtn) generateBtn.style.display = 'none';
                if (keepStatsBtn) keepStatsBtn.style.display = 'none';
                if (testBtn) testBtn.style.display = 'none';
                return;
            } else {
                // Show buttons for basketball
                const generateBtn = document.querySelector('.generate-btn');
                const keepStatsBtn = document.getElementById('keep-stats-btn');
                const testBtn = document.querySelector('.generate-btn[onclick="createTestGame()"]');
                if (generateBtn) generateBtn.style.display = '';
                if (keepStatsBtn) keepStatsBtn.style.display = '';
                if (testBtn) testBtn.style.display = '';
            }
            
            // Continue with normal basketball roster rendering
            const container = document.getElementById('game-roster-container');
            container.innerHTML = '';
            
            // Show message if no players in roster
            if (players.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <p style="margin-bottom: 20px;">No players in roster yet.</p>
                        <p>Go to <strong>Roster</strong> to add players to this team.</p>
                    </div>
                `;
                return;
            }

            players.forEach(player => {
                const card = document.createElement('div');
                card.className = `player-card ${player.present ? 'present' : 'absent'}`;
                
                card.innerHTML = `
                    <div class="player-header">
                        <span class="player-name">
                            ${player.name} ${player.star ? 'â­' : ''}
                        </span>
                        <input type="checkbox" class="presence-checkbox" ${player.present ? 'checked' : ''} 
                               onchange="togglePresence(${player.id})">
                        <label>Present</label>
                    </div>
                    <div class="positions">
                        ${player.positions.map(pos => `
                            <span class="position-btn active" style="cursor: default;">
                                ${pos}
                            </span>
                        `).join('')}
                    </div>
                `;
                
                container.appendChild(card);
            });
        }


        async function editPlayerName(playerId) {
            editingPlayerId = playerId;
            await renderRosterEdit();
        }

        async function savePlayerName(playerId, newName) {
            const player = players.find(p => p.id === playerId);
            if (player && newName.trim()) {
                const oldName = player.name;
                const newNameTrimmed = newName.trim();
                
                // Only update if name actually changed
                if (oldName !== newNameTrimmed) {
                    player.name = newNameTrimmed;
                    
                    // Update name in all saved games (retroactive update)
                    await StorageService.updatePlayerNamesInAllGames({
                        [playerId]: newNameTrimmed
                    });
                }
            }
            editingPlayerId = null;
            await renderRosterEdit();
            saveRoster();
        }

        function savePlayerNumber(playerId, newNumber) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const sanitized = String(newNumber || '').replace(/[^0-9]/g, '').slice(0, 3);
            player.number = sanitized;
            saveRoster();
        }

        async function toggleStar(playerId) {
            const player = players.find(p => p.id === playerId);
            if (player) {
                player.star = !player.star;
                // Update only the star button for this player (no full re-render)
                updatePlayerStar(playerId);
                saveRoster(); // Save roster (affects future games only)
            }
        }

        function togglePresence(playerId) {
            const player = players.find(p => p.id === playerId);
            if (player) {
                player.present = !player.present;
                // Update the appropriate view
                const activePage = document.querySelector('.page.active');
                if (activePage && activePage.id === 'new-game-page') {
                    renderGameRoster().catch(err => console.error('Error rendering game roster:', err));
                }
            }
        }

        async function togglePosition(playerId, position) {
            const player = players.find(p => p.id === playerId);
            if (player) {
                // Ensure positions array exists
                if (!player.positions || !Array.isArray(player.positions)) {
                    player.positions = [1,2,3,4,5];
                }
                
                const index = player.positions.indexOf(position);
                if (index > -1) {
                    player.positions.splice(index, 1);
                } else {
                    player.positions.push(position);
                    player.positions.sort();
                }
                
                // Update only the position buttons for this player (no full re-render)
                updatePlayerPositions(playerId);
                saveRoster(); // Save roster (affects future games only)
            }
        }

        function removePlayer(playerId) {
            const player = players.find(p => p.id === playerId);
            const playerName = player ? player.name : 'this player';
            
            showConfirmModal({
                title: 'Remove Player',
                message: `Remove ${playerName} from the roster?`,
                submessage: 'This will not affect previously saved games.',
                confirmText: 'Remove',
                confirmStyle: 'danger',
                cancelText: 'Cancel',
                onConfirm: async () => {
                    players = players.filter(p => p.id !== playerId);
                    await renderRosterEdit();
                    saveRoster();
                }
            });
        }

        async function addPlayer() {
            players.push({
                id: nextPlayerId++,
                name: `Player ${nextPlayerId - 10}`,
                number: '',
                present: true,
                star: false,
                positions: [1,2,3,4,5]
            });
            await renderRosterEdit();
            saveRoster();
        }

        // Save roster to storage (for future games)
        async function saveRoster() {
            const rosterData = {
                players: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    number: p.number || '',
                    star: p.star,
                    positions: p.positions
                })),
                nextPlayerId: nextPlayerId,
                lastUpdated: new Date().toISOString()
            };
            await StorageService.saveRoster(rosterData);
        }

        // Load roster from storage
        async function loadRoster() {
            // Check if we have a team selected
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                players = [];
                nextPlayerId = 1;
                return;
            }
            
            // Clear current players array first to prevent showing old team's data
            players = [];
            
            const savedRoster = await StorageService.loadRoster();
            if (savedRoster && savedRoster.players) {
                // Use saved roster
                players = savedRoster.players.map(p => ({
                    ...p,
                    number: p.number || '',
                    present: p.present !== undefined ? p.present : true, // Always default to present for roster edit page
                    star: p.star || false,
                    positions: p.positions || (p.position ? [parseInt(p.position)] : [1,2,3,4,5]) // Ensure positions array exists
                }));
                if (savedRoster.nextPlayerId) {
                    nextPlayerId = savedRoster.nextPlayerId;
                } else {
                    // Calculate nextPlayerId from existing players
                    const maxId = Math.max(...players.map(p => {
                        const idStr = String(p.id || '');
                        return parseInt(idStr.replace('p', '')) || 0;
                    }), 0);
                    nextPlayerId = maxId + 1;
                }
            } else {
                // No saved roster for this team, start with empty array
                players = [];
                nextPlayerId = 1;
            }
        }

        function generateLineup() {
            const errorDiv = document.getElementById('error-message');
            const lineupSection = document.getElementById('lineup-section');
            errorDiv.classList.remove('show');
            lineupSection.classList.remove('show');

            const presentPlayers = players.filter(p => p.present);
            
            if (presentPlayers.length < 5) {
                showError('Need at least 5 present players to generate a lineup.');
                return;
            }

            // Validate that all positions can be covered
            for (let pos = 1; pos <= 5; pos++) {
                const canPlayPosition = presentPlayers.filter(p => p.positions.includes(pos));
                if (canPlayPosition.length === 0) {
                    showError(`No present players can play position ${pos}. Please check player positions.`);
                    return;
                }
            }

            const lineup = solveLineup(presentPlayers);
            
            if (!lineup) {
                showError('Could not generate a lineup. Please try again.');
                return;
            }

            // Display lineup regardless - violations are tracked for optimization
            displayLineup(lineup.quarters);
            lineupSection.classList.add('show');
            
            // Show warnings for violations, but still display the lineup
            if (lineup.violations > 0) {
                let warningMsg = '';
                const emptyDetails = [];
                
                // Check which quarters have empty positions (critical issue)
                for (let q = 0; q < 4; q++) {
                    const emptyCount = lineup.quarters[q].filter(slot => !slot).length;
                    if (emptyCount > 0) {
                        emptyDetails.push(`Q${q+1}: ${emptyCount} empty`);
                    }
                }
                
                if (emptyDetails.length > 0) {
                    warningMsg = `Warning: Some positions are unfilled: ${emptyDetails.join(', ')}`;
                } else if (lineup.violations >= 5000) {
                    warningMsg = `Warning: Critical rule violations detected (violations: ${lineup.violations}). Lineup may not meet all requirements.`;
                } else if (lineup.violations >= 500) {
                    warningMsg = `Note: Some secondary rules were not fully satisfied (e.g., star player distribution). The lineup is still valid.`;
                }
                
                if (warningMsg) {
                    showError(warningMsg);
                }
            } else {
                // Clear any previous error messages
                const errorDiv = document.getElementById('error-message');
                errorDiv.classList.remove('show');
            }
        }

        function solveLineup(presentPlayers) {
            const NUM_QUARTERS = 4;
            const NUM_POSITIONS = 5;
            const ATTEMPTS = 15000;
            const MIN_QUARTERS = 2;
            
            let bestSolution = null;
            let bestViolations = Infinity;

            for (let attempt = 0; attempt < ATTEMPTS; attempt++) {
                const quarters = Array(NUM_QUARTERS).fill(null).map(() => Array(NUM_POSITIONS).fill(null));
                const playerLastQuarter = {}; // track last quarter each player played (-1 = never, q = last played in quarter q)
                const playerQuartersPlayed = {}; // track total quarters per player
                const playerSittingStreak = {}; // track consecutive quarters sitting
                
                presentPlayers.forEach(p => {
                    playerLastQuarter[p.id] = -1;
                    playerQuartersPlayed[p.id] = 0;
                    playerSittingStreak[p.id] = 0;
                });

                let violations = 0;
                const needsStars = presentPlayers.length >= 7;

                // Generate each quarter
                for (let q = 0; q < NUM_QUARTERS; q++) {
                    const quarter = quarters[q];
                    const quarterPlayers = new Set(); // Track players already in this quarter
                    
                    // Calculate who MUST play (sat last quarter)
                    const mustPlay = [];
                    for (const player of presentPlayers) {
                        // If player sat last quarter, they MUST play this quarter
                        if (q > 0 && playerSittingStreak[player.id] >= 1 && playerQuartersPlayed[player.id] < NUM_QUARTERS) {
                            mustPlay.push(player);
                        }
                        // If player hasn't played enough yet and we're getting late, prioritize
                        const quartersRemaining = NUM_QUARTERS - q;
                        if (playerQuartersPlayed[player.id] + quartersRemaining < MIN_QUARTERS) {
                            mustPlay.push(player);
                        }
                    }

                    // Shuffle for randomness but prioritize must-play
                    mustPlay.sort(() => Math.random() - 0.5);
                    const otherPlayers = presentPlayers.filter(p => !mustPlay.includes(p));
                    otherPlayers.sort(() => Math.random() - 0.5);

                    // Track stars in this quarter
                    let starsInQuarter = 0;

                    // Function to assign player to position
                    const assignPlayer = (player, position) => {
                        quarter[position - 1] = { playerId: player.id, position: position };
                        quarterPlayers.add(player.id);
                        playerLastQuarter[player.id] = q;
                        playerQuartersPlayed[player.id]++;
                        playerSittingStreak[player.id] = 0;
                        if (player.star) starsInQuarter++;
                    };

                    // First: Assign MUST PLAY players
                    for (const player of mustPlay) {
                        if (quarterPlayers.has(player.id)) continue;
                        
                        const availablePositions = player.positions.filter(pos => !quarter[pos - 1]);
                        if (availablePositions.length > 0) {
                            const pos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                            assignPlayer(player, pos);
                        }
                    }

                    // Second: Prefer star players if needed (but don't force - prioritize rotation)
                    // Only try to add stars if we have 0 and 7+ players, and only if it doesn't force a player to play all 4 quarters
                    if (needsStars && starsInQuarter === 0) {
                        const starPlayers = presentPlayers.filter(p => 
                            p.star && 
                            !quarterPlayers.has(p.id) &&
                            playerQuartersPlayed[p.id] < 3  // Prefer stars who haven't played 3 quarters yet
                        );
                        
                        // Sort by quarters played (fewer = better) to avoid playing all 4
                        starPlayers.sort((a, b) => {
                            if (playerQuartersPlayed[a.id] !== playerQuartersPlayed[b.id]) {
                                return playerQuartersPlayed[a.id] - playerQuartersPlayed[b.id];
                            }
                            return Math.random() - 0.5;
                        });
                        
                        // Try to add just one star player if possible
                        for (const starPlayer of starPlayers.slice(0, 1)) {
                            const availablePositions = starPlayer.positions.filter(pos => !quarter[pos - 1]);
                            if (availablePositions.length > 0) {
                                const pos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
                                assignPlayer(starPlayer, pos);
                                break; // Only add one to avoid forcing rotation issues
                            }
                        }
                    }

                    // Third: Fill remaining positions - use iterative approach to ensure all are filled
                    let maxIterations = 10; // Safety limit
                    let iterations = 0;
                    
                    while (iterations < maxIterations) {
                        const remainingPositions = [];
                        for (let pos = 1; pos <= NUM_POSITIONS; pos++) {
                            if (!quarter[pos - 1]) {
                                remainingPositions.push(pos);
                            }
                        }
                        
                        if (remainingPositions.length === 0) break; // All positions filled
                        
                        // Sort by difficulty (fewer eligible players = harder)
                        remainingPositions.sort((posA, posB) => {
                            const eligibleA = presentPlayers.filter(p => 
                                p.positions.includes(posA) &&
                                !quarterPlayers.has(p.id) &&
                                playerQuartersPlayed[p.id] < NUM_QUARTERS
                            ).length;
                            const eligibleB = presentPlayers.filter(p => 
                                p.positions.includes(posB) &&
                                !quarterPlayers.has(p.id) &&
                                playerQuartersPlayed[p.id] < NUM_QUARTERS
                            ).length;
                            return eligibleA - eligibleB;
                        });
                        
                        let filledAny = false;
                        for (const pos of remainingPositions) {
                            if (quarter[pos - 1]) continue;
                            
                            // First try: players who haven't hit max quarters
                            let eligiblePlayers = presentPlayers.filter(p => 
                                p.positions.includes(pos) &&
                                !quarterPlayers.has(p.id) &&
                                playerQuartersPlayed[p.id] < NUM_QUARTERS
                            );
                            
                            // If none available, allow players at max (emergency)
                            if (eligiblePlayers.length === 0) {
                                eligiblePlayers = presentPlayers.filter(p => 
                                    p.positions.includes(pos) &&
                                    !quarterPlayers.has(p.id)
                                );
                            }
                            
                            if (eligiblePlayers.length > 0) {
                                // Sort by priority: avoid playing all 4 quarters > meet minimum > prefer stars > random
                                eligiblePlayers.sort((a, b) => {
                                    // FIRST: Prefer players who have played fewer quarters (avoid 4-quarter games)
                                    const aQuarters = playerQuartersPlayed[a.id];
                                    const bQuarters = playerQuartersPlayed[b.id];
                                    if (aQuarters !== bQuarters) {
                                        return aQuarters - bQuarters; // Fewer quarters = higher priority
                                    }
                                    
                                    // SECOND: Players who need to meet minimum
                                    const aNeedsMin = aQuarters < MIN_QUARTERS ? 1 : 0;
                                    const bNeedsMin = bQuarters < MIN_QUARTERS ? 1 : 0;
                                    if (aNeedsMin !== bNeedsMin) return bNeedsMin - aNeedsMin;
                                    
                                    // THIRD: Prefer stars if we have 0 stars (but don't force)
                                    if (needsStars && starsInQuarter === 0) {
                                        if (a.star !== b.star) {
                                            return b.star ? 1 : -1; // Prefer stars if we have 0
                                        }
                                    }
                                    
                                    return Math.random() - 0.5;
                                });
                                
                                const player = eligiblePlayers[0];
                                assignPlayer(player, pos);
                                filledAny = true;
                            }
                        }
                        
                        if (!filledAny) break; // Can't fill any more
                        iterations++;
                    }

                    // Update sitting streaks for players not in this quarter
                    for (const player of presentPlayers) {
                        if (!quarterPlayers.has(player.id)) {
                            playerSittingStreak[player.id]++;
                        }
                    }

                    // Final check: ensure ALL positions are filled (absolute requirement)
                    // This should NEVER fail if validation passed, but ensure it doesn't
                    const unfilledPositions = [];
                    for (let pos = 1; pos <= NUM_POSITIONS; pos++) {
                        if (!quarter[pos - 1]) {
                            unfilledPositions.push(pos);
                        }
                    }
                    
                    // Force fill any remaining positions - this MUST succeed
                    for (const pos of unfilledPositions) {
                        // Find ANY available player who can play this position
                        let candidates = presentPlayers.filter(p => 
                            p.positions.includes(pos) && !quarterPlayers.has(p.id)
                        );
                        
                        // If still no candidates, something is very wrong, but try to find ANY player
                        if (candidates.length === 0) {
                            // Emergency: find any player not in quarter (shouldn't happen)
                            candidates = presentPlayers.filter(p => !quarterPlayers.has(p.id));
                            console.warn(`No player found for position ${pos} in quarter ${q+1}, using emergency fill`);
                        }
                        
                        if (candidates.length > 0) {
                            // Pick randomly from candidates - position must be filled
                            const player = candidates[Math.floor(Math.random() * candidates.length)];
                            assignPlayer(player, pos);
                        } else {
                            console.error(`CRITICAL: Cannot fill position ${pos} in quarter ${q+1} - no available players!`);
                        }
                    }
                    
                    // Final verification - if any positions still empty, that's a critical error
                    const finalEmpty = [];
                    for (let pos = 1; pos <= NUM_POSITIONS; pos++) {
                        if (!quarter[pos - 1]) {
                            finalEmpty.push(pos);
                            console.error(`Quarter ${q+1}, Position ${pos} is STILL empty after all fill attempts!`);
                        }
                    }
                    if (finalEmpty.length > 0) {
                        // This should never happen - means our validation was wrong or algorithm has a bug
                        violations += 10000 * finalEmpty.length;
                        console.error(`Quarter ${q+1} has ${finalEmpty.length} empty positions:`, finalEmpty);
                    }

                    // Prefer at least 1 star player, but don't penalize heavily (rotation is more important)
                    if (needsStars && starsInQuarter === 0) {
                        violations += 50; // Minor penalty for no star players (preference, not requirement)
                    }
                }

                // Check absolute rules after all quarters
                for (const player of presentPlayers) {
                    // Rule: No sitting 2 quarters in a row
                    for (let q = 0; q < NUM_QUARTERS - 1; q++) {
                        const playedQ1 = quarters[q].some(slot => slot && slot.playerId === player.id);
                        const playedQ2 = quarters[q + 1].some(slot => slot && slot.playerId === player.id);
                        
                        if (!playedQ1 && !playedQ2) {
                            violations += 10000; // ABSOLUTE VIOLATION
                        }
                    }

                    // Rule: Must play at least 2 quarters
                    if (playerQuartersPlayed[player.id] < MIN_QUARTERS) {
                        violations += 5000; // ABSOLUTE VIOLATION
                    }
                    
                    // Rule: Avoid playing all 4 quarters unless necessary (penalty, not absolute)
                    if (playerQuartersPlayed[player.id] === 4) {
                        violations += 100; // Penalty for playing all 4 quarters (prefer 2-3 quarters)
                    }
                }

                if (violations < bestViolations) {
                    bestViolations = violations;
                    bestSolution = {
                        quarters: quarters.map(q => q.map(slot => slot ? {...slot} : null)),
                        violations: violations,
                        playerQuartersPlayed: {...playerQuartersPlayed}
                    };

                    if (violations === 0) {
                        break; // Found perfect solution
                    }
                }
            }

            return bestSolution;
        }

        function displayLineup(quarters) {
            const tbody = document.getElementById('lineup-tbody');
            tbody.innerHTML = '';
            
            // Store lineup data for editing
            currentLineupData = quarters.map(q => q.map(slot => slot ? {...slot} : null));
            const editedCells = {}; // Track manually edited cells: {playerId-quarter: true}

            const presentPlayers = players.filter(p => p.present);
            const playerQuartersCount = {};

            presentPlayers.forEach((p, playerIndex) => {
                playerQuartersCount[p.id] = 0;
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.className = 'player-name-col';
                nameCell.textContent = p.name + (p.star ? ' â­' : '');
                row.appendChild(nameCell);

                for (let q = 0; q < 4; q++) {
                    const cell = document.createElement('td');
                    const assignment = currentLineupData[q].find(slot => slot && slot.playerId === p.id);
                    const cellKey = `${p.id}-${q}`;
                    
                    if (assignment) {
                        cell.textContent = assignment.position;
                        cell.className = 'position-cell' + (editedCells[cellKey] ? ' edited' : '');
                        cell.dataset.playerId = p.id;
                        cell.dataset.quarter = q;
                        cell.dataset.position = assignment.position;
                        playerQuartersCount[p.id]++;
                    } else {
                        cell.textContent = 'â€”';
                        cell.className = 'sit-cell' + (editedCells[cellKey] ? ' edited' : '');
                        cell.dataset.playerId = p.id;
                        cell.dataset.quarter = q;
                        cell.dataset.position = '';
                    }
                    
                    // Make cell editable
                    cell.addEventListener('click', (e) => editCell(e.target, p, q, editedCells, playerQuartersCount, row));
                    row.appendChild(cell);
                }

                const totalCell = document.createElement('td');
                totalCell.className = 'total-cell';
                totalCell.id = `total-${p.id}`;
                totalCell.textContent = playerQuartersCount[p.id];
                row.appendChild(totalCell);

                tbody.appendChild(row);
            });
        }

        function editCell(cell, player, quarter, editedCells, playerQuartersCount, row) {
            // Remove any existing selector
            const existingSelector = document.querySelector('.position-selector');
            if (existingSelector) {
                existingSelector.remove();
            }

            // Create position selector
            const selector = document.createElement('div');
            selector.className = 'position-selector';
            
            // Add position options (1-5)
            for (let pos = 1; pos <= 5; pos++) {
                const option = document.createElement('div');
                option.className = 'position-option';
                option.textContent = pos;
                option.onclick = () => {
                    updateCell(cell, player, quarter, pos, editedCells, playerQuartersCount, row);
                    selector.remove();
                };
                selector.appendChild(option);
            }

            // Add clear/remove option
            const clearOption = document.createElement('div');
            clearOption.className = 'position-option clear';
            clearOption.textContent = 'â€”';
            clearOption.onclick = () => {
                updateCell(cell, player, quarter, null, editedCells, playerQuartersCount, row);
                selector.remove();
            };
            selector.appendChild(clearOption);

            // Position the selector near the clicked cell
            const rect = cell.getBoundingClientRect();
            selector.style.position = 'fixed';
            selector.style.left = rect.left + 'px';
            selector.style.top = (rect.bottom + 5) + 'px';

            document.body.appendChild(selector);

            // Close selector when clicking outside
            const closeSelector = (e) => {
                if (!selector.contains(e.target) && e.target !== cell) {
                    selector.remove();
                    document.removeEventListener('click', closeSelector);
                }
            };
            setTimeout(() => document.addEventListener('click', closeSelector), 100);
        }

        function updateCell(cell, player, quarter, newPosition, editedCells, playerQuartersCount, row) {
            const cellKey = `${player.id}-${quarter}`;
            editedCells[cellKey] = true;

            // Remove player from this quarter in lineup data
            const quarterData = currentLineupData[quarter];
            const existingIndex = quarterData.findIndex(slot => slot && slot.playerId === player.id);
            if (existingIndex >= 0) {
                quarterData[existingIndex] = null;
            }

            // Update counts before assignment changes
            const wasPlaying = cell.dataset.position !== '';
            if (wasPlaying) {
                playerQuartersCount[player.id]--;
            }

            if (newPosition) {
                // Add player to new position in this quarter
                // Check if position is already taken
                const positionSlot = quarterData[newPosition - 1];
                if (positionSlot && positionSlot.playerId !== player.id) {
                    // Remove the other player from this quarter - find their cell in the table
                    const tbody = row.parentElement;
                    const allRows = Array.from(tbody.querySelectorAll('tr'));
                    for (const otherRow of allRows) {
                        const otherCell = otherRow.querySelector(`td[data-player-id="${positionSlot.playerId}"][data-quarter="${quarter}"]`);
                        if (otherCell) {
                            const otherCellKey = `${positionSlot.playerId}-${quarter}`;
                            editedCells[otherCellKey] = true;
                            otherCell.textContent = 'â€”';
                            otherCell.className = 'sit-cell edited';
                            otherCell.dataset.position = '';
                            playerQuartersCount[positionSlot.playerId]--;
                            updateTotal(positionSlot.playerId, playerQuartersCount[positionSlot.playerId]);
                            break;
                        }
                    }
                }
                
                quarterData[newPosition - 1] = { playerId: player.id, position: newPosition };
                cell.textContent = newPosition;
                cell.className = 'position-cell edited';
                cell.dataset.position = newPosition;
                playerQuartersCount[player.id]++;
            } else {
                // Clear cell (player sits)
                cell.textContent = 'â€”';
                cell.className = 'sit-cell edited';
                cell.dataset.position = '';
            }

            updateTotal(player.id, playerQuartersCount[player.id]);
        }

        function updateTotal(playerId, count) {
            const totalCell = document.getElementById(`total-${playerId}`);
            if (totalCell) {
                totalCell.textContent = count;
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }

        // ============================================================================
        // SAVE/LOAD FUNCTIONS - Use StorageService abstraction
        // ============================================================================

        function saveCurrentLineup() {
            if (!currentLineupData) {
                showError('No lineup to save. Please generate a lineup first.');
                return;
            }

            saveMode = 'lineup';
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('game-date-input').value = today;

            // Clear form fields
            document.getElementById('opponent-input').value = '';
            document.getElementById('team-score-input').value = '';
            document.getElementById('opponent-score-input').value = '';
            document.getElementById('game-comments-input').value = '';

            // Show modal
            const saveGameModal = document.getElementById('save-game-modal');
            saveGameModal.classList.add('show');
            // Scroll modal to top
            const modalDialog = saveGameModal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
            document.getElementById('opponent-input').focus();
        }

        function startStatsOnlyGame() {
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('stats-game-date-input').value = today;

            // Clear form fields
            document.getElementById('stats-opponent-input').value = '';

            // Show simplified modal (no score/comments - they don't know it yet)
            const startStatsModal = document.getElementById('start-stats-modal');
            startStatsModal.classList.add('show');
            // Scroll modal to top
            const modalDialog = startStatsModal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
            document.getElementById('stats-opponent-input').focus();
        }

        function closeStartStatsModal() {
            document.getElementById('start-stats-modal').classList.remove('show');
        }

        function closeStartStatsModalIfOutside(event) {
            if (event.target.id === 'start-stats-modal') {
                closeStartStatsModal();
            }
        }

        async function handleStartStatsGame(event) {
            event.preventDefault();
            
            const opponent = document.getElementById('stats-opponent-input').value.trim();
            const gameDate = document.getElementById('stats-game-date-input').value;
            
            if (!opponent || !gameDate) {
                showError('Please fill in all required fields.');
                return;
            }
            
            closeStartStatsModal();
            
            // Create the stats-only game
            saveMode = 'stats-only';
            currentEditingGameId = null;
            forceUpdateGame = false;
            
            const gameName = `vs ${opponent} - ${gameDate}`;
            const presentPlayers = players.filter(p => p.present);
            
            const metadataPayload = {
                opponent: opponent,
                gameDate: gameDate,
                teamScore: null,
                opponentScore: null,
                comments: '',
                playerCount: presentPlayers.length,
                roster: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    number: p.number || '',
                    present: p.present,
                    star: p.star,
                    positions: p.positions
                })),
                statsOnly: true,
                statsPlayed: presentPlayers.reduce((acc, p) => {
                    if (p.present) acc[p.id] = true;
                    return acc;
                }, {})
            };
            
            // Save the game
            const result = await StorageService.saveGame(gameName, null, metadataPayload);
            
            if (result.success) {
                const savedGame = await StorageService.loadGame(result.id);
                currentViewingGame = savedGame;
                currentViewingGameId = result.id;
                await initializeLiveStats();
                navigateTo('live-stats-page');
            } else {
                showError(`Failed to start game: ${result.error || 'Unknown error'}`);
            }
        }

        // Test Game Function - Creates a game automatically with random lineup
        async function createTestGame() {
            // Ensure we have players loaded
            if (players.length === 0) {
                await loadRoster();
            }

            // Mark all players as present except one (for testing)
            // Shuffle players and mark all but one as present
            const shuffled = [...players].sort(() => Math.random() - 0.5);
            players.forEach(p => p.present = true); // Mark all as present first
            shuffled[0].present = false; // Mark first shuffled player as not present

            // Generate random opponent name
            const testOpponents = ['Test Team', 'Practice Squad', 'Scrimmage Team', 'Demo Opponent', 'Test Game'];
            const opponent = testOpponents[Math.floor(Math.random() * testOpponents.length)];
            
            // Use today's date
            const today = new Date().toISOString().split('T')[0];
            const gameName = `vs ${opponent} - ${today}`;

            // Create random starting lineup (first 5 present players)
            const presentPlayers = players.filter(p => p.present);
            const startingLineup = presentPlayers.slice(0, 5).map(p => p.id);

            // Create game metadata
            const metadataPayload = {
                opponent: opponent,
                gameDate: today,
                teamScore: null,
                opponentScore: null,
                comments: 'Test game - automatically generated',
                playerCount: presentPlayers.length,
                roster: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    number: p.number || '',
                    present: p.present,
                    star: p.star,
                    positions: p.positions
                })),
                statsOnly: true,
                statsPlayed: presentPlayers.reduce((acc, p) => {
                    if (p.present) acc[p.id] = true;
                    return acc;
                }, {})
            };

            // Save the game
            const result = await StorageService.saveGame(
                gameName,
                [], // Empty lineup for stats-only
                metadataPayload
            );

            if (result.success) {
                // Load the saved game
                const savedGame = await StorageService.loadGame(result.id);
                currentViewingGame = savedGame;
                currentViewingGameId = result.id;

                // Initialize live stats structure first
                for (let p = 1; p <= 5; p++) {
                    liveGameStats.periods[p] = {
                        opponentPoints: 0,
                        teamPoints: 0,
                        opponentFouls: 0,
                        teamFouls: 0,
                        opponentRebounds: 0,
                        teamRebounds: 0,
                        opponentTurnovers: 0,
                        teamTurnovers: 0,
                        teamTimeouts: 0,
                        playerStats: {}
                    };
                }
                
                // Set the starting lineup before calling initializeLiveStats
                liveGameStats.onCourt = startingLineup;
                liveGameStats.fouledOut = [];

                // Now initialize (will skip starting lineup modal since onCourt is already set)
                await initializeLiveStats();

                // Navigate to live stats
                navigateTo('live-stats-page');
            } else {
                showError(`Failed to create test game: ${result.error || 'Unknown error'}`);
            }
        }

        function closeSaveModal() {
            document.getElementById('save-game-modal').classList.remove('show');
        }

        function closeModalIfOutside(event) {
            if (event.target.id === 'save-game-modal') {
                closeSaveModal();
            }
        }

        async function handleSaveGame(event) {
            event.preventDefault();

            const opponent = document.getElementById('opponent-input').value.trim();
            const gameDate = document.getElementById('game-date-input').value;
            const teamScore = document.getElementById('team-score-input').value ? parseInt(document.getElementById('team-score-input').value) : null;
            const opponentScore = document.getElementById('opponent-score-input').value ? parseInt(document.getElementById('opponent-score-input').value) : null;
            const comments = document.getElementById('game-comments-input').value.trim();

            if (!opponent) {
                showError('Please enter an opponent name.');
                return;
            }

            if (!gameDate) {
                showError('Please enter a game date.');
                return;
            }

            // Create game name from opponent and date
            const gameName = `vs ${opponent} - ${gameDate}`;

            if (forceUpdateGame && !currentEditingGameId) {
                showError('This lineup must be saved to the existing game.');
                return;
            }

            if (saveMode === 'lineup' && currentEditingGameId) {
                const existingGame = await StorageService.loadGame(currentEditingGameId);
                if (!existingGame) {
                    showError('Failed to load game for update.');
                    return;
                }

                const updatedGame = {
                    ...existingGame,
                    name: gameName,
                    lineup: currentLineupData,
                    metadata: {
                        ...existingGame.metadata,
                        opponent: opponent,
                        gameDate: gameDate,
                        teamScore: teamScore,
                        opponentScore: opponentScore,
                        comments: comments,
                        playerCount: players.filter(p => p.present).length,
                        roster: players.map(p => ({
                            id: p.id,
                            name: p.name,
                            present: p.present,
                            star: p.star,
                            positions: p.positions
                        }))
                    }
                };

                const result = await StorageService.updateGame(currentEditingGameId, updatedGame);
                if (result.success) {
                    closeSaveModal();
                    currentEditingGameId = null;
                    forceUpdateGame = false;
                    saveMode = 'lineup';
                    await viewGame(updatedGame.id);
                } else {
                    showError(`Failed to update game: ${result.error || 'Unknown error'}`);
                }
                return;
            }

            const lineupPayload = saveMode === 'stats-only' ? [] : currentLineupData;
            const statsPlayed = saveMode === 'stats-only'
                ? players.reduce((acc, p) => {
                    if (p.present) acc[p.id] = true;
                    return acc;
                }, {})
                : {};

            const metadataPayload = {
                opponent: opponent,
                gameDate: gameDate,
                teamScore: teamScore,
                opponentScore: opponentScore,
                comments: comments,
                playerCount: players.filter(p => p.present).length,
                roster: players.map(p => ({
                    id: p.id,
                    name: p.name,
                    number: p.number || '',
                    present: p.present,
                    star: p.star,
                    positions: p.positions
                })),
                statsOnly: saveMode === 'stats-only',
                statsPlayed: statsPlayed
            };

            const result = await StorageService.saveGame(
                gameName,
                lineupPayload,
                metadataPayload
            );

            if (result.success) {
                closeSaveModal();
                if (saveMode === 'stats-only') {
                    const savedGame = await StorageService.loadGame(result.id);
                    currentViewingGame = savedGame;
                    currentViewingGameId = result.id;
                    await initializeLiveStats();
                    navigateTo('live-stats-page');
                } else {
                    showError(`Game saved: ${gameName}`);
                    setTimeout(() => {
                        const errorDiv = document.getElementById('error-message');
                        errorDiv.classList.remove('show');
                        // Navigate back to games list
                        navigateTo('games-list-page');
                    }, 2000);
                }
                saveMode = 'lineup';
            } else {
                showError(`Failed to save game: ${result.error || 'Unknown error'}`);
            }
        }

        async function renderGamesList() {
            const container = document.getElementById('games-list-container');
            const games = await StorageService.listGames();

            // Calculate team record
            let wins = 0;
            let losses = 0;
            let ties = 0;
            
            games.forEach(game => {
                const teamScore = game.metadata.teamScore !== null && game.metadata.teamScore !== undefined ? game.metadata.teamScore : null;
                const opponentScore = game.metadata.opponentScore !== null && game.metadata.opponentScore !== undefined ? game.metadata.opponentScore : null;
                
                if (teamScore !== null && opponentScore !== null) {
                    if (teamScore > opponentScore) {
                        wins++;
                    } else if (teamScore < opponentScore) {
                        losses++;
                    } else {
                        ties++;
                    }
                }
            });

            // Display record
            const recordDisplay = document.getElementById('team-record-display');
            if (recordDisplay) {
                const totalGames = wins + losses + ties;
                if (totalGames > 0) {
                    recordDisplay.textContent = `Record: ${wins}-${losses}-${ties}`;
                } else {
                    recordDisplay.textContent = '';
                }
            }

            if (games.length === 0) {
                container.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No saved games yet. Start a new game to create your first lineup!</p>';
                if (recordDisplay) recordDisplay.textContent = '';
                return;
            }

            container.innerHTML = games.map(game => {
                const date = new Date(game.metadata.savedAt);
                const dateStr = formatDate(game.metadata.savedAt);
                const opponent = game.metadata.opponent || 'Unknown';
                const gameDate = formatDate(game.metadata.gameDate || game.metadata.savedAt);
                const displayName = opponent ? `vs ${opponent} - ${gameDate}` : game.name;
                const teamScore = game.metadata.teamScore !== null && game.metadata.teamScore !== undefined ? game.metadata.teamScore : null;
                const opponentScore = game.metadata.opponentScore !== null && game.metadata.opponentScore !== undefined ? game.metadata.opponentScore : null;
                const comments = game.metadata.comments || '';
                
                // Check if game is in progress (has liveStats but not ended)
                const hasLiveStats = game.metadata.liveStats;
                const isInProgress = hasLiveStats && !game.metadata.gameEnded;
                const isFinished = hasLiveStats && game.metadata.gameEnded;
                const currentPeriod = game.metadata.liveStats?.currentPeriod || 1;
                const periodLabel = currentPeriod === 5 ? 'OT' : `P${currentPeriod}`;

                // Format score display with status
                let scoreDisplay = '';
                let scoreClass = '';
                if (teamScore !== null && opponentScore !== null) {
                    const isWin = teamScore > opponentScore;
                    scoreClass = isWin ? ' win' : '';
                    const emoji = isWin && isFinished ? ' ðŸ†' : '';
                    
                    // Status indicator
                    let statusIndicator = '';
                    if (isInProgress) {
                        statusIndicator = `<div class="game-status-badge in-progress">In Progress - ${periodLabel}</div>`;
                    } else if (isFinished) {
                        statusIndicator = `<div class="game-status-badge completed">Final</div>`;
                    }
                    
                    scoreDisplay = `
                        <div class="game-score-container">
                            <div class="game-score${scoreClass}">
                                <span class="team-score">${teamScore}</span> - ${opponentScore}${emoji}
                            </div>
                            ${statusIndicator}
                        </div>
                    `;
                } else if (isInProgress) {
                    // Show in-progress even without score
                    scoreDisplay = `
                        <div class="game-score-container">
                            <div class="game-status-badge in-progress">In Progress - ${periodLabel}</div>
                        </div>
                    `;
                }

                // Status badge is now part of scoreDisplay, so we don't need separate badge
                let statusBadge = '';
                
                // Format comments display - right side
                let commentsDisplay = '';
                if (comments) {
                    const truncatedComments = comments.length > 100 ? comments.substring(0, 100) + '...' : comments;
                    commentsDisplay = `<div class="game-comments">"${escapeHtml(truncatedComments)}"</div>`;
                }

                // Click handler - resume if in progress, otherwise view
                const clickHandler = isInProgress ? `resumeGame('${game.id}')` : `viewGame('${game.id}')`;
                
                return `
                    <div class="game-list-item${isInProgress ? ' in-progress' : ''}">
                        <div class="game-info-left" style="flex: 1; cursor: pointer;" onclick="${clickHandler}">
                            <h4>${escapeHtml(displayName)} ${statusBadge}</h4>
                            <div class="game-meta">
                                <div>Opponent: ${escapeHtml(opponent)}</div>
                                <div>Date: ${escapeHtml(gameDate)}</div>
                                <div style="font-size: 0.8rem; color: #999; margin-top: 5px;">Saved: ${dateStr}</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            ${(scoreDisplay || commentsDisplay) ? `
                            <div class="game-info-right">
                                ${scoreDisplay}
                                ${commentsDisplay}
                            </div>
                            ` : ''}
                            <button class="delete-game-btn" onclick="deleteGame('${game.id}'); event.stopPropagation();" title="Delete game">
                                ðŸ—‘ï¸
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function resumeGame(gameId) {
            const game = await StorageService.loadGame(gameId);
            
            if (!game) {
                showError('Failed to load game.');
                return;
            }

            if (!game.metadata.liveStats) {
                showError('No live stats data found for this game.');
                return;
            }

            // Set up game state
            currentViewingGameId = gameId;
            currentViewingGame = game;

            // Restore live game stats from saved data (deep copy to avoid reference issues)
            const savedStats = game.metadata.liveStats;
            
            liveGameStats = {
                periods: JSON.parse(JSON.stringify(savedStats.periods || {})),
                onCourt: [...(savedStats.onCourt || [])],
                opponentScore: savedStats.opponentScore || 0,
                teamScore: savedStats.teamScore || 0,
                opponentFouls: savedStats.opponentFouls || 0,
                opponentRebounds: savedStats.opponentRebounds || 0,
                opponentTurnovers: savedStats.opponentTurnovers || 0,
                substitutionHistory: [...(savedStats.substitutionHistory || [])],
                substitutions: [...(savedStats.substitutions || [])],
                fouledOut: [...(savedStats.fouledOut || [])],
                teamStats: savedStats.teamStats || { points: 0, fouls: 0, rebounds: 0, turnovers: 0, timeouts: 0 },
                opponentStats: savedStats.opponentStats || { points: 0, fouls: 0, rebounds: 0, turnovers: 0 },
                playByPlay: [...(savedStats.playByPlay || [])]
            };
            
            // Restore next play-by-play ID
            if (liveGameStats.playByPlay.length > 0) {
                nextPlayByPlayId = Math.max(...liveGameStats.playByPlay.map(p => p.id)) + 1;
            }

            // Ensure all 5 periods exist
            for (let p = 1; p <= 5; p++) {
                if (!liveGameStats.periods[p]) {
                    liveGameStats.periods[p] = {
                        opponentPoints: 0,
                        teamPoints: 0,
                        opponentFouls: 0,
                        teamFouls: 0,
                        opponentRebounds: 0,
                        teamRebounds: 0,
                        opponentTurnovers: 0,
                        teamTurnovers: 0,
                        teamTimeouts: 0,
                        playerStats: {}
                    };
                }
            }

            // Restore period
            currentPeriod = savedStats.currentPeriod || 1;

            // Navigate to live stats page first
            navigateTo('live-stats-page');

            // Update UI directly without reinitializing (which would reset stats)
            // Scroll to top
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            const liveStatsPage = document.getElementById('live-stats-page');
            if (liveStatsPage) {
                liveStatsPage.scrollTop = 0;
            }

            // Update all UI elements
            updatePeriodDisplay();
            updateScoreboard();
            renderOnCourtPlayers();
            await updateTeamNames();
            renderRosterTab();
            
            // Set default tab to scoring
            await switchStatsTab('scoring');
        }

        async function viewGame(gameId) {
            currentViewingGameId = gameId;
            const game = await StorageService.loadGame(gameId);
            
            if (!game) {
                showError('Failed to load game.');
                return;
            }

            // Store game data
            currentViewingGame = game;
            viewGameEditMode = false;
            // Load saved edited cells from metadata, or initialize empty
            viewGameEditedCells = game.metadata.savedEditedCells ? {...game.metadata.savedEditedCells} : {};

            // Update title with formatted date
            const opponentForTitle = game.metadata.opponent || 'Unknown';
            const gameDateForTitle = formatDate(game.metadata.gameDate || 'Unknown');
            document.getElementById('view-game-title').textContent = `vs ${opponentForTitle} - ${gameDateForTitle}`;
            const metaDiv = document.getElementById('view-game-meta');
            
            const opponent = game.metadata.opponent || 'Unknown';
            const gameDate = formatDate(game.metadata.gameDate || 'Unknown');
            const teamScore = game.metadata.teamScore !== null && game.metadata.teamScore !== undefined ? game.metadata.teamScore : null;
            const opponentScore = game.metadata.opponentScore !== null && game.metadata.opponentScore !== undefined ? game.metadata.opponentScore : null;
            const comments = game.metadata.comments || '';
            const playerCount = game.metadata.playerCount || 'Unknown';

            // Check if team won
            let victoryMessage = '';
            if (teamScore !== null && opponentScore !== null) {
                if (teamScore > opponentScore) {
                    victoryMessage = `
                        <div class="victory-message">
                            ðŸ† Great job coach, this lineup won! ðŸ†<br>
                            <span style="font-size: 0.9rem; font-weight: normal;">Final Score: ${teamScore} - ${opponentScore}</span>
                        </div>
                    `;
                }
            }

            // Build metadata HTML
            metaDiv.innerHTML = victoryMessage + `
                <div class="game-info-card">
                    <div class="game-info-row">
                        <span class="game-info-label">Opponent:</span>
                        <span class="game-info-value">${escapeHtml(opponent)}</span>
                    </div>
                    <div class="game-info-row">
                        <span class="game-info-label">Date:</span>
                        <span class="game-info-value">${escapeHtml(gameDate)}</span>
                    </div>
                    ${teamScore !== null && opponentScore !== null ? `
                    <div class="game-info-row">
                        <span class="game-info-label">Score:</span>
                        <span class="game-info-value"><strong>${teamScore}</strong> - ${opponentScore}</span>
                    </div>
                    ` : ''}
                    <div class="game-info-row">
                        <span class="game-info-label">Players:</span>
                        <span class="game-info-value">${playerCount}</span>
                    </div>
                    ${comments ? `
                    <div class="game-info-row" style="flex-direction: column; align-items: flex-start;">
                        <span class="game-info-label" style="margin-bottom: 10px;">Comments:</span>
                        <div class="game-comments">${escapeHtml(comments)}</div>
                    </div>
                    ` : ''}
                    ${renderGameStats()}
                </div>
            `;

            // Store lineup data for potential editing
            if (game.lineup && Array.isArray(game.lineup) && game.lineup.length > 0) {
                currentLineupData = game.lineup.map(q => q.map(slot => slot ? {...slot} : null));
            } else {
                currentLineupData = null;
            }

            // Display lineup
            renderViewGameLineup();

            // Move lineup status legend below the table
            const legend = document.getElementById('view-game-legend');
            if (legend) {
                const savedEdits = currentViewingGame?.metadata?.savedEditedCells || {};
                if (Object.keys(savedEdits).length > 0) {
                    legend.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 8px;">Lineup Status</div>
                        <div style="display: flex; gap: 16px; flex-wrap: wrap; font-size: 0.9rem; color: #666;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="display: inline-block; width: 20px; height: 20px; background: #20c997; border: 2px solid #0d9488; border-radius: 4px;"></span>
                                <span>Previously edited positions</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="display: inline-block; width: 20px; height: 20px; background: #ff9800; border: 2px solid #e65100; border-radius: 4px;"></span>
                                <span>Previously edited sit-outs</span>
                            </div>
                        </div>
                    `;
                } else {
                    legend.innerHTML = '';
                }
            }

            // Show/hide edit button and configure for missing lineup
            const editBtn = document.getElementById('view-game-edit-btn');
            if (editBtn) {
                if (!currentLineupData) {
                    editBtn.textContent = 'âž• Add Lineup';
                    editBtn.onclick = startAddLineupForGame;
                } else {
                    editBtn.textContent = 'âœï¸ Edit Lineup';
                    editBtn.onclick = editGameMode;
                }
                editBtn.style.display = 'block';
            }
            document.getElementById('view-game-actions').style.display = 'none';

            // Navigate to view game page and update nav
            navigateTo('view-game-page');
        }

        function renderViewGameLineup() {
            const tbody = document.getElementById('view-game-tbody');
            tbody.innerHTML = '';

            if (!currentViewingGame) return;
            if (!currentLineupData) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 30px; color: #666;">
                            No lineup saved for this game yet.
                        </td>
                    </tr>
                `;
                return;
            }

            const savedRoster = currentViewingGame.metadata.roster || [];
            const playerQuartersCount = {};
            
            // Get saved edited cells from metadata
            const savedEditedCells = currentViewingGame.metadata.savedEditedCells || {};
            // Merge with current session edits
            const allEditedCells = {...savedEditedCells, ...viewGameEditedCells};

            // Merge saved roster with current roster to get updated names
            // Use current names but preserve historical star/positions
            const presentPlayers = savedRoster.map(savedPlayer => {
                const currentPlayer = players.find(p => p.id === savedPlayer.id);
                return {
                    ...savedPlayer, // Keep historical star, positions, present status
                    name: currentPlayer ? currentPlayer.name : savedPlayer.name // Use current name
                };
            });

            presentPlayers.forEach(p => {
                playerQuartersCount[p.id] = 0;
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.className = 'player-name-col';
                nameCell.textContent = p.name + (p.star ? ' â­' : '');
                row.appendChild(nameCell);

                for (let q = 0; q < 4; q++) {
                    const cell = document.createElement('td');
                    const cellKey = `${p.id}-${q}`;
                    const assignment = currentLineupData[q].find(slot => slot && slot.playerId === p.id);
                    
                    // Determine if this cell was edited (saved or current session)
                    const wasEdited = allEditedCells[cellKey];
                    const isNewlyEdited = viewGameEditedCells[cellKey] && !savedEditedCells[cellKey];
                    const wasPreviouslyEdited = savedEditedCells[cellKey];
                    
                    if (assignment) {
                        cell.textContent = assignment.position;
                        // Use edited class if cell was edited at any time
                        let cellClass = 'position-cell';
                        if (wasEdited) {
                            cellClass += ' edited';
                            if (wasPreviouslyEdited && !isNewlyEdited) {
                                cellClass += ' saved-edit'; // Previously saved edit
                            } else if (isNewlyEdited) {
                                cellClass += ' new-edit'; // New edit this session
                            }
                        }
                        cell.className = cellClass;
                        cell.dataset.position = assignment.position;
                        playerQuartersCount[p.id]++;
                    } else {
                        cell.textContent = 'â€”';
                        let cellClass = 'sit-cell';
                        if (wasEdited) {
                            cellClass += ' edited';
                            if (wasPreviouslyEdited && !isNewlyEdited) {
                                cellClass += ' saved-edit';
                            } else if (isNewlyEdited) {
                                cellClass += ' new-edit';
                            }
                        }
                        cell.className = cellClass;
                        cell.dataset.position = '';
                    }
                    
                    // Make cell editable if in edit mode
                    if (viewGameEditMode) {
                        cell.addEventListener('click', (e) => editViewGameCell(e.target, p, q, playerQuartersCount, row));
                    }
                    
                    cell.dataset.playerId = p.id;
                    cell.dataset.quarter = q;
                    row.appendChild(cell);
                }

                const totalCell = document.createElement('td');
                totalCell.className = 'total-cell';
                totalCell.id = `view-total-${p.id}`;
                totalCell.textContent = playerQuartersCount[p.id];
                row.appendChild(totalCell);

                tbody.appendChild(row);
            });
        }

        function editViewGameCell(cell, player, quarter, playerQuartersCount, row) {
            // Same edit functionality as new game page
            editCell(cell, player, quarter, viewGameEditedCells, playerQuartersCount, row);
            // Update total cell ID for view game page
            updateTotal(player.id, playerQuartersCount[player.id]);
            const totalCell = document.getElementById(`view-total-${player.id}`);
            if (totalCell) {
                totalCell.textContent = playerQuartersCount[player.id];
            }
        }

        function editGameMode() {
            viewGameEditMode = true;
            document.getElementById('view-game-edit-btn').style.display = 'none';
            document.getElementById('view-game-actions').style.display = 'flex';
            renderViewGameLineup(); // Re-render with editable cells
        }

        function startAddLineupForGame() {
            if (!currentViewingGame) return;
            const gameRoster = currentViewingGame.metadata.roster || [];
            players = gameRoster.map(p => ({
                id: p.id,
                name: p.name,
                present: !!p.present,
                star: !!p.star,
                positions: Array.isArray(p.positions) ? [...p.positions] : [1,2,3,4,5]
            }));
            nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
            currentEditingGameId = currentViewingGameId;
            forceUpdateGame = true;
            navigateTo('new-game-page');
            renderGameRoster();

            const keepStatsBtn = document.getElementById('keep-stats-btn');
            if (keepStatsBtn) {
                keepStatsBtn.style.display = 'none';
            }
        }

        function cancelEditGame() {
            if (!currentViewingGame) return;
            
            // Reset to saved data (including saved edits)
            currentLineupData = currentViewingGame.lineup.map(q => q.map(slot => slot ? {...slot} : null));
            // Reset to saved edited cells, discarding new edits
            viewGameEditedCells = currentViewingGame.metadata.savedEditedCells ? {...currentViewingGame.metadata.savedEditedCells} : {};
            viewGameEditMode = false;
            
            document.getElementById('view-game-edit-btn').style.display = 'block';
            document.getElementById('view-game-actions').style.display = 'none';
            renderViewGameLineup(); // Re-render with saved edits only
        }

        function closeEditGameModal() {
            document.getElementById('edit-game-modal').classList.remove('show');
        }

        function closeEditModalIfOutside(event) {
            if (event.target.id === 'edit-game-modal') {
                closeEditGameModal();
            }
        }

        // ============================================================================
        // STATS TRACKING FUNCTIONS
        // ============================================================================

        let currentGameStats = {}; // Temporary storage for stats being edited
        let currentGameStatsPlayed = {}; // Temporary stats-based played map for current game
        let currentStatsPlayedMap = {}; // Played map for current game (lineup or stats)

        function getLineupPlayedMap(game) {
            const playedMap = {};
            if (!game || !game.lineup) return playedMap;

            game.lineup.forEach(quarter => {
                if (!quarter) return;
                quarter.forEach(slot => {
                    if (slot && slot.playerId) {
                        const playerId = String(slot.playerId);
                        playedMap[playerId] = (playedMap[playerId] || 0) + 1;
                    }
                });
            });

            return playedMap;
        }

        function getPlayedMapForGame(game) {
            if (!game) return {};
            if (Array.isArray(game.lineup) && game.lineup.length > 0) {
                return getLineupPlayedMap(game);
            }
            const statsPlayed = game.metadata?.statsPlayed || {};
            const map = {};
            Object.keys(statsPlayed).forEach(playerId => {
                if (statsPlayed[playerId]) map[playerId] = 1;
            });
            return map;
        }

        function openEditStatsModal() {
            if (!currentViewingGame) return;

            // Default return page if opened from view game
            if (!statsReturnPage) {
                statsReturnPage = 'view-game';
            }

            // Load existing stats or initialize empty
            currentGameStats = currentViewingGame.metadata.playerStats || {};
            currentGameStatsPlayed = currentViewingGame.metadata.statsPlayed || {};
            currentStatsPlayedMap = getPlayedMapForGame(currentViewingGame);
            
            // Get all players who were on the roster for this game (present or absent)
            const savedRoster = currentViewingGame.metadata.roster || [];
            const allGamePlayers = savedRoster;
            
            // Merge with current roster to get updated names
            const playersWithNames = allGamePlayers.map(savedPlayer => {
                const currentPlayer = players.find(p => p.id === savedPlayer.id);
                return {
                    ...savedPlayer,
                    name: currentPlayer ? currentPlayer.name : savedPlayer.name,
                    number: currentPlayer ? (currentPlayer.number || '') : (savedPlayer.number || '')
                };
            });

            // If stats-only game without overrides, default GP to present players
            if (currentViewingGame.metadata.statsOnly && Object.keys(currentGameStatsPlayed).length === 0) {
                const presentIds = (currentViewingGame.metadata.roster || [])
                    .filter(p => p.present)
                    .map(p => p.id);
                presentIds.forEach(id => {
                    currentGameStatsPlayed[id] = true;
                });
                currentStatsPlayedMap = presentIds.reduce((acc, id) => {
                    acc[String(id)] = 1;
                    return acc;
                }, {});
            }

            // Initialize stats for players who don't have them yet
            playersWithNames.forEach(player => {
                if (!currentGameStats[player.id]) {
                    currentGameStats[player.id] = {
                        points: 0,
                        assists: 0,
                        rebounds: 0,
                        blocks: 0,
                        steals: 0,
                        turnovers: 0
                    };
                }
            });

            // Render the stats table
            renderStatsTable(playersWithNames);
            
            // Show modal
            const editStatsModal = document.getElementById('edit-stats-modal');
            editStatsModal.classList.add('show');
            // Scroll modal to top
            const modalDialog = editStatsModal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function renderStatsTable(playersList) {
            const tbody = document.getElementById('stats-tbody');
            tbody.innerHTML = '';

            const statTypes = ['points', 'assists', 'rebounds', 'blocks', 'steals', 'turnovers'];
            const statLabels = ['Points', 'Assists', 'Rebounds', 'Blocks', 'Steals', 'Turnovers'];

            playersList.forEach(player => {
                const row = document.createElement('tr');
                const playedQuarters = currentStatsPlayedMap[String(player.id)] || 0;
                const didPlay = playedQuarters > 0;
                
                // Player name
                const nameCell = document.createElement('td');
                nameCell.className = 'player-name-col';
                nameCell.innerHTML = `${escapeHtml(player.name)}${player.star ? ' â­' : ''}${!didPlay ? ' <span class="dnp-badge">DNP</span>' : ''}`;
                row.appendChild(nameCell);

                const numberCell = document.createElement('td');
                numberCell.className = 'number-col';
                numberCell.textContent = player.number || '';
                numberCell.style.textAlign = 'center';
                row.appendChild(numberCell);

                // Count GP column (override for DNP)
                const gpCell = document.createElement('td');
                gpCell.style.textAlign = 'center';
                const gpToggle = document.createElement('input');
                gpToggle.type = 'checkbox';
                gpToggle.className = 'gp-toggle';
                if (didPlay) {
                    gpToggle.checked = true;
                    gpToggle.disabled = true;
                    gpToggle.title = 'Played per lineup';
                } else {
                    gpToggle.checked = !!currentGameStatsPlayed[player.id];
                    gpToggle.title = 'Count this DNP as played for per-game stats';
                    gpToggle.onchange = () => {
                        if (gpToggle.checked) {
                            currentGameStatsPlayed[player.id] = true;
                            currentStatsPlayedMap[String(player.id)] = 1;
                        } else {
                            delete currentGameStatsPlayed[player.id];
                            delete currentStatsPlayedMap[String(player.id)];
                        }
                    };
                }
                gpCell.appendChild(gpToggle);
                row.appendChild(gpCell);

                // Stats columns
                statTypes.forEach((statType, index) => {
                    const statCell = document.createElement('td');
                    const statControl = document.createElement('div');
                    statControl.className = 'stat-control';

                    // Decrement button
                    const decBtn = document.createElement('button');
                    decBtn.className = 'stat-btn decrement';
                    decBtn.textContent = 'âˆ’';
                    decBtn.onclick = () => adjustStat(player.id, statType, -1);
                    statControl.appendChild(decBtn);

                    // Value display
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'stat-value';
                    valueSpan.id = `stat-${player.id}-${statType}`;
                    valueSpan.textContent = currentGameStats[player.id][statType] || 0;
                    statControl.appendChild(valueSpan);

                    // Increment button
                    const incBtn = document.createElement('button');
                    incBtn.className = 'stat-btn';
                    incBtn.textContent = '+';
                    incBtn.onclick = () => adjustStat(player.id, statType, 1);
                    statControl.appendChild(incBtn);

                    statCell.appendChild(statControl);
                    row.appendChild(statCell);
                });

                tbody.appendChild(row);
            });

            updateStatsTotalPoints(playersList);
        }

        function adjustStat(playerId, statType, change) {
            if (!currentGameStats[playerId]) {
                currentGameStats[playerId] = {
                    points: 0,
                    assists: 0,
                    rebounds: 0,
                    blocks: 0,
                    steals: 0,
                    turnovers: 0
                };
            }

            const currentValue = currentGameStats[playerId][statType] || 0;
            const newValue = Math.max(0, currentValue + change); // Don't allow negative values
            currentGameStats[playerId][statType] = newValue;

            // Update display
            const valueSpan = document.getElementById(`stat-${playerId}-${statType}`);
            if (valueSpan) {
                valueSpan.textContent = newValue;
            }

            updateStatsTotalPoints();
        }

        function updateStatsTotalPoints(playersList = null) {
            const totalCell = document.getElementById('stats-total-points');
            if (!totalCell) return;

            let totalPoints = 0;
            if (playersList && Array.isArray(playersList)) {
                playersList.forEach(player => {
                    const stats = currentGameStats[player.id];
                    totalPoints += stats ? (stats.points || 0) : 0;
                });
            } else {
                Object.values(currentGameStats).forEach(stats => {
                    totalPoints += stats ? (stats.points || 0) : 0;
                });
            }

            totalCell.textContent = totalPoints;
        }

        async function saveGameStats() {
            if (!currentViewingGame || !currentViewingGameId) return;

            // Save stats to game metadata
            currentViewingGame.metadata.playerStats = {...currentGameStats};
            currentViewingGame.metadata.statsPlayed = {...currentGameStatsPlayed};

            // Update game in storage
            const result = await StorageService.updateGame(currentViewingGameId, currentViewingGame);
            
            if (result.success) {
                closeEditStatsModal();
                if (statsReturnPage === 'history') {
                    navigateTo('playtime-history-page');
                    await renderPlaytimeHistory();
                } else {
                    // Refresh the view game page to show updated stats
                    await viewGame(currentViewingGameId);
                }
                
                // Show success message
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = 'Stats saved successfully!';
                errorDiv.style.color = '#28a745';
                errorDiv.classList.add('show');
                setTimeout(() => {
                    errorDiv.classList.remove('show');
                    errorDiv.style.color = '';
                }, 2000);
            } else {
                showError(`Failed to save stats: ${result.error || 'Unknown error'}`);
            }
        }

        function closeEditStatsModal() {
            document.getElementById('edit-stats-modal').classList.remove('show');
            currentGameStats = {}; // Clear temporary stats
            currentGameStatsPlayed = {};
            currentStatsPlayedMap = {};
            statsReturnPage = 'view-game';
        }

        function closeStatsModalIfOutside(event) {
            if (event.target.id === 'edit-stats-modal') {
                closeEditStatsModal();
            }
        }

        // Live Stats Tracking Variables
        let currentPeriod = 1;
        let nextPlayByPlayId = 1; // Counter for unique play-by-play event IDs
        let liveGameStats = {
            periods: {},
            opponentStats: {
                points: 0,
                fouls: 0,
                rebounds: 0,
                turnovers: 0
            },
            teamStats: {
                points: 0,
                fouls: 0,
                rebounds: 0,
                turnovers: 0,
                timeouts: 0
            },
            onCourt: [], // Array of player IDs currently on court
            substitutions: [], // Array of {period, time, playerOut, playerIn}
            fouledOut: [], // Array of player IDs who have fouled out (5+ fouls)
            playByPlay: [] // Array of play-by-play events
        };
        let pendingAction = null; // Track pending action waiting for player selection
        let pendingAssist = null; // Track pending assist after scoring
        let pendingFreeThrow = null; // Track pending free throw: {playerId, count, shots: []}

        // Initialize Live Stats Page
        async function initializeLiveStats() {
            if (!currentViewingGame) return;

            // Reset period to 1 for new games (will be overwritten if loading existing stats)
            currentPeriod = 1;
            
            // Reset play-by-play ID counter
            nextPlayByPlayId = 1;

            // Fully reset liveGameStats to ensure clean state
            liveGameStats = {
                periods: {},
                opponentStats: {
                    points: 0,
                    fouls: 0,
                    rebounds: 0,
                    turnovers: 0
                },
                teamStats: {
                    points: 0,
                    fouls: 0,
                    rebounds: 0,
                    turnovers: 0,
                    timeouts: 0
                },
                onCourt: [],
                substitutions: [],
                fouledOut: [],
                playByPlay: []
            };

            // Initialize period-based stats structure
            for (let p = 1; p <= 5; p++) {
                liveGameStats.periods[p] = {
                    opponentPoints: 0,
                    teamPoints: 0,
                    opponentFouls: 0,
                    teamFouls: 0,
                    opponentRebounds: 0,
                    teamRebounds: 0,
                    opponentTurnovers: 0,
                    teamTurnovers: 0,
                    teamTimeouts: 0,
                    playerStats: {}
                };
            }

            // Load existing stats if available
            const existingStats = currentViewingGame.metadata.liveStats;
            if (existingStats) {
                liveGameStats = {...liveGameStats, ...existingStats};
                currentPeriod = existingStats.currentPeriod || 1;
                // Ensure fouledOut array exists
                if (!liveGameStats.fouledOut) {
                    liveGameStats.fouledOut = [];
                }
                // Ensure substitutions array exists
                if (!liveGameStats.substitutions) {
                    liveGameStats.substitutions = [];
                }
                // Ensure playByPlay array exists
                if (!liveGameStats.playByPlay) {
                    liveGameStats.playByPlay = [];
                }
                // Restore next play-by-play ID
                if (liveGameStats.playByPlay.length > 0) {
                    nextPlayByPlayId = Math.max(...liveGameStats.playByPlay.map(p => p.id)) + 1;
                }
            }
            
            // Set default tab to scoring
            await switchStatsTab('scoring');

            // Initialize player stats for all present players
            const roster = currentViewingGame.metadata.roster || [];
            const presentPlayers = roster.filter(p => p.present);
            
            presentPlayers.forEach(player => {
                for (let p = 1; p <= 5; p++) {
                    if (!liveGameStats.periods[p].playerStats[player.id]) {
                        liveGameStats.periods[p].playerStats[player.id] = {
                            points: 0,
                            fouls: 0,
                            fgMade: 0,
                            fgAttempted: 0,
                            fg3Made: 0,
                            fg3Attempted: 0,
                            ftMade: 0,
                            ftAttempted: 0,
                            rebounds: 0,
                            assists: 0,
                            steals: 0,
                            blocks: 0,
                            turnovers: 0
                        };
                    }
                }
            });

            // Scroll to top of page
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            const liveStatsPage = document.getElementById('live-stats-page');
            if (liveStatsPage) {
                liveStatsPage.scrollTop = 0;
            }
            
            // Check if starting lineup needs to be set
            if (liveGameStats.onCourt.length === 0 && presentPlayers.length > 0) {
                // Show starting lineup modal
                openStartingLineupModal();
            } else {
                // Update UI
                updatePeriodDisplay();
                updateScoreboard();
                renderOnCourtPlayers();
                await updateTeamNames();
                renderRosterTab();
            }

            // Save initial state immediately so game shows as "in progress"
            autoSaveGame();
        }

        function openStartingLineupModal() {
            const modal = document.getElementById('starting-lineup-modal');
            const list = document.getElementById('starting-lineup-players-list');
            const countDisplay = document.getElementById('starting-lineup-count');
            const confirmBtn = document.getElementById('confirm-starting-lineup-btn');
            
            list.innerHTML = '';
            
            const roster = currentViewingGame.metadata.roster || [];
            const fouledOutIds = new Set(liveGameStats.fouledOut || []);
            // Only show players who are explicitly marked as present and not fouled out
            const presentPlayers = roster.filter(p => p.present === true && !fouledOutIds.has(p.id));
            
            // If no present players, show error
            if (presentPlayers.length === 0) {
                alert('No players are marked as present. Please mark players as present before starting the game.');
                return;
            }
            
            // If fewer than 5 present players, warn but allow
            if (presentPlayers.length < 5) {
                console.warn(`Only ${presentPlayers.length} players are present. Need at least 5 for starting lineup.`);
            }
            
            let selectedPlayers = [];
            
            presentPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'starting-lineup-player-item';
                item.dataset.playerId = player.id;
                item.innerHTML = `
                    <div class="player-info">
                        <span class="player-number">#${player.number || player.id}</span>
                        <span>${escapeHtml(player.name)}</span>
                    </div>
                `;
                
                item.onclick = () => {
                    // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
                    const playerId = item.dataset.playerId;
                    const index = selectedPlayers.indexOf(playerId);
                    
                    if (index > -1) {
                        // Deselect
                        selectedPlayers.splice(index, 1);
                        item.classList.remove('selected');
                    } else {
                        // Select (max 5)
                        if (selectedPlayers.length < 5) {
                            selectedPlayers.push(playerId);
                            item.classList.add('selected');
                        }
                    }
                    
                    // Update count and button state
                    countDisplay.textContent = `${selectedPlayers.length} / 5 selected`;
                    confirmBtn.disabled = selectedPlayers.length !== 5;
                };
                
                list.appendChild(item);
            });
            
            // Reset state
            selectedPlayers = [];
            countDisplay.textContent = '0 / 5 selected';
            confirmBtn.disabled = true;
            
            modal.classList.add('show');
            // Scroll modal to top
            const modalDialog = modal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        async function confirmStartingLineup() {
            const selectedItems = document.querySelectorAll('.starting-lineup-player-item.selected');
            
            if (selectedItems.length !== 5) {
                alert('Please select exactly 5 players for the starting lineup.');
                return;
            }
            
            // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
            const selectedPlayerIds = Array.from(selectedItems).map(item => item.dataset.playerId);
            liveGameStats.onCourt = selectedPlayerIds;
            
            // Close modal
            document.getElementById('starting-lineup-modal').classList.remove('show');
            
            // Update UI
            updatePeriodDisplay();
            updateScoreboard();
            renderOnCourtPlayers();
            await updateTeamNames();
            renderRosterTab();
            
            autoSaveGame();
        }

        function updatePeriodDisplay() {
            const periodNames = {1: 'Period 1', 2: 'Period 2', 3: 'Period 3', 4: 'Period 4', 5: 'Overtime'};
            document.getElementById('current-period-display').textContent = periodNames[currentPeriod] || `Period ${currentPeriod}`;
        }

        function togglePeriodSelector() {
            const dropdown = document.getElementById('period-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close period selector when clicking outside
        document.addEventListener('click', (e) => {
            const selector = document.getElementById('period-selector-btn');
            const dropdown = document.getElementById('period-dropdown');
            if (selector && dropdown && !selector.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('show');
            }
        });

        function selectPeriod(period) {
            currentPeriod = period;
            updatePeriodDisplay();
            document.getElementById('period-dropdown').classList.remove('show');
            autoSaveGame();
        }

        function updateScoreboard() {
            const opponentTotal = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.opponentPoints, 0);
            const teamTotal = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamPoints, 0);

            document.getElementById('opponent-main-score').textContent = opponentTotal;
            document.getElementById('team-main-score').textContent = teamTotal;
        }

        async function updateTeamNames() {
            const opponentName = currentViewingGame.metadata.opponent || 'Opponent Team';
            document.getElementById('opponent-team-name').textContent = opponentName;
            document.getElementById('opponent-team-header').textContent = opponentName;
            
            // Update game title
            const gameName = currentViewingGame.name || 'Practice Game';
            document.getElementById('live-game-title').textContent = gameName;
            
            // Use actual team name
            const currentTeam = await TeamService.getCurrentTeam();
            const teamName = currentTeam ? (currentTeam.teamName || currentTeam.name) : 'Scoring Team';
            document.getElementById('scoring-team-header').textContent = teamName;
            document.getElementById('scoring-team-name').textContent = teamName;
        }

        function updateOpponentTeamName(newName) {
            if (!currentViewingGame) return;
            currentViewingGame.metadata.opponent = newName;
            document.getElementById('opponent-team-name').textContent = newName;
            document.getElementById('opponent-team-header').textContent = newName;
            autoSaveGame();
        }

        async function switchStatsTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.stats-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.stats-tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab-content`).classList.add('active');

            // Add/remove class for scoring tab to hide header on mobile
            const liveStatsPage = document.getElementById('live-stats-page');
            if (tabName === 'scoring') {
                liveStatsPage.classList.add('scoring-tab-active');
            } else {
                liveStatsPage.classList.remove('scoring-tab-active');
            }

            if (tabName === 'stats') {
                await renderStatsTab();
            } else if (tabName === 'roster') {
                renderRosterTab();
            } else if (tabName === 'plays') {
                renderPlayByPlay();
            }
        }

        // ============================================================================
        // PLAY-BY-PLAY TRACKING
        // ============================================================================

        function getStatDescription(statType, isOpponent = false) {
            const descriptions = {
                'fg2pt': 'scored a 2pt FG',
                'fg3pt': 'scored a 3pt FG',
                'freeThrow': 'made a free throw',
                'freeThrowMiss': 'missed a free throw',
                'miss2pt': 'missed a 2pt FG',
                'miss3pt': 'missed a 3pt FG',
                'rebound': 'grabbed a rebound',
                'assist': 'made an assist',
                'steal': 'made a steal',
                'block': 'made a block',
                'turnover': 'committed a turnover',
                'foul': 'committed a foul'
            };
            
            if (isOpponent) {
                const opponentDescriptions = {
                    'fg2pt': '+2 pts',
                    'fg3pt': '+3 pts',
                    'freeThrow': '+1 pt (FT)',
                    'rebound': 'rebound',
                    'turnover': 'turnover',
                    'foul': 'foul'
                };
                return opponentDescriptions[statType] || descriptions[statType] || statType;
            }
            
            return descriptions[statType] || statType;
        }

        function addPlayByPlayEvent(options) {
            const {
                playerId = null,
                playerName = null,
                playerNumber = null,
                statType,
                isOpponent = false,
                points = 0
            } = options;

            const teamScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamPoints, 0);
            const opponentScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.opponentPoints, 0);

            const event = {
                id: nextPlayByPlayId++,
                period: currentPeriod,
                timestamp: new Date().toISOString(),
                playerId,
                playerName,
                playerNumber,
                statType,
                isOpponent,
                points,
                scoreAtTime: { team: teamScore, opponent: opponentScore }
            };

            // Generate description
            if (isOpponent) {
                const opponentName = currentViewingGame?.metadata?.opponent || 'Opponent';
                event.description = `${opponentName} - ${getStatDescription(statType, true)}`;
            } else if (playerName) {
                event.description = `#${playerNumber || '?'} ${playerName} ${getStatDescription(statType)}`;
            } else {
                event.description = getStatDescription(statType);
            }

            liveGameStats.playByPlay.push(event);
            
            // Auto-save to persist the play-by-play
            autoSaveGame();
        }

        function renderPlayByPlay() {
            const container = document.getElementById('play-by-play-list');
            const plays = liveGameStats.playByPlay || [];
            const undoLastBtn = document.getElementById('pbp-undo-last-btn');

            // Update undo last button state
            if (undoLastBtn) {
                undoLastBtn.disabled = plays.length === 0;
            }

            if (plays.length === 0) {
                container.innerHTML = '<div class="pbp-empty-message">No plays recorded yet. Start tracking stats to see the play-by-play!</div>';
                return;
            }

            // Group plays by period
            const playsByPeriod = {};
            plays.forEach(play => {
                const period = play.period || 1;
                if (!playsByPeriod[period]) {
                    playsByPeriod[period] = [];
                }
                playsByPeriod[period].push(play);
            });

            // Sort periods in reverse order (most recent period first)
            const sortedPeriods = Object.keys(playsByPeriod).sort((a, b) => b - a);

            let html = '';
            sortedPeriods.forEach(period => {
                const periodPlays = playsByPeriod[period];
                // Sort plays within period: most recent first
                periodPlays.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                const periodLabel = period === '5' ? 'Overtime' : `Quarter ${period}`;
                const isCurrentPeriod = parseInt(period) === currentPeriod;

                html += `
                    <div class="pbp-quarter-section${isCurrentPeriod ? '' : ' collapsed'}" data-period="${period}">
                        <div class="pbp-quarter-header" onclick="togglePbpQuarter(${period})">
                            <span>${periodLabel} (${periodPlays.length} plays)</span>
                            <span class="pbp-quarter-toggle">â–¼</span>
                        </div>
                        <div class="pbp-plays-list">
                `;

                periodPlays.forEach(play => {
                    const playClass = play.isOpponent ? 'opponent-play' : 'team-play';

                    html += `
                        <div class="pbp-entry ${playClass}" data-play-id="${play.id}" onclick="openDeletePlayModal(${play.id})">
                            <span class="pbp-entry-text">${escapeHtml(play.description)}</span>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function togglePbpQuarter(period) {
            const section = document.querySelector(`.pbp-quarter-section[data-period="${period}"]`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        function undoLastPlay() {
            const plays = liveGameStats.playByPlay || [];
            if (plays.length === 0) return;

            // Find the most recent play (by timestamp)
            const sortedPlays = [...plays].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const lastPlay = sortedPlays[0];
            
            if (lastPlay) {
                undoPlayByPlayEvent(lastPlay.id);
            }
        }

        let pendingDeletePlayId = null;

        function openDeletePlayModal(playId) {
            const play = liveGameStats.playByPlay.find(p => p.id === playId);
            if (!play) return;

            pendingDeletePlayId = playId;
            document.getElementById('delete-play-description').textContent = play.description;
            document.getElementById('delete-play-modal').classList.add('show');
        }

        function closeDeletePlayModal() {
            document.getElementById('delete-play-modal').classList.remove('show');
            pendingDeletePlayId = null;
        }

        function confirmDeletePlay() {
            if (pendingDeletePlayId !== null) {
                undoPlayByPlayEvent(pendingDeletePlayId);
                closeDeletePlayModal();
            }
        }

        function undoPlayByPlayEvent(eventId) {
            const playIndex = liveGameStats.playByPlay.findIndex(p => p.id === eventId);
            if (playIndex === -1) return;

            const play = liveGameStats.playByPlay[playIndex];
            const period = play.period;
            const periodStats = liveGameStats.periods[period];

            // Reverse the stat
            if (play.isOpponent) {
                // Reverse opponent stats
                switch (play.statType) {
                    case 'fg2pt':
                        periodStats.opponentPoints -= 2;
                        liveGameStats.opponentStats.points -= 2;
                        break;
                    case 'fg3pt':
                        periodStats.opponentPoints -= 3;
                        liveGameStats.opponentStats.points -= 3;
                        break;
                    case 'freeThrow':
                        periodStats.opponentPoints -= 1;
                        liveGameStats.opponentStats.points -= 1;
                        break;
                    case 'foul':
                        periodStats.opponentFouls -= 1;
                        liveGameStats.opponentStats.fouls -= 1;
                        break;
                    case 'rebound':
                        periodStats.opponentRebounds -= 1;
                        liveGameStats.opponentStats.rebounds -= 1;
                        break;
                    case 'turnover':
                        periodStats.opponentTurnovers -= 1;
                        liveGameStats.opponentStats.turnovers -= 1;
                        break;
                }
            } else {
                // Reverse team/player stats
                const playerId = play.playerId;
                const playerPeriodStats = periodStats.playerStats[playerId];

                if (playerPeriodStats) {
                    switch (play.statType) {
                        case 'fg2pt':
                            playerPeriodStats.points -= 2;
                            playerPeriodStats.fgMade -= 1;
                            playerPeriodStats.fgAttempted -= 1;
                            periodStats.teamPoints -= 2;
                            liveGameStats.teamStats.points -= 2;
                            break;
                        case 'fg3pt':
                            playerPeriodStats.points -= 3;
                            playerPeriodStats.fg3Made -= 1;
                            playerPeriodStats.fg3Attempted -= 1;
                            playerPeriodStats.fgMade -= 1;
                            playerPeriodStats.fgAttempted -= 1;
                            periodStats.teamPoints -= 3;
                            liveGameStats.teamStats.points -= 3;
                            break;
                        case 'freeThrow':
                            playerPeriodStats.points -= 1;
                            playerPeriodStats.ftMade -= 1;
                            playerPeriodStats.ftAttempted -= 1;
                            periodStats.teamPoints -= 1;
                            liveGameStats.teamStats.points -= 1;
                            break;
                        case 'freeThrowMiss':
                            playerPeriodStats.ftAttempted -= 1;
                            break;
                        case 'miss2pt':
                            playerPeriodStats.fgAttempted -= 1;
                            break;
                        case 'miss3pt':
                            playerPeriodStats.fg3Attempted -= 1;
                            playerPeriodStats.fgAttempted -= 1;
                            break;
                        case 'rebound':
                            playerPeriodStats.rebounds -= 1;
                            periodStats.teamRebounds -= 1;
                            liveGameStats.teamStats.rebounds -= 1;
                            break;
                        case 'assist':
                            playerPeriodStats.assists -= 1;
                            break;
                        case 'steal':
                            playerPeriodStats.steals -= 1;
                            // Also reverse the opponent turnover that was recorded with the steal
                            periodStats.opponentTurnovers -= 1;
                            liveGameStats.opponentStats.turnovers -= 1;
                            break;
                        case 'block':
                            playerPeriodStats.blocks -= 1;
                            break;
                        case 'turnover':
                            playerPeriodStats.turnovers -= 1;
                            periodStats.teamTurnovers -= 1;
                            liveGameStats.teamStats.turnovers -= 1;
                            break;
                        case 'foul':
                            playerPeriodStats.fouls -= 1;
                            periodStats.teamFouls -= 1;
                            liveGameStats.teamStats.fouls -= 1;
                            // Check if player was fouled out and should be unfouled
                            const totalFouls = Object.values(liveGameStats.periods).reduce((sum, p) => {
                                return sum + ((p.playerStats[playerId] || {}).fouls || 0);
                            }, 0);
                            if (totalFouls < 5) {
                                const fouledOutIndex = liveGameStats.fouledOut.indexOf(playerId);
                                if (fouledOutIndex > -1) {
                                    liveGameStats.fouledOut.splice(fouledOutIndex, 1);
                                }
                            }
                            break;
                    }
                }
            }

            // Remove the event from play-by-play
            liveGameStats.playByPlay.splice(playIndex, 1);

            // Update UI
            updateScoreboard();
            renderOnCourtPlayers();
            renderPlayByPlay();
            autoSaveGame();
        }

        // Opponent Team Actions
        function recordOpponentAction(actionType) {
            const periodStats = liveGameStats.periods[currentPeriod];
            let points = 0;
            
            switch(actionType) {
                case 'freeThrow':
                    periodStats.opponentPoints += 1;
                    liveGameStats.opponentStats.points += 1;
                    points = 1;
                    break;
                case 'fg2pt':
                    periodStats.opponentPoints += 2;
                    liveGameStats.opponentStats.points += 2;
                    points = 2;
                    break;
                case 'fg3pt':
                    periodStats.opponentPoints += 3;
                    liveGameStats.opponentStats.points += 3;
                    points = 3;
                    break;
                case 'foul':
                    periodStats.opponentFouls += 1;
                    liveGameStats.opponentStats.fouls += 1;
                    break;
                case 'rebound':
                    periodStats.opponentRebounds += 1;
                    liveGameStats.opponentStats.rebounds += 1;
                    break;
                case 'turnover':
                    periodStats.opponentTurnovers += 1;
                    liveGameStats.opponentStats.turnovers += 1;
                    break;
            }

            // Add to play-by-play
            addPlayByPlayEvent({
                statType: actionType,
                isOpponent: true,
                points: points
            });

            updateScoreboard();
        }

        // Scoring Team Actions
        function recordTeamAction(actionType) {
            pendingAction = actionType;
            
            // Actions that require player selection
            if (['fg2pt', 'fg3pt', 'miss2pt', 'miss3pt', 'freeThrow', 'rebound', 'assist', 'steal', 'block', 'foul', 'turnover'].includes(actionType)) {
                openPlayerSelection(actionType);
            }
        }

        function openPlayerSelection(actionType) {
            const modal = document.getElementById('player-selection-modal');
            const title = document.getElementById('player-selection-title');
            const action = document.getElementById('player-selection-action');
            const onCourtList = document.getElementById('player-selection-on-court-list');
            const benchList = document.getElementById('player-selection-bench-list');
            const onCourtTitle = document.getElementById('player-selection-on-court-title');
            const benchTitle = document.getElementById('player-selection-bench-title');
            
            // Set title based on action
            const actionTitles = {
                'fg2pt': 'Who made the 2-point field goal?',
                'fg3pt': 'Who made the 3-point field goal?',
                'miss2pt': 'Who missed the 2-point field goal?',
                'miss3pt': 'Who missed the 3-point field goal?',
                'freeThrow': 'Who took the free throw?',
                'rebound': 'Who got the rebound?',
                'assist': 'Who made the assist?',
                'steal': 'Who made the steal?',
                'block': 'Who made the block?',
                'foul': 'Who committed the foul?',
                'turnover': 'Who had the turnover?'
            };
            
            title.textContent = actionTitles[actionType] || 'Select Player';
            const currentTeam = TeamService.getCurrentTeam();
            action.textContent = currentTeam ? currentTeam.teamName : 'Scoring Team';
            
            onCourtList.innerHTML = '';
            benchList.innerHTML = '';

            // Get roster
            const roster = currentViewingGame.metadata.roster || [];
            const fouledOutIds = new Set(liveGameStats.fouledOut || []);
            // Only show present players who are not fouled out
            const presentPlayers = roster.filter(p => p.present && !fouledOutIds.has(p.id));
            const onCourtIds = new Set(liveGameStats.onCourt);
            
            // Separate on-court and bench players
            const onCourtPlayers = presentPlayers.filter(p => onCourtIds.has(p.id));
            const benchPlayers = presentPlayers.filter(p => !onCourtIds.has(p.id));

            // Render on-court players
            onCourtTitle.textContent = `On the Court (${onCourtPlayers.length})`;
            onCourtPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'assist-player-item on-court';
                item.innerHTML = `
                    <div class="assist-player-number">#${player.number || player.id}</div>
                    <div class="assist-player-name">${escapeHtml(player.name)}</div>
                `;
                item.onclick = () => selectPlayerForAction(player.id, actionType);
                onCourtList.appendChild(item);
            });

            // Render bench players
            benchTitle.textContent = `Bench (${benchPlayers.length})`;
            benchPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'assist-player-item';
                item.innerHTML = `
                    <div class="assist-player-number">#${player.number || player.id}</div>
                    <div class="assist-player-name">${escapeHtml(player.name)}</div>
                `;
                item.onclick = () => selectPlayerForAction(player.id, actionType);
                benchList.appendChild(item);
            });

            modal.classList.add('show');
            // Scroll modal to top
            const modalDialog = modal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function selectPlayerForAction(playerId, actionType) {
            const periodStats = liveGameStats.periods[currentPeriod];
            const playerPeriodStats = periodStats.playerStats[playerId] || {
                points: 0, fouls: 0, fgMade: 0, fgAttempted: 0,
                fg3Made: 0, fg3Attempted: 0, ftMade: 0, ftAttempted: 0,
                rebounds: 0, assists: 0, steals: 0, blocks: 0, turnovers: 0
            };
            periodStats.playerStats[playerId] = playerPeriodStats;

            // Get player info for play-by-play
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === playerId);
            const playerName = player ? player.name : 'Unknown';
            const playerNumber = player ? player.number : '';

            switch(actionType) {
                case 'fg2pt':
                    playerPeriodStats.points += 2;
                    playerPeriodStats.fgMade += 1;
                    playerPeriodStats.fgAttempted += 1;
                    periodStats.teamPoints += 2;
                    liveGameStats.teamStats.points += 2;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'fg2pt',
                        points: 2
                    });
                    pendingAssist = {playerId, points: 2, period: currentPeriod};
                    closePlayerSelection();
                    updateScoreboard();
                    openAssistAssignmentModal(playerId, '2-point FG made');
                    return; // Don't continue, wait for assist assignment
                case 'fg3pt':
                    playerPeriodStats.points += 3;
                    playerPeriodStats.fg3Made += 1;
                    playerPeriodStats.fg3Attempted += 1;
                    playerPeriodStats.fgMade += 1;
                    playerPeriodStats.fgAttempted += 1;
                    periodStats.teamPoints += 3;
                    liveGameStats.teamStats.points += 3;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'fg3pt',
                        points: 3
                    });
                    pendingAssist = {playerId, points: 3, period: currentPeriod};
                    closePlayerSelection();
                    updateScoreboard();
                    openAssistAssignmentModal(playerId, '3-point FG made');
                    return; // Don't continue, wait for assist assignment
                case 'miss2pt':
                    playerPeriodStats.fgAttempted += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'miss2pt'
                    });
                    break;
                case 'miss3pt':
                    playerPeriodStats.fg3Attempted += 1;
                    playerPeriodStats.fgAttempted += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'miss3pt'
                    });
                    break;
                case 'freeThrow':
                    // Open free throw assignment modal
                    pendingFreeThrow = {playerId, count: null, shots: []};
                    closePlayerSelection();
                    openFreeThrowAssignmentModal(playerId);
                    return; // Don't continue, wait for free throw assignment
                case 'rebound':
                    playerPeriodStats.rebounds += 1;
                    periodStats.teamRebounds += 1;
                    liveGameStats.teamStats.rebounds += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'rebound'
                    });
                    break;
                case 'assist':
                    // Record assist for the assisting player
                    playerPeriodStats.assists += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'assist'
                    });
                    pendingAssist = null;
                    break;
                case 'steal':
                    playerPeriodStats.steals += 1;
                    // Record opponent turnover
                    periodStats.opponentTurnovers += 1;
                    liveGameStats.opponentStats.turnovers += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'steal'
                    });
                    break;
                case 'block':
                    playerPeriodStats.blocks += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'block'
                    });
                    break;
                case 'foul':
                    playerPeriodStats.fouls += 1;
                    periodStats.teamFouls += 1;
                    liveGameStats.teamStats.fouls += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'foul'
                    });
                    
                    // Check if player has reached 5 fouls
                    const totalFouls = Object.values(liveGameStats.periods).reduce((sum, p) => {
                        return sum + ((p.playerStats[playerId] || {}).fouls || 0);
                    }, 0);
                    
                    if (totalFouls >= 5 && !liveGameStats.fouledOut.includes(playerId)) {
                        // Mark player as fouled out
                        liveGameStats.fouledOut.push(playerId);
                        
                        // Check if player is currently on court
                        if (liveGameStats.onCourt.includes(playerId)) {
                            // Automatically open substitution modal for fouled out player
                            setTimeout(() => {
                                openFouledOutSubstitutionModal(playerId);
                            }, 500); // Small delay to ensure foul is recorded
                        }
                    }
                    break;
                case 'turnover':
                    playerPeriodStats.turnovers += 1;
                    periodStats.teamTurnovers += 1;
                    liveGameStats.teamStats.turnovers += 1;
                    // Add to play-by-play
                    addPlayByPlayEvent({
                        playerId, playerName, playerNumber,
                        statType: 'turnover'
                    });
                    break;
            }

            // Handle free throw after player selection (legacy code path)
            if (actionType === 'freeThrow') {
                closePlayerSelection();
                const playerNameDisplay = player ? `${player.name} (#${player.number || playerId})` : 'Player';
                setTimeout(() => {
                    showFreeThrowModal(playerNameDisplay, playerId, periodStats);
                }, 100);
                return;
            }

            closePlayerSelection();
            
            // If steal was recorded, animate opponent TO button after modal closes
            if (actionType === 'steal') {
                setTimeout(() => {
                    animateOpponentTurnover();
                }, 300); // Small delay to ensure modal is closed
            }
            
            updateScoreboard();
            renderOnCourtPlayers();
            autoSaveGame();
        }

        function animateOpponentTurnover() {
            const btn = document.getElementById('opponent-turnover-btn');
            if (!btn) return;
            
            // Add animation class
            btn.classList.add('animate-highlight');
            
            // Remove animation class after animation completes
            setTimeout(() => {
                btn.classList.remove('animate-highlight');
            }, 1500);
        }

        function closePlayerSelection() {
            document.getElementById('player-selection-modal').classList.remove('show');
            pendingAction = null;
        }

        function closePlayerSelectionIfOutside(event) {
            if (event.target.id === 'player-selection-modal') {
                closePlayerSelection();
            }
        }

        function renderOnCourtPlayers() {
            const container = document.getElementById('on-court-players');
            if (!container) return;
            
            // Save the substitution button before clearing
            const subButton = container.querySelector('.inline-sub-btn');
            
            container.innerHTML = '';
            
            const roster = currentViewingGame.metadata.roster || [];
            const onCourtPlayers = liveGameStats.onCourt.map(id => {
                const player = roster.find(p => p.id === id);
                return player ? {...player, id} : null;
            }).filter(p => p !== null);

            onCourtPlayers.forEach(player => {
                const totalFouls = Object.values(liveGameStats.periods).reduce((sum, p) => {
                    return sum + ((p.playerStats[player.id] || {}).fouls || 0);
                }, 0);

                // Determine badge color based on foul count
                let badgeClass = 'foul-badge';
                if (totalFouls >= 4) {
                    badgeClass = 'foul-badge foul-badge-red';
                } else if (totalFouls >= 3) {
                    badgeClass = 'foul-badge foul-badge-yellow';
                }

                const playerDiv = document.createElement('div');
                playerDiv.className = 'on-court-player';
                playerDiv.innerHTML = `
                    <div class="player-number">#${player.number || player.id}</div>
                    <div class="player-name-small">${escapeHtml(player.name)}</div>
                    <div class="${badgeClass}">${totalFouls} PF</div>
                `;
                container.appendChild(playerDiv);
            });

            // Re-add the substitution button if it existed, or create it if it doesn't
            let subBtn = subButton;
            if (!subBtn) {
                subBtn = document.createElement('button');
                subBtn.className = 'swap-players-btn compact-sub-btn inline-sub-btn';
                subBtn.onclick = () => openSubstitutionDialog();
                subBtn.title = 'Substitute Players';
                subBtn.innerHTML = `
                    <span class="swap-icon">â‡„</span>
                    <span class="sub-btn-text">Sub</span>
                    <span class="player-count-badge" id="on-court-count">${onCourtPlayers.length}</span>
                `;
            }
            container.appendChild(subBtn);

            // Update count badge
            const countElement = document.getElementById('on-court-count');
            if (countElement) {
                countElement.textContent = onCourtPlayers.length;
            }
        }

        // Substitution state
        let substitutionSelectedOut = [];
        let substitutionSelectedIn = [];

        function openSubstitutionDialog() {
            const modal = document.getElementById('substitution-modal');
            const outList = document.getElementById('sub-out-players-list');
            const inList = document.getElementById('sub-in-players-list');
            const instruction = document.getElementById('substitution-instruction');
            const confirmBtn = document.getElementById('confirm-sub-btn');
            
            outList.innerHTML = '';
            inList.innerHTML = '';
            
            // Reset selection state
            substitutionSelectedOut = [];
            substitutionSelectedIn = [];

            const roster = currentViewingGame.metadata.roster || [];
            // Only show players who were originally present
            const presentPlayers = roster.filter(p => p.present);
            const onCourtIds = new Set(liveGameStats.onCourt);
            const fouledOutIds = new Set(liveGameStats.fouledOut || []);

            // Helper function to get total fouls for a player
            const getPlayerTotalFouls = (playerId) => {
                return Object.values(liveGameStats.periods).reduce((sum, p) => {
                    return sum + ((p.playerStats[playerId] || {}).fouls || 0);
                }, 0);
            };

            // Players on court
            liveGameStats.onCourt.forEach(playerId => {
                const player = roster.find(p => p.id === playerId);
                if (!player || !player.present) return; // Skip if not present
                
                const isFouledOut = fouledOutIds.has(playerId);
                const totalFouls = getPlayerTotalFouls(playerId);
                
                // Determine foul warning class
                let foulWarningClass = '';
                let pfBadgeClass = 'normal';
                if (totalFouls >= 4) {
                    foulWarningClass = 'foul-warning-red';
                    pfBadgeClass = 'danger';
                } else if (totalFouls >= 3) {
                    foulWarningClass = 'foul-warning-yellow';
                    pfBadgeClass = 'warning';
                }
                
                const item = document.createElement('div');
                item.className = 'substitution-player-item';
                if (isFouledOut) {
                    item.classList.add('fouled-out-player');
                }
                if (foulWarningClass) {
                    item.classList.add(foulWarningClass);
                }
                item.dataset.playerId = playerId;
                item.innerHTML = `
                    <div class="player-info">
                        <span class="player-number">#${player.number || player.id}</span>
                        <span>${escapeHtml(player.name)}</span>
                        <span class="substitution-pf-badge ${pfBadgeClass}">${totalFouls} PF</span>
                        ${isFouledOut ? '<span style="color: #dc3545; font-weight: bold; margin-left: 8px;">(Fouled Out)</span>' : ''}
                    </div>
                `;
                item.onclick = () => {
                    // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
                    const playerId = item.dataset.playerId;
                    const index = substitutionSelectedOut.indexOf(playerId);
                    
                    if (index > -1) {
                        // Deselect
                        substitutionSelectedOut.splice(index, 1);
                        item.classList.remove('selected-out');
                    } else {
                        // Select
                        substitutionSelectedOut.push(playerId);
                        item.classList.add('selected-out');
                    }
                    
                    // Use window reference to ensure we get the latest update function
                    if (window.updateSubstitutionUI) {
                        window.updateSubstitutionUI();
                    }
                };
                outList.appendChild(item);
            });

            // Available players (only those who were present and not fouled out)
            const availablePlayers = presentPlayers.filter(p => !onCourtIds.has(p.id) && !fouledOutIds.has(p.id));
            availablePlayers.forEach(player => {
                const totalFouls = getPlayerTotalFouls(player.id);
                
                // Determine foul warning class
                let foulWarningClass = '';
                let pfBadgeClass = 'normal';
                if (totalFouls >= 4) {
                    foulWarningClass = 'foul-warning-red';
                    pfBadgeClass = 'danger';
                } else if (totalFouls >= 3) {
                    foulWarningClass = 'foul-warning-yellow';
                    pfBadgeClass = 'warning';
                }
                
                const item = document.createElement('div');
                item.className = 'substitution-player-item';
                if (foulWarningClass) {
                    item.classList.add(foulWarningClass);
                }
                item.dataset.playerId = player.id;
                item.innerHTML = `
                    <div class="player-info">
                        <span class="player-number">#${player.number || player.id}</span>
                        <span>${escapeHtml(player.name)}</span>
                        <span class="substitution-pf-badge ${pfBadgeClass}">${totalFouls} PF</span>
                    </div>
                `;
                item.onclick = () => {
                    // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
                    const playerId = item.dataset.playerId;
                    const index = substitutionSelectedIn.indexOf(playerId);
                    
                    if (index > -1) {
                        // Deselect
                        substitutionSelectedIn.splice(index, 1);
                        item.classList.remove('selected-in');
                    } else {
                        // Only allow selecting if we have equal or fewer than selected out
                        if (substitutionSelectedIn.length < substitutionSelectedOut.length) {
                            substitutionSelectedIn.push(playerId);
                            item.classList.add('selected-in');
                        }
                    }
                    
                    // Use window reference to ensure we get the latest update function
                    if (window.updateSubstitutionUI) {
                        window.updateSubstitutionUI();
                    }
                };
                inList.appendChild(item);
            });

            // Show fouled out players at the bottom (not selectable)
            const fouledOutPlayers = presentPlayers.filter(p => fouledOutIds.has(p.id));
            const fouledOutSection = document.getElementById('fouled-out-section');
            const fouledOutList = document.getElementById('fouled-out-players-list');
            
            if (fouledOutPlayers.length > 0) {
                fouledOutSection.style.display = 'block';
                fouledOutList.innerHTML = '';
                
                fouledOutPlayers.forEach(player => {
                    const totalFouls = getPlayerTotalFouls(player.id);
                    const item = document.createElement('div');
                    item.className = 'substitution-player-item fouled-out-player';
                    item.style.cursor = 'not-allowed';
                    item.style.opacity = '0.7';
                    item.innerHTML = `
                        <div class="player-info">
                            <span class="player-number">#${player.number || player.id}</span>
                            <span>${escapeHtml(player.name)}</span>
                            <span class="substitution-pf-badge danger">${totalFouls} PF</span>
                            <span style="color: #dc3545; font-weight: bold; margin-left: 8px;">(Fouled Out)</span>
                        </div>
                    `;
                    // No onclick - they can't be selected
                    fouledOutList.appendChild(item);
                });
            } else {
                fouledOutSection.style.display = 'none';
            }
            
            // Store reference to update function
            window.updateSubstitutionUI = function() {
                // Update instruction text
                if (substitutionSelectedOut.length === 0) {
                    instruction.textContent = 'Select players to sub out, then select equal number to sub in';
                    confirmBtn.disabled = true;
                } else if (substitutionSelectedIn.length < substitutionSelectedOut.length) {
                    instruction.textContent = `Selected ${substitutionSelectedOut.length} to sub out. Select ${substitutionSelectedOut.length} player${substitutionSelectedOut.length > 1 ? 's' : ''} to sub in.`;
                    confirmBtn.disabled = true;
                } else if (substitutionSelectedIn.length === substitutionSelectedOut.length) {
                    instruction.textContent = `Ready to substitute ${substitutionSelectedOut.length} player${substitutionSelectedOut.length > 1 ? 's' : ''}`;
                    confirmBtn.disabled = false;
                } else {
                    instruction.textContent = 'Too many players selected to sub in. Please deselect some.';
                    confirmBtn.disabled = true;
                }
            };
            
            // Initialize UI
            window.updateSubstitutionUI();

            modal.classList.add('show');
        }

        function confirmSubstitution() {
            if (substitutionSelectedOut.length === 0 || substitutionSelectedIn.length === 0) {
                alert('Please select players to sub out and sub in.');
                return;
            }

            if (substitutionSelectedOut.length !== substitutionSelectedIn.length) {
                alert(`Please select equal numbers: ${substitutionSelectedOut.length} out, ${substitutionSelectedIn.length} in.`);
                return;
            }

            // Ensure substitutions array exists
            if (!liveGameStats.substitutions) {
                liveGameStats.substitutions = [];
            }

            // Debug logging
            console.log('Substitution - Selected Out:', substitutionSelectedOut);
            console.log('Substitution - Selected In:', substitutionSelectedIn);
            console.log('Substitution - Current onCourt:', liveGameStats.onCourt);

            // Update on-court list - replace selected out players with selected in players
            substitutionSelectedOut.forEach((playerOutId, index) => {
                const playerInId = substitutionSelectedIn[index];
                const courtIndex = liveGameStats.onCourt.indexOf(playerOutId);
                console.log(`Looking for player ${playerOutId} in onCourt, found at index:`, courtIndex);
                
                if (courtIndex !== -1) {
                    liveGameStats.onCourt[courtIndex] = playerInId;
                    console.log(`Replaced player at index ${courtIndex}: ${playerOutId} -> ${playerInId}`);
                    
                    // Record substitution
                    liveGameStats.substitutions.push({
                        period: currentPeriod,
                        time: new Date().toISOString(),
                        playerOut: playerOutId,
                        playerIn: playerInId
                    });
                } else {
                    // Player not found in onCourt - try to add the new player anyway if we have space
                    console.warn(`Player ${playerOutId} not found in onCourt array. Current onCourt:`, liveGameStats.onCourt);
                    // If we have less than 5 players, add the new player
                    if (liveGameStats.onCourt.length < 5) {
                        liveGameStats.onCourt.push(playerInId);
                        console.log(`Added player ${playerInId} to onCourt (now ${liveGameStats.onCourt.length} players)`);
                        // Record substitution
                        liveGameStats.substitutions.push({
                            period: currentPeriod,
                            time: new Date().toISOString(),
                            playerOut: playerOutId,
                            playerIn: playerInId
                        });
                    }
                }
            });
            
            console.log('Substitution - Final onCourt:', liveGameStats.onCourt);

            // Reset selection state
            substitutionSelectedOut = [];
            substitutionSelectedIn = [];

            closeSubstitutionDialog();
            renderOnCourtPlayers();
            autoSaveGame();
        }

        function openFouledOutSubstitutionModal(fouledOutPlayerId) {
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === fouledOutPlayerId);
            const playerName = player ? player.name : 'Player';
            
            // Debug logging
            console.log('Opening fouled-out substitution modal for player:', fouledOutPlayerId);
            console.log('Current onCourt:', liveGameStats.onCourt);
            console.log('Player in onCourt?', liveGameStats.onCourt.includes(fouledOutPlayerId));
            
            // Ensure player is still in onCourt (they should be, but verify)
            if (!liveGameStats.onCourt.includes(fouledOutPlayerId)) {
                console.warn(`Fouled-out player ${fouledOutPlayerId} is not in onCourt! Adding them back.`);
                // If they're not in onCourt but should be, add them back
                if (liveGameStats.onCourt.length < 5) {
                    liveGameStats.onCourt.push(fouledOutPlayerId);
                }
            }
            
            // Open the substitution modal first (it will reset the arrays)
            openSubstitutionDialog();
            
            // Immediately restore pre-selection of fouled out player (required, cannot be deselected)
            // Ensure we use the exact same ID format as stored in onCourt
            substitutionSelectedOut = [fouledOutPlayerId];
            substitutionSelectedIn = [];
            
            // Update instruction and lock fouled out player
            setTimeout(() => {
                // Ensure modal is scrolled to top
                const modal = document.getElementById('substitution-modal');
                const modalDialog = modal.querySelector('.modal-dialog');
                if (modalDialog) {
                    modalDialog.scrollTop = 0;
                }
                const instruction = document.getElementById('substitution-instruction');
                const confirmBtn = document.getElementById('confirm-sub-btn');
                const outList = document.getElementById('sub-out-players-list');
                const fouledOutItem = outList.querySelector(`[data-player-id="${fouledOutPlayerId}"]`);
                
                if (fouledOutItem) {
                    // Ensure fouled-out player is in the selection array
                    if (!substitutionSelectedOut.includes(fouledOutPlayerId)) {
                        substitutionSelectedOut.push(fouledOutPlayerId);
                    }
                    fouledOutItem.classList.add('selected-out', 'required-substitution');
                    // Disable clicking on fouled out player (they must be subbed out)
                    fouledOutItem.onclick = null;
                    fouledOutItem.style.cursor = 'default';
                    // Remove the "(Fouled Out)" text to keep it clean
                    const playerInfo = fouledOutItem.querySelector('.player-info');
                    if (playerInfo) {
                        const fouledOutText = playerInfo.querySelector('span[style*="color: #dc3545"]');
                        if (fouledOutText && fouledOutText.textContent.includes('Fouled Out')) {
                            fouledOutText.remove();
                        }
                    }
                } else {
                    console.warn(`Fouled-out player item not found for player ID: ${fouledOutPlayerId}`);
                }
                
                // Update click handlers for other "out" players to allow additional selections
                const outItems = outList.querySelectorAll('.substitution-player-item');
                outItems.forEach(item => {
                    // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
                    const itemPlayerId = item.dataset.playerId;
                    if (itemPlayerId !== fouledOutPlayerId) {
                        // Re-bind to allow normal multi-select
                        item.onclick = () => {
                            const playerId = item.dataset.playerId;
                            const index = substitutionSelectedOut.indexOf(playerId);
                            
                            if (index > -1) {
                                // Deselect (but keep fouled out player selected)
                                substitutionSelectedOut.splice(index, 1);
                                item.classList.remove('selected-out');
                            } else {
                                // Select additional player
                                substitutionSelectedOut.push(playerId);
                                item.classList.add('selected-out');
                            }
                            
                            // Update UI
                            if (window.updateSubstitutionUI) {
                                window.updateSubstitutionUI();
                            }
                        };
                    }
                });
                
                // Create custom update function for fouled out scenario
                const updateFouledOutUI = function() {
                    // Ensure fouled out player is always selected
                    if (!substitutionSelectedOut.includes(fouledOutPlayerId)) {
                        substitutionSelectedOut.push(fouledOutPlayerId);
                    }
                    
                    const totalOut = substitutionSelectedOut.length;
                    const totalIn = substitutionSelectedIn.length;
                    
                    if (totalIn === 0) {
                        instruction.textContent = `${playerName} has fouled out (5 fouls) and must be subbed out. ${totalOut > 1 ? `You've selected ${totalOut} players to sub out. ` : ''}Select ${totalOut} player${totalOut > 1 ? 's' : ''} to sub in.`;
                        confirmBtn.disabled = true;
                    } else if (totalIn < totalOut) {
                        instruction.textContent = `Selected ${totalOut} to sub out (${playerName} fouled out). Select ${totalOut} player${totalOut > 1 ? 's' : ''} to sub in.`;
                        confirmBtn.disabled = true;
                    } else if (totalIn === totalOut) {
                        instruction.textContent = `Ready to substitute ${totalOut} player${totalOut > 1 ? 's' : ''} (${playerName} fouled out)`;
                        confirmBtn.disabled = false;
                    } else {
                        instruction.textContent = `Too many players selected to sub in. Please select ${totalOut} player${totalOut > 1 ? 's' : ''}.`;
                        confirmBtn.disabled = true;
                    }
                };
                
                // Replace the update function
                window.updateSubstitutionUI = updateFouledOutUI;
                
                // Re-bind all click handlers in the "in" list to allow multi-select
                const inList = document.getElementById('sub-in-players-list');
                const inItems = inList.querySelectorAll('.substitution-player-item');
                inItems.forEach(item => {
                    item.onclick = () => {
                        // Keep player IDs as strings (they're stored as "p1", "p2", etc.)
                        const playerId = item.dataset.playerId;
                        const index = substitutionSelectedIn.indexOf(playerId);
                        
                        if (index > -1) {
                            // Deselect
                            substitutionSelectedIn.splice(index, 1);
                            item.classList.remove('selected-in');
                        } else {
                            // Allow selecting up to the number of players selected out
                            if (substitutionSelectedIn.length < substitutionSelectedOut.length) {
                                substitutionSelectedIn.push(playerId);
                                item.classList.add('selected-in');
                            }
                        }
                        
                        updateFouledOutUI();
                    };
                });
                
                // Initial update
                updateFouledOutUI();
            }, 200);
        }

        function closeSubstitutionDialog() {
            document.getElementById('substitution-modal').classList.remove('show');
            // Reset selection state
            substitutionSelectedOut = [];
            substitutionSelectedIn = [];
        }

        function closeSubstitutionIfOutside(event) {
            if (event.target.id === 'substitution-modal') {
                closeSubstitutionDialog();
            }
        }

        async function renderStatsTab() {
            await renderBoxScoreByPeriod();
            renderPlayerStatsTable();
        }

        async function renderBoxScoreByPeriod() {
            const container = document.getElementById('box-score-by-period');
            
            // Calculate totals
            const opponentTotal = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.opponentPoints, 0);
            const teamTotal = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamPoints, 0);
            
            // Get period scores
            const periodScores = [];
            for (let p = 1; p <= 4; p++) {
                const periodStats = liveGameStats.periods[p];
                periodScores.push({
                    period: p,
                    opponent: periodStats.opponentPoints || 0,
                    team: periodStats.teamPoints || 0
                });
            }
            
            let html = '<table class="box-score-table"><thead><tr>';
            html += '<th class="box-score-team-label"></th>'; // Empty cell for team names
            
            // Period headers at the top
            for (let p = 1; p <= 4; p++) {
                html += `<th class="box-score-period-header">${p}</th>`;
            }
            html += '<th class="box-score-total-header">T</th>';
            html += '</tr></thead><tbody>';
            
            // Opponent Team row
            html += '<tr class="box-score-team-row">';
            html += '<td class="box-score-team-name">Opponent Team</td>';
            for (let p = 1; p <= 4; p++) {
                const score = periodScores[p - 1].opponent;
                html += `<td class="box-score-period-value">${score}</td>`;
            }
            html += `<td class="box-score-total-value"><strong>${opponentTotal}</strong></td>`;
            html += '</tr>';
            
            // Scoring Team row
            const currentTeam = await TeamService.getCurrentTeam();
            const teamName = currentTeam ? (currentTeam.teamName || currentTeam.name) : 'Scoring Team';
            html += '<tr class="box-score-team-row">';
            html += `<td class="box-score-team-name">${escapeHtml(teamName)}</td>`;
            for (let p = 1; p <= 4; p++) {
                const score = periodScores[p - 1].team;
                html += `<td class="box-score-period-value">${score}</td>`;
            }
            html += `<td class="box-score-total-value"><strong>${teamTotal}</strong></td>`;
            html += '</tr>';
            
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }

        function renderTeamStatsByPeriod() {
            const container = document.getElementById('team-stats-by-period');
            let html = '<table class="stats-table"><thead><tr><th>Period</th><th>Team Fouls</th><th>Team Timeouts</th></tr></thead><tbody>';
            
            for (let p = 1; p <= 5; p++) {
                const periodStats = liveGameStats.periods[p];
                if (periodStats.teamFouls === 0 && periodStats.teamTimeouts === 0) continue;
                
                html += `<tr>
                    <td>Period ${p === 5 ? 'OT' : p}</td>
                    <td>${periodStats.teamFouls}</td>
                    <td>${periodStats.teamTimeouts}</td>
                </tr>`;
            }
            
            const totalFouls = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamFouls, 0);
            const totalTimeouts = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamTimeouts, 0);
            
            html += `<tr style="font-weight: bold; border-top: 2px solid #333;">
                <td>Total</td>
                <td>${totalFouls}</td>
                <td>${totalTimeouts}</td>
            </tr></tbody></table>`;
            
            container.innerHTML = html;
        }

        // Player stats table sort state
        let playerStatsSortColumn = 'number';
        let playerStatsSortDirection = 'asc';

        function renderPlayerStatsTable() {
            const container = document.getElementById('player-stats-table');
            const roster = currentViewingGame.metadata.roster || [];
            const presentPlayers = roster.filter(p => p.present);
            
            // Build player stats data
            const playersData = presentPlayers.map(player => {
                let totalStats = {
                    points: 0, fouls: 0, fgMade: 0, fgAttempted: 0,
                    fg3Made: 0, fg3Attempted: 0, ftMade: 0, ftAttempted: 0,
                    rebounds: 0, assists: 0, steals: 0, blocks: 0, turnovers: 0
                };
                
                // Aggregate across all periods
                Object.values(liveGameStats.periods).forEach(periodStats => {
                    const playerStats = periodStats.playerStats[player.id] || {};
                    Object.keys(totalStats).forEach(key => {
                        totalStats[key] += (playerStats[key] || 0);
                    });
                });
                
                const fgPct = totalStats.fgAttempted > 0 ? (totalStats.fgMade / totalStats.fgAttempted * 100) : 0;
                const fg3Pct = totalStats.fg3Attempted > 0 ? (totalStats.fg3Made / totalStats.fg3Attempted * 100) : 0;
                const ftPct = totalStats.ftAttempted > 0 ? (totalStats.ftMade / totalStats.ftAttempted * 100) : 0;
                const plusMinus = 0; // TODO: Implement proper +/- tracking
                
                return {
                    id: player.id,
                    name: player.name,
                    number: parseInt(player.number) || player.id,
                    ...totalStats,
                    fgPct,
                    fg3Pct,
                    ftPct,
                    plusMinus
                };
            });

            // Sort players
            playersData.sort((a, b) => {
                let aVal = a[playerStatsSortColumn];
                let bVal = b[playerStatsSortColumn];
                
                // Handle string comparison for name
                if (playerStatsSortColumn === 'name') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (aVal < bVal) return playerStatsSortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return playerStatsSortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            // Find leaders for each stat category (only if > 0)
            const leaderStats = ['points', 'assists', 'rebounds', 'blocks', 'steals', 'fgPct', 'ftPct', 'fg3Pct', 'plusMinus'];
            const badStats = ['turnovers', 'fouls'];
            const leaders = {};
            
            [...leaderStats, ...badStats].forEach(stat => {
                const maxVal = Math.max(...playersData.map(p => p[stat]));
                if (maxVal > 0) {
                    leaders[stat] = maxVal;
                }
            });

            // Helper function to format stat value
            const formatStat = (value, isLeader, isBadStat = false) => {
                if (value === 0) {
                    return { display: '-', className: 'stat-zero' };
                }
                let className = '';
                if (isLeader) {
                    className = isBadStat ? 'stat-leader-bad' : 'stat-leader-good';
                }
                return { display: value, className };
            };

            const formatPct = (value, isLeader) => {
                if (value === 0) {
                    return { display: '-', className: 'stat-zero' };
                }
                let className = isLeader ? 'stat-leader-good' : '';
                return { display: value.toFixed(1) + '%', className };
            };

            const formatRatio = (made, attempted) => {
                if (made === 0 && attempted === 0) {
                    return { display: '-', className: 'stat-zero' };
                }
                return { display: `${made}/${attempted}`, className: '' };
            };

            // Build header with sort indicators
            const sortHeader = (label, column, extraClass = '') => {
                const isActive = playerStatsSortColumn === column;
                const sortClass = isActive ? (playerStatsSortDirection === 'asc' ? 'sort-asc' : 'sort-desc') : '';
                const sortIndicator = isActive ? (playerStatsSortDirection === 'asc' ? 'â–²' : 'â–¼') : '';
                return `<th class="${extraClass} sortable ${sortClass}" onclick="sortPlayerStats('${column}')">${label}<span class="sort-indicator">${sortIndicator}</span></th>`;
            };

            let html = '<table class="stats-table" id="player-stats-table-inner"><thead><tr>';
            html += sortHeader('Player', 'name', 'player-name-col');
            html += sortHeader('#', 'number', 'number-col');
            html += sortHeader('PTS', 'points');
            html += sortHeader('AST', 'assists');
            html += sortHeader('REB', 'rebounds');
            html += sortHeader('BLK', 'blocks');
            html += sortHeader('STL', 'steals');
            html += sortHeader('TO', 'turnovers');
            html += sortHeader('Foul', 'fouls');
            html += '<th>FG</th>';
            html += sortHeader('FG%', 'fgPct');
            html += '<th>FT</th>';
            html += sortHeader('FT%', 'ftPct');
            html += '<th>3PT</th>';
            html += sortHeader('3PT%', 'fg3Pct');
            html += sortHeader('+/-', 'plusMinus');
            html += '</tr></thead><tbody>';
            
            playersData.forEach(player => {
                const pts = formatStat(player.points, player.points === leaders.points);
                const ast = formatStat(player.assists, player.assists === leaders.assists);
                const reb = formatStat(player.rebounds, player.rebounds === leaders.rebounds);
                const blk = formatStat(player.blocks, player.blocks === leaders.blocks);
                const stl = formatStat(player.steals, player.steals === leaders.steals);
                const to = formatStat(player.turnovers, player.turnovers === leaders.turnovers, true);
                const foul = formatStat(player.fouls, player.fouls === leaders.fouls, true);
                const fg = formatRatio(player.fgMade, player.fgAttempted);
                const fgPct = formatPct(player.fgPct, player.fgPct === leaders.fgPct);
                const ft = formatRatio(player.ftMade, player.ftAttempted);
                const ftPct = formatPct(player.ftPct, player.ftPct === leaders.ftPct);
                const fg3 = formatRatio(player.fg3Made, player.fg3Attempted);
                const fg3Pct = formatPct(player.fg3Pct, player.fg3Pct === leaders.fg3Pct);
                const pm = formatStat(player.plusMinus, player.plusMinus === leaders.plusMinus);
                const pmDisplay = player.plusMinus === 0 ? '-' : (player.plusMinus >= 0 ? '+' : '') + player.plusMinus;
                
                html += `<tr>
                    <td class="player-name-col">${escapeHtml(player.name)}</td>
                    <td class="number-col">#${player.number}</td>
                    <td class="${pts.className}">${pts.display}</td>
                    <td class="${ast.className}">${ast.display}</td>
                    <td class="${reb.className}">${reb.display}</td>
                    <td class="${blk.className}">${blk.display}</td>
                    <td class="${stl.className}">${stl.display}</td>
                    <td class="${to.className}">${to.display}</td>
                    <td class="${foul.className}">${foul.display}</td>
                    <td class="${fg.className}">${fg.display}</td>
                    <td class="${fgPct.className}">${fgPct.display}</td>
                    <td class="${ft.className}">${ft.display}</td>
                    <td class="${ftPct.className}">${ftPct.display}</td>
                    <td class="${fg3.className}">${fg3.display}</td>
                    <td class="${fg3Pct.className}">${fg3Pct.display}</td>
                    <td class="${pm.className}">${player.plusMinus === 0 ? '-' : pmDisplay}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function sortPlayerStats(column) {
            if (playerStatsSortColumn === column) {
                // Toggle direction if same column
                playerStatsSortDirection = playerStatsSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column - default to descending for stats, ascending for name/number
                playerStatsSortColumn = column;
                playerStatsSortDirection = (column === 'name' || column === 'number') ? 'asc' : 'desc';
            }
            renderPlayerStatsTable();
        }

        function renderRosterTab() {
            const container = document.getElementById('live-stats-roster-list');
            const roster = currentViewingGame.metadata.roster || [];
            const presentPlayers = roster.filter(p => p.present);
            const fouledOutIds = new Set(liveGameStats.fouledOut || []);
            
            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
            presentPlayers.forEach(player => {
                const onCourt = liveGameStats.onCourt.includes(player.id);
                const isFouledOut = fouledOutIds.has(player.id);
                
                let borderColor = '#e0e0e0';
                let backgroundColor = 'white';
                let statusText = '';
                
                if (isFouledOut) {
                    borderColor = '#dc3545';
                    backgroundColor = '#ffebee';
                    statusText = '<span style="color: #dc3545; margin-left: 10px; font-weight: bold;">âš ï¸ Fouled Out</span>';
                } else if (onCourt) {
                    borderColor = '#28a745';
                    backgroundColor = '#e8f5e9';
                    statusText = '<span style="color: #28a745; margin-left: 10px;">â— On Court</span>';
                }
                
                html += `<div style="padding: 15px; border: 2px solid ${borderColor}; border-radius: 8px; background: ${backgroundColor};">
                    <strong>#${player.number || player.id} ${escapeHtml(player.name)}</strong>
                    ${statusText}
                </div>`;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }

        async function autoSaveGame() {
            if (!currentViewingGameId || !currentViewingGame) return;
            
            // Update game metadata with live stats
            currentViewingGame.metadata.liveStats = {
                ...liveGameStats,
                currentPeriod: currentPeriod
            };
            
            // Also update traditional stats format for compatibility
            const aggregatedStats = {};
            const roster = currentViewingGame.metadata.roster || [];
            roster.forEach(player => {
                let totalStats = {
                    points: 0, assists: 0, rebounds: 0, blocks: 0, steals: 0, turnovers: 0
                };
                
                Object.values(liveGameStats.periods).forEach(periodStats => {
                    const playerStats = periodStats.playerStats[player.id] || {};
                    totalStats.points += (playerStats.points || 0);
                    totalStats.assists += (playerStats.assists || 0);
                    totalStats.rebounds += (playerStats.rebounds || 0);
                    totalStats.blocks += (playerStats.blocks || 0);
                    totalStats.steals += (playerStats.steals || 0);
                    totalStats.turnovers += (playerStats.turnovers || 0);
                });
                
                if (Object.values(totalStats).some(v => v > 0)) {
                    aggregatedStats[player.id] = totalStats;
                }
            });
            
            currentViewingGame.metadata.playerStats = aggregatedStats;
            currentViewingGame.metadata.teamScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamPoints, 0);
            currentViewingGame.metadata.opponentScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.opponentPoints, 0);
            
            await StorageService.updateGame(currentViewingGameId, currentViewingGame);
        }

        function recordTeamTimeout() {
            const periodStats = liveGameStats.periods[currentPeriod];
            periodStats.teamTimeouts += 1;
            liveGameStats.teamStats.timeouts += 1;
            autoSaveGame();
        }

        // Assist Assignment Functions
        function openAssistAssignmentModal(scorerId, actionDescription) {
            const modal = document.getElementById('assist-assignment-modal');
            const roster = currentViewingGame.metadata.roster || [];
            const scorer = roster.find(p => p.id === scorerId);
            
            if (!scorer) return;

            // Update scorer header
            document.getElementById('assist-scorer-name').textContent = `${scorer.name}, #${scorer.number || scorerId}`;
            document.getElementById('assist-scorer-action').textContent = actionDescription;
            
            // Update team name
            const currentTeam = TeamService.getCurrentTeam();
            const assistTeamName = document.getElementById('assist-team-name');
            if (assistTeamName) {
                assistTeamName.textContent = currentTeam ? currentTeam.teamName : 'Scoring Team';
            }

            // Get players
            const presentPlayers = roster.filter(p => p.present);
            const onCourtIds = new Set(liveGameStats.onCourt);
            
            // Separate on-court and bench players, excluding the scorer
            const onCourtPlayers = presentPlayers.filter(p => onCourtIds.has(p.id) && p.id !== scorerId);
            const benchPlayers = presentPlayers.filter(p => !onCourtIds.has(p.id) && p.id !== scorerId);

            // Render on-court players
            const onCourtList = document.getElementById('assist-on-court-list');
            const onCourtTitle = document.getElementById('on-court-title');
            onCourtTitle.textContent = `On the Court (${onCourtPlayers.length})`;
            onCourtList.innerHTML = '';

            onCourtPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'assist-player-item on-court';
                item.innerHTML = `
                    <div class="assist-player-number">#${player.number || player.id}</div>
                    <div class="assist-player-name">${escapeHtml(player.name)}</div>
                `;
                item.onclick = () => selectAssistingPlayer(player.id);
                onCourtList.appendChild(item);
            });

            // Render bench players
            const benchList = document.getElementById('assist-bench-list');
            const benchTitle = document.getElementById('bench-title');
            benchTitle.textContent = `Bench (${benchPlayers.length})`;
            benchList.innerHTML = '';

            benchPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'assist-player-item';
                item.innerHTML = `
                    <div class="assist-player-number">#${player.number || player.id}</div>
                    <div class="assist-player-name">${escapeHtml(player.name)}</div>
                `;
                item.onclick = () => selectAssistingPlayer(player.id);
                benchList.appendChild(item);
            });

            modal.classList.add('show');
            // Scroll modal to top
            const modalDialog = modal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function selectAssistingPlayer(assistingPlayerId) {
            if (!pendingAssist) return;

            const periodStats = liveGameStats.periods[pendingAssist.period];
            const assistingPlayerStats = periodStats.playerStats[assistingPlayerId] || {
                points: 0, fouls: 0, fgMade: 0, fgAttempted: 0,
                fg3Made: 0, fg3Attempted: 0, ftMade: 0, ftAttempted: 0,
                rebounds: 0, assists: 0, steals: 0, blocks: 0, turnovers: 0
            };
            periodStats.playerStats[assistingPlayerId] = assistingPlayerStats;
            
            // Record assist for the assisting player
            assistingPlayerStats.assists += 1;
            
            // Get player info for play-by-play
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === assistingPlayerId);
            const playerName = player ? player.name : 'Unknown';
            const playerNumber = player ? player.number : '';
            
            // Add to play-by-play
            addPlayByPlayEvent({
                playerId: assistingPlayerId,
                playerName, playerNumber,
                statType: 'assist'
            });
            
            pendingAssist = null;
            closeAssistAssignment();
            renderOnCourtPlayers();
        }

        function recordNoAssist() {
            pendingAssist = null;
            closeAssistAssignment();
            renderOnCourtPlayers();
            autoSaveGame();
        }

        function assignAssistLater() {
            // Just close the modal, keep pendingAssist for later assignment
            // (For now, we'll just clear it - could implement "assign later" queue if needed)
            pendingAssist = null;
            closeAssistAssignment();
            renderOnCourtPlayers();
            autoSaveGame();
        }

        function closeAssistAssignment() {
            document.getElementById('assist-assignment-modal').classList.remove('show');
        }

        function closeAssistAssignmentIfOutside(event) {
            if (event.target.id === 'assist-assignment-modal') {
                closeAssistAssignment();
                // If closing without assigning, treat as "No Assist"
                if (pendingAssist) {
                    pendingAssist = null;
                    autoSaveGame();
                }
            }
        }

        // Free Throw Assignment Functions
        function openFreeThrowAssignmentModal(playerId) {
            const modal = document.getElementById('freethrow-assignment-modal');
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === playerId);
            
            if (!player) return;

            // Update player header
            document.getElementById('freethrow-player-name').textContent = `${player.name}, #${player.number || playerId}`;
            
            modal.classList.add('show');
            // Scroll modal to top
            const modalDialog = modal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function selectFreeThrowCount(count) {
            if (!pendingFreeThrow) return;
            
            pendingFreeThrow.count = count;
            
            // Close count selection modal
            document.getElementById('freethrow-assignment-modal').classList.remove('show');
            
            // Open shots modal
            openFreeThrowShotsModal();
        }

        function openFreeThrowShotsModal() {
            const modal = document.getElementById('freethrow-shots-modal');
            const container = document.getElementById('freethrow-shots-container');
            const playerNameEl = document.getElementById('freethrow-shots-player-name');
            const countDisplayEl = document.getElementById('freethrow-shots-count-display');
            
            if (!pendingFreeThrow) return;
            
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === pendingFreeThrow.playerId);
            
            if (!player) return;
            
            playerNameEl.textContent = `${player.name}, #${player.number || pendingFreeThrow.playerId}`;
            
            const count = pendingFreeThrow.count;
            const countLabels = {
                '1and1': '1:1 Free Throw',
                '1': '1 Free Throw',
                '2': '2 Free Throws',
                '3': '3 Free Throws'
            };
            countDisplayEl.textContent = countLabels[count] || 'Free Throw';
            
            container.innerHTML = '';
            pendingFreeThrow.shots = [];
            
            if (count === '1and1') {
                // Handle 1:1 - show first shot
                renderFreeThrowShot(container, 1, true);
            } else {
                // Handle 1, 2, or 3 shots
                const numShots = parseInt(count);
                for (let i = 1; i <= numShots; i++) {
                    renderFreeThrowShot(container, i, false);
                }
            }
            
            modal.classList.add('show');
            // Scroll modal to top
            const modalDialog = modal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function renderFreeThrowShot(container, shotNumber, isOneAndOne) {
            const row = document.createElement('div');
            row.className = 'freethrow-shot-row';
            row.dataset.shotNumber = shotNumber;
            
            const label = document.createElement('div');
            label.className = 'freethrow-shot-label';
            label.textContent = isOneAndOne && shotNumber === 1 ? 'First Shot:' : `Shot ${shotNumber}:`;
            
            const buttons = document.createElement('div');
            buttons.className = 'freethrow-shot-buttons';
            
            const missBtn = document.createElement('button');
            missBtn.className = 'freethrow-shot-btn miss';
            missBtn.textContent = 'Miss';
            missBtn.onclick = () => recordFreeThrowShot(shotNumber, false, isOneAndOne);
            
            const makeBtn = document.createElement('button');
            makeBtn.className = 'freethrow-shot-btn make';
            makeBtn.textContent = 'Make (+1)';
            makeBtn.onclick = () => recordFreeThrowShot(shotNumber, true, isOneAndOne);
            
            buttons.appendChild(missBtn);
            buttons.appendChild(makeBtn);
            
            row.appendChild(label);
            row.appendChild(buttons);
            container.appendChild(row);
        }

        function recordFreeThrowShot(shotNumber, made, isOneAndOne) {
            if (!pendingFreeThrow) return;
            
            // Record this shot
            pendingFreeThrow.shots.push({shotNumber, made});
            
            // Update button states
            const row = document.querySelector(`.freethrow-shot-row[data-shot-number="${shotNumber}"]`);
            if (row) {
                const missBtn = row.querySelector('.miss');
                const makeBtn = row.querySelector('.make');
                
                if (made) {
                    missBtn.classList.remove('selected');
                    makeBtn.classList.add('selected');
                } else {
                    makeBtn.classList.remove('selected');
                    missBtn.classList.add('selected');
                }
            }
            
            // Handle 1:1 logic
            if (isOneAndOne && shotNumber === 1) {
                if (!made) {
                    // First shot missed - record and return
                    finalizeFreeThrows();
                    return;
                } else {
                    // First shot made - show second shot
                    const container = document.getElementById('freethrow-shots-container');
                    renderFreeThrowShot(container, 2, true);
                }
            } else {
                // Check if all shots are recorded
                const count = pendingFreeThrow.count;
                const expectedShots = count === '1and1' ? 2 : parseInt(count);
                
                if (pendingFreeThrow.shots.length >= expectedShots) {
                    finalizeFreeThrows();
                }
            }
        }

        function finalizeFreeThrows() {
            if (!pendingFreeThrow) return;
            
            const periodStats = liveGameStats.periods[currentPeriod];
            const playerPeriodStats = periodStats.playerStats[pendingFreeThrow.playerId] || {
                points: 0, fouls: 0, fgMade: 0, fgAttempted: 0,
                fg3Made: 0, fg3Attempted: 0, ftMade: 0, ftAttempted: 0,
                rebounds: 0, assists: 0, steals: 0, blocks: 0, turnovers: 0
            };
            periodStats.playerStats[pendingFreeThrow.playerId] = playerPeriodStats;
            
            // Get player info for play-by-play
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === pendingFreeThrow.playerId);
            const playerName = player ? player.name : 'Unknown';
            const playerNumber = player ? player.number : '';
            
            // Record each shot
            let pointsScored = 0;
            pendingFreeThrow.shots.forEach(shot => {
                playerPeriodStats.ftAttempted += 1;
                if (shot.made) {
                    playerPeriodStats.ftMade += 1;
                    playerPeriodStats.points += 1;
                    pointsScored += 1;
                    periodStats.teamPoints += 1;
                    liveGameStats.teamStats.points += 1;
                    // Add to play-by-play (made)
                    addPlayByPlayEvent({
                        playerId: pendingFreeThrow.playerId,
                        playerName, playerNumber,
                        statType: 'freeThrow',
                        points: 1
                    });
                } else {
                    // Add to play-by-play (missed)
                    addPlayByPlayEvent({
                        playerId: pendingFreeThrow.playerId,
                        playerName, playerNumber,
                        statType: 'freeThrowMiss',
                        points: 0
                    });
                }
            });
            
            // Close modal
            closeFreeThrowShots();
            
            // Update UI
            updateScoreboard();
            renderOnCourtPlayers();
            
            // Clear pending
            pendingFreeThrow = null;
        }

        function goBackToFreeThrowCount() {
            document.getElementById('freethrow-shots-modal').classList.remove('show');
            const freeThrowModal = document.getElementById('freethrow-assignment-modal');
            freeThrowModal.classList.add('show');
            // Scroll modal to top
            const modalDialog = freeThrowModal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
        }

        function closeFreeThrowAssignment() {
            document.getElementById('freethrow-assignment-modal').classList.remove('show');
            pendingFreeThrow = null;
        }

        function closeFreeThrowAssignmentIfOutside(event) {
            if (event.target.id === 'freethrow-assignment-modal') {
                closeFreeThrowAssignment();
            }
        }

        function closeFreeThrowShots() {
            document.getElementById('freethrow-shots-modal').classList.remove('show');
        }

        function closeFreeThrowShotsIfOutside(event) {
            if (event.target.id === 'freethrow-shots-modal') {
                closeFreeThrowShots();
                // If closing without completing, cancel the free throw
                if (pendingFreeThrow) {
                    pendingFreeThrow = null;
                }
            }
        }

        function toggleHamburgerMenu() {
            const overlay = document.getElementById('hamburger-menu-overlay');
            overlay.classList.toggle('show');
        }

        function closeHamburgerMenu() {
            const overlay = document.getElementById('hamburger-menu-overlay');
            overlay.classList.remove('show');
        }

        function exitLiveStats() {
            // Show the exit game modal instead of system confirm
            document.getElementById('exit-game-modal').classList.add('show');
        }

        function closeExitGameModal() {
            document.getElementById('exit-game-modal').classList.remove('show');
        }

        async function exitGameWithSave() {
            closeExitGameModal();
            // Save current state before exiting
            await autoSaveGame();
            navigateTo('games-list-page');
        }

        async function exitGameWithoutSaving() {
            closeExitGameModal();
            // Delete the game without saving
            if (currentViewingGameId) {
                await StorageService.deleteGame(currentViewingGameId);
                currentViewingGame = null;
                currentViewingGameId = null;
            }
            navigateTo('games-list-page');
        }

        // ============================================================================
        // GENERIC CONFIRMATION MODAL SYSTEM
        // ============================================================================
        
        let confirmModalCallback = null;
        let confirmModalCancelCallback = null;

        function showConfirmModal(options) {
            const { title, message, submessage, confirmText, cancelText, confirmStyle, onConfirm, onCancel } = options;
            
            document.getElementById('confirm-modal-title').textContent = title || 'Confirm';
            document.getElementById('confirm-modal-message').textContent = message || '';
            document.getElementById('confirm-modal-submessage').textContent = submessage || '';
            document.getElementById('confirm-modal-submessage').style.display = submessage ? 'block' : 'none';
            
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            confirmBtn.textContent = confirmText || 'Confirm';
            
            // Reset button style and apply custom style if provided
            confirmBtn.className = 'modal-btn modal-btn-primary';
            if (confirmStyle === 'danger') {
                confirmBtn.style.background = '#dc3545';
            } else {
                confirmBtn.style.background = '';
            }
            
            const cancelBtn = document.getElementById('confirm-modal-cancel');
            cancelBtn.textContent = cancelText || 'Cancel';
            
            confirmModalCallback = onConfirm || null;
            confirmModalCancelCallback = onCancel || null;
            
            document.getElementById('confirm-modal').classList.add('show');
        }

        function closeConfirmModal() {
            document.getElementById('confirm-modal').classList.remove('show');
            if (confirmModalCancelCallback) {
                confirmModalCancelCallback();
            }
            confirmModalCallback = null;
            confirmModalCancelCallback = null;
        }

        function confirmModalAction() {
            document.getElementById('confirm-modal').classList.remove('show');
            if (confirmModalCallback) {
                confirmModalCallback();
            }
            confirmModalCallback = null;
            confirmModalCancelCallback = null;
        }

        // ============================================================================
        // FREE THROW MODAL
        // ============================================================================
        
        let pendingFreeThrowData = null;

        function showFreeThrowModal(playerName, playerId, periodStats) {
            document.getElementById('free-throw-player-name').textContent = playerName;
            pendingFreeThrowData = { playerId, periodStats };
            document.getElementById('free-throw-modal').classList.add('show');
        }

        function closeFreeThrowModal() {
            document.getElementById('free-throw-modal').classList.remove('show');
            pendingFreeThrowData = null;
        }

        function recordFreeThrowResult(made) {
            if (!pendingFreeThrowData) return;
            
            const { playerId, periodStats } = pendingFreeThrowData;
            const playerPeriodStats = periodStats.playerStats[playerId];
            
            // Get player info for play-by-play
            const roster = currentViewingGame.metadata.roster || [];
            const player = roster.find(p => p.id === playerId);
            const playerName = player ? player.name : 'Unknown';
            const playerNumber = player ? player.number : '';
            
            if (made) {
                playerPeriodStats.points += 1;
                playerPeriodStats.ftMade += 1;
                periodStats.teamPoints += 1;
                liveGameStats.teamStats.points += 1;
                // Add to play-by-play (made)
                addPlayByPlayEvent({
                    playerId, playerName, playerNumber,
                    statType: 'freeThrow',
                    points: 1
                });
            } else {
                // Add to play-by-play (missed)
                addPlayByPlayEvent({
                    playerId, playerName, playerNumber,
                    statType: 'freeThrowMiss',
                    points: 0
                });
            }
            playerPeriodStats.ftAttempted += 1;
            
            closeFreeThrowModal();
            updateScoreboard();
            renderOnCourtPlayers();
            autoSaveGame();
        }

        async function endGame() {
            document.getElementById('period-dropdown').classList.remove('show');
            
            // Calculate final scores
            const teamScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.teamPoints, 0);
            const opponentScore = Object.values(liveGameStats.periods).reduce((sum, p) => sum + p.opponentPoints, 0);
            const opponent = currentViewingGame?.metadata?.opponent || 'Opponent';
            
            // Populate the end game modal
            document.getElementById('end-game-opponent-display').textContent = `vs ${opponent}`;
            document.getElementById('end-game-team-score').textContent = teamScore;
            document.getElementById('end-game-opponent-score').textContent = opponentScore;
            
            // Show result
            const resultEl = document.getElementById('end-game-result');
            if (teamScore > opponentScore) {
                resultEl.textContent = 'ðŸŽ‰ Victory!';
                resultEl.style.color = '#28a745';
            } else if (teamScore < opponentScore) {
                resultEl.textContent = 'Defeat';
                resultEl.style.color = '#dc3545';
            } else {
                resultEl.textContent = 'Tie Game';
                resultEl.style.color = '#6c757d';
            }
            
            // Clear previous comments
            document.getElementById('end-game-comments').value = currentViewingGame?.metadata?.comments || '';
            
            // Show the modal
            document.getElementById('end-game-modal').classList.add('show');
        }

        function closeEndGameModal() {
            document.getElementById('end-game-modal').classList.remove('show');
        }

        function closeEndGameModalIfOutside(event) {
            if (event.target.id === 'end-game-modal') {
                closeEndGameModal();
            }
        }

        async function saveAndEndGame() {
            closeEndGameModal();
            
            // Get the comments
            const comments = document.getElementById('end-game-comments').value.trim();
            
            // Mark game as ended and save comments
            if (currentViewingGame && currentViewingGame.metadata) {
                currentViewingGame.metadata.gameEnded = true;
                currentViewingGame.metadata.endedAt = new Date().toISOString();
                currentViewingGame.metadata.comments = comments;
                
                // Save the final state
                await autoSaveGame();
            }

            // Clear live game state
            currentViewingGame = null;
            currentViewingGameId = null;

            // Navigate to games list page
            navigateTo('games-list-page');
        }

        function renderGameStats() {
            if (!currentViewingGame) return '';

            const stats = currentViewingGame.metadata.playerStats;
            if (!stats || Object.keys(stats).length === 0) {
                return '';
            }

            // Get players who have stats
            const savedRoster = currentViewingGame.metadata.roster || [];
            const playersWithStats = savedRoster
                .filter(p => p.present && stats[p.id])
                .map(savedPlayer => {
                    const currentPlayer = players.find(p => p.id === savedPlayer.id);
                    return {
                        ...savedPlayer,
                        name: currentPlayer ? currentPlayer.name : savedPlayer.name,
                        stats: stats[savedPlayer.id]
                    };
                });

            const getViewStatValue = (player, key) => {
                if (key === 'name') return player.name;
                return player.stats[key] || 0;
            };

            const sortedPlayers = playersWithStats.sort((a, b) => {
                const aVal = getViewStatValue(a, viewGameStatsSort.key);
                const bVal = getViewStatValue(b, viewGameStatsSort.key);
                if (viewGameStatsSort.key === 'name') {
                    return viewGameStatsSort.dir === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                }
                return viewGameStatsSort.dir === 'asc' ? aVal - bVal : bVal - aVal;
            });

            if (playersWithStats.length === 0) return '';

            let statsHtml = `
                <div class="game-info-row" style="flex-direction: column; align-items: flex-start; padding-top: 15px; border-top: 2px solid #e0e0e0;">
                    <span class="game-info-label" style="margin-bottom: 15px;">Player Statistics:</span>
                    <div style="width: 100%; overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead>
                                <tr style="background: #004E89; color: white;">
                                    <th class="sortable-header" onclick="setViewGameStatsSort('name')" style="padding: 8px; text-align: left;">Player <span id="view-stats-sort-name"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('points')" style="padding: 8px; text-align: center;">PTS <span id="view-stats-sort-pts"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('assists')" style="padding: 8px; text-align: center;">AST <span id="view-stats-sort-ast"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('rebounds')" style="padding: 8px; text-align: center;">REB <span id="view-stats-sort-reb"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('blocks')" style="padding: 8px; text-align: center;">BLK <span id="view-stats-sort-blk"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('steals')" style="padding: 8px; text-align: center;">STL <span id="view-stats-sort-stl"></span></th>
                                    <th class="sortable-header" onclick="setViewGameStatsSort('turnovers')" style="padding: 8px; text-align: center;">TO <span id="view-stats-sort-to"></span></th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            const maxStats = sortedPlayers.reduce((acc, player) => {
                acc.points = Math.max(acc.points, player.stats.points || 0);
                acc.assists = Math.max(acc.assists, player.stats.assists || 0);
                acc.rebounds = Math.max(acc.rebounds, player.stats.rebounds || 0);
                acc.blocks = Math.max(acc.blocks, player.stats.blocks || 0);
                acc.steals = Math.max(acc.steals, player.stats.steals || 0);
                acc.turnovers = Math.max(acc.turnovers, player.stats.turnovers || 0);
                return acc;
            }, { points: 0, assists: 0, rebounds: 0, blocks: 0, steals: 0, turnovers: 0 });

            const leaderClass = (value, maxValue, isTurnover = false) => {
                if (maxValue > 0 && value === maxValue) {
                    return isTurnover ? 'stat-leader-red' : 'stat-leader-green';
                }
                return '';
            };

            // Calculate totals
            let totalPoints = 0;
            let totalAssists = 0;
            let totalRebounds = 0;
            let totalBlocks = 0;
            let totalSteals = 0;
            let totalTurnovers = 0;

            sortedPlayers.forEach(player => {
                const s = player.stats;
                totalPoints += s.points || 0;
                totalAssists += s.assists || 0;
                totalRebounds += s.rebounds || 0;
                totalBlocks += s.blocks || 0;
                totalSteals += s.steals || 0;
                totalTurnovers += s.turnovers || 0;

                statsHtml += `
                    <tr style="border-bottom: 1px solid #e0e0e0;">
                        <td style="padding: 8px; font-weight: 500;">${escapeHtml(player.name)}${player.star ? ' â­' : ''}</td>
                        <td class="${leaderClass(s.points || 0, maxStats.points)}" style="padding: 8px; text-align: center; font-weight: bold; color: #004E89;">${s.points || 0}</td>
                        <td class="${leaderClass(s.assists || 0, maxStats.assists)}" style="padding: 8px; text-align: center;">${s.assists || 0}</td>
                        <td class="${leaderClass(s.rebounds || 0, maxStats.rebounds)}" style="padding: 8px; text-align: center;">${s.rebounds || 0}</td>
                        <td class="${leaderClass(s.blocks || 0, maxStats.blocks)}" style="padding: 8px; text-align: center;">${s.blocks || 0}</td>
                        <td class="${leaderClass(s.steals || 0, maxStats.steals)}" style="padding: 8px; text-align: center;">${s.steals || 0}</td>
                        <td class="${leaderClass(s.turnovers || 0, maxStats.turnovers, true)}" style="padding: 8px; text-align: center; color: ${(s.turnovers || 0) > 0 ? '#dc3545' : '#666'};">
                            ${s.turnovers || 0}
                        </td>
                    </tr>
                `;
            });

            // Add totals row
            statsHtml += `
                    <tr style="background: #f0f0f0; font-weight: bold; border-top: 2px solid #004E89;">
                        <td style="padding: 10px; font-weight: bold; color: #004E89;">TOTALS</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: #004E89; font-size: 1.1rem;">${totalPoints}</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: #004E89;">${totalAssists}</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: #004E89;">${totalRebounds}</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: #004E89;">${totalBlocks}</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: #004E89;">${totalSteals}</td>
                        <td style="padding: 10px; text-align: center; font-weight: bold; color: ${totalTurnovers > 0 ? '#dc3545' : '#004E89'};">
                            ${totalTurnovers}
                        </td>
                    </tr>
            `;

            statsHtml += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            updateViewGameStatsSortIndicators();
            return statsHtml;
        }

        function openEditGameInfoModal() {
            if (!currentViewingGame) return;

            const game = currentViewingGame;
            const today = game.metadata.gameDate || new Date().toISOString().split('T')[0];

            document.getElementById('edit-opponent-input').value = game.metadata.opponent || '';
            document.getElementById('edit-game-date-input').value = today;
            updateEditGameDateDisplay(today);
            document.getElementById('edit-team-score-input').value = game.metadata.teamScore !== null && game.metadata.teamScore !== undefined ? game.metadata.teamScore : '';
            document.getElementById('edit-opponent-score-input').value = game.metadata.opponentScore !== null && game.metadata.opponentScore !== undefined ? game.metadata.opponentScore : '';
            document.getElementById('edit-game-comments-input').value = game.metadata.comments || '';

            const editGameModal = document.getElementById('edit-game-modal');
            editGameModal.classList.add('show');
            // Scroll modal to top
            const modalDialog = editGameModal.querySelector('.modal-dialog');
            if (modalDialog) {
                modalDialog.scrollTop = 0;
            }
            document.getElementById('edit-opponent-input').focus();
        }

        function updateEditGameDateDisplay(dateValue) {
            const display = document.getElementById('edit-game-date-display');
            if (!display) return;
            display.textContent = dateValue ? `Formatted: ${formatDate(dateValue)}` : '';
        }

        async function handleEditGameInfo(event) {
            event.preventDefault();

            const opponent = document.getElementById('edit-opponent-input').value.trim();
            const gameDate = document.getElementById('edit-game-date-input').value;
            const teamScore = document.getElementById('edit-team-score-input').value ? parseInt(document.getElementById('edit-team-score-input').value) : null;
            const opponentScore = document.getElementById('edit-opponent-score-input').value ? parseInt(document.getElementById('edit-opponent-score-input').value) : null;
            const comments = document.getElementById('edit-game-comments-input').value.trim();

            if (!opponent) {
                showError('Please enter an opponent name.');
                return;
            }

            if (!currentViewingGame || !currentViewingGameId) {
                showError('No game to update.');
                return;
            }

            // Update current viewing game metadata
            currentViewingGame.metadata.opponent = opponent;
            currentViewingGame.metadata.gameDate = gameDate;
            currentViewingGame.metadata.teamScore = teamScore;
            currentViewingGame.metadata.opponentScore = opponentScore;
            currentViewingGame.metadata.comments = comments;
            currentViewingGame.name = `vs ${opponent} - ${gameDate}`;

            // Save updated game
            const result = await StorageService.updateGame(currentViewingGameId, currentViewingGame);

            if (result.success) {
                closeEditGameModal();
                showError('Game information updated!');
                setTimeout(() => {
                    const errorDiv = document.getElementById('error-message');
                    errorDiv.classList.remove('show');
                }, 1500);
                // Re-render the view to show updated info
                viewGame(currentViewingGameId);
            } else {
                showError(`Failed to update game: ${result.error || 'Unknown error'}`);
            }
        }

        async function saveEditedGame() {
            if (!currentViewingGame || !currentViewingGameId) {
                showError('No game to save.');
                return;
            }

            // Update lineup data in game
            currentViewingGame.lineup = currentLineupData.map(q => q.map(slot => slot ? {...slot} : null));

            // Merge new edits with saved edits - all edits become saved edits
            const savedEditedCells = currentViewingGame.metadata.savedEditedCells || {};
            const allEditedCells = {...savedEditedCells, ...viewGameEditedCells};
            currentViewingGame.metadata.savedEditedCells = allEditedCells;

            // Save updated game
            const result = await StorageService.updateGame(currentViewingGameId, currentViewingGame);

            if (result.success) {
                showError('Game updated successfully!');
                setTimeout(() => {
                    const errorDiv = document.getElementById('error-message');
                    errorDiv.classList.remove('show');
                    // Exit edit mode and refresh view
                    viewGameEditMode = false;
                    // Reset session edits (they're now saved)
                    viewGameEditedCells = {};
                    document.getElementById('view-game-edit-btn').style.display = 'block';
                    document.getElementById('view-game-actions').style.display = 'none';
                    viewGame(currentViewingGameId);
                }, 1500);
            } else {
                showError(`Failed to update game: ${result.error || 'Unknown error'}`);
            }
        }

        async function deleteGame(gameId) {
            showConfirmModal({
                title: 'Delete Game',
                message: 'Are you sure you want to delete this saved game?',
                submessage: 'This action cannot be undone.',
                confirmText: 'Delete',
                confirmStyle: 'danger',
                cancelText: 'Cancel',
                onConfirm: async () => {
                    const result = await StorageService.deleteGame(gameId);
                    
                    if (result.success) {
                        // If we're currently viewing this game, navigate away
                        if (currentViewingGameId === gameId) {
                            navigateTo('games-list-page');
                            currentViewingGameId = null;
                            currentViewingGame = null;
                        }
                        
                        // Refresh the games list and playtime history
                        await renderGamesList();
                        
                        // Refresh playtime history if we're on that page
                        const activePage = document.querySelector('.page.active');
                        if (activePage && activePage.id === 'playtime-history-page') {
                            await renderPlaytimeHistory();
                        }
                
                        // Show success message
                        const errorDiv = document.getElementById('error-message');
                        errorDiv.textContent = 'Game deleted successfully.';
                        errorDiv.style.color = '#28a745';
                        errorDiv.classList.add('show');
                        setTimeout(() => {
                            errorDiv.classList.remove('show');
                            errorDiv.style.color = ''; // Reset color
                        }, 2000);
                    } else {
                        showError(`Failed to delete game: ${result.error || 'Unknown error'}`);
                    }
                }
            });
        }

        async function deleteCurrentGame() {
            if (!currentViewingGameId) return;
            await deleteGame(currentViewingGameId);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date as Month/day/year (e.g., "1/15/2024" or "12/3/2024")
        function formatDate(dateString) {
            if (!dateString || dateString === 'Unknown') {
                return 'Unknown';
            }

            // Parse the date string (could be YYYY-MM-DD, ISO datetime, or already formatted)
            let date;
            if (dateString.includes('-')) {
                // ISO format YYYY-MM-DD or ISO datetime - try parsing directly
                date = new Date(dateString);
                // If it's just a date (YYYY-MM-DD), add time component for proper parsing
                if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    date = new Date(dateString + 'T00:00:00');
                }
            } else {
                date = new Date(dateString);
            }

            if (isNaN(date.getTime())) {
                return dateString; // Return original if can't parse
            }

            // Format as MM/DD/YYYY (zero-padded)
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();
            return `${month}/${day}/${year}`;
        }

        function togglePlaytimeRow(row, playerId) {
            const detailRow = document.querySelector(`tr.playtime-detail-row[data-player-id="${playerId}"]`);
            if (!detailRow) return;

            const isExpanded = row.classList.contains('expanded');
            
            if (isExpanded) {
                row.classList.remove('expanded');
                detailRow.classList.remove('show');
            } else {
                row.classList.add('expanded');
                detailRow.classList.add('show');
            }
        }

        function toggleStatsHistoryRow(row, playerId) {
            const detailRow = document.querySelector(`tr.stats-history-detail-row[data-player-id="${playerId}"]`);
            if (!detailRow) return;

            const isExpanded = row.classList.contains('expanded');

            if (isExpanded) {
                row.classList.remove('expanded');
                detailRow.classList.remove('show');
            } else {
                row.classList.add('expanded');
                detailRow.classList.add('show');
            }
        }

        async function openGameStatsEditor(gameId) {
            if (!gameId) return;
            setStatsReturnPage('history');
            await viewGame(gameId);
            openEditStatsModal();
        }

        let statsViewMode = 'total';
        let lastStatsGamesCache = [];
        let lastPlaytimeGamesCache = [];
        let playtimeSort = { key: 'name', dir: 'asc' };
        let statsSort = { key: 'points', dir: 'desc' };
        let statsReturnPage = 'view-game';
        let saveMode = 'lineup';
        let currentEditingGameId = null;
        let forceUpdateGame = false;
        let viewGameStatsSort = { key: 'points', dir: 'desc' };

        function setStatsViewMode(mode) {
            statsViewMode = mode;
            const totalBtn = document.getElementById('stats-view-total-btn');
            const perGameBtn = document.getElementById('stats-view-per-game-btn');
            if (totalBtn && perGameBtn) {
                if (mode === 'per-game') {
                    totalBtn.className = 'modal-btn modal-btn-secondary';
                    perGameBtn.className = 'modal-btn modal-btn-primary';
                } else {
                    totalBtn.className = 'modal-btn modal-btn-primary';
                    perGameBtn.className = 'modal-btn modal-btn-secondary';
                }
            }
            if (lastStatsGamesCache.length > 0) {
                renderStatsHistory(lastStatsGamesCache);
            }
        }

        function setStatsReturnPage(pageId) {
            statsReturnPage = pageId;
        }

        function setStatsSort(key) {
            if (statsSort.key === key) {
                statsSort.dir = statsSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                statsSort.key = key;
                statsSort.dir = key === 'name' ? 'asc' : 'desc';
            }
            if (lastStatsGamesCache.length > 0) {
                renderStatsHistory(lastStatsGamesCache);
            }
        }

        function setPlaytimeSort(key) {
            if (playtimeSort.key === key) {
                playtimeSort.dir = playtimeSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                playtimeSort.key = key;
                playtimeSort.dir = key === 'name' ? 'asc' : 'desc';
            }
            if (lastPlaytimeGamesCache.length > 0) {
                renderPlaytimeHistoryFromCache();
            }
        }

        function renderPlaytimeHistoryFromCache() {
            if (lastPlaytimeGamesCache.length === 0) return;
            renderPlaytimeHistory(lastPlaytimeGamesCache);
        }

        function updateStatsSortIndicators() {
            const map = {
                name: 'stats-sort-name',
                gamesPlayed: 'stats-sort-gp',
                points: 'stats-sort-pts',
                assists: 'stats-sort-ast',
                rebounds: 'stats-sort-reb',
                blocks: 'stats-sort-blk',
                steals: 'stats-sort-stl',
                turnovers: 'stats-sort-to'
            };
            Object.values(map).forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '';
            });
            const activeId = map[statsSort.key];
            const activeEl = document.getElementById(activeId);
            if (activeEl) activeEl.textContent = statsSort.dir === 'asc' ? 'â–²' : 'â–¼';
        }

        function updatePlaytimeSortIndicators() {
            const map = {
                name: 'playtime-sort-name',
                totalQuarters: 'playtime-sort-total',
                gamesPlayed: 'playtime-sort-played',
                gamesAbsent: 'playtime-sort-absent',
                avgQuarters: 'playtime-sort-avg'
            };
            Object.values(map).forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '';
            });
            const activeId = map[playtimeSort.key];
            const activeEl = document.getElementById(activeId);
            if (activeEl) activeEl.textContent = playtimeSort.dir === 'asc' ? 'â–²' : 'â–¼';
        }

        function setViewGameStatsSort(key) {
            if (viewGameStatsSort.key === key) {
                viewGameStatsSort.dir = viewGameStatsSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                viewGameStatsSort.key = key;
                viewGameStatsSort.dir = key === 'name' ? 'asc' : 'desc';
            }
            // Re-render to apply sorting and leader highlighting
            const metaDiv = document.getElementById('view-game-meta');
            if (metaDiv && currentViewingGame) {
                viewGame(currentViewingGameId);
            }
        }

        function updateViewGameStatsSortIndicators() {
            const map = {
                name: 'view-stats-sort-name',
                points: 'view-stats-sort-pts',
                assists: 'view-stats-sort-ast',
                rebounds: 'view-stats-sort-reb',
                blocks: 'view-stats-sort-blk',
                steals: 'view-stats-sort-stl',
                turnovers: 'view-stats-sort-to'
            };
            Object.values(map).forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '';
            });
            const activeId = map[viewGameStatsSort.key];
            const activeEl = document.getElementById(activeId);
            if (activeEl) activeEl.textContent = viewGameStatsSort.dir === 'asc' ? 'â–²' : 'â–¼';
        }

        // ============================================================================
        // PLAYTIME HISTORY
        // ============================================================================

        async function renderPlaytimeHistory(gamesOverride = null) {
            // Check current team sport
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                const container = document.getElementById('playtime-history-container');
                if (container) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Please select a team first.</p>';
                }
                return;
            }
            
            // Show placeholder for Lacrosse
            if (currentTeam.sport && currentTeam.sport.toLowerCase() === 'lacrosse') {
                const container = document.getElementById('playtime-history-container');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: #666;">
                            <div style="font-size: 4rem; margin-bottom: 20px;">ðŸ¥</div>
                            <h3 style="color: #004E89; margin-bottom: 10px;">Lacrosse History Coming Soon</h3>
                            <p>Lacrosse playtime history is under development.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Continue with normal basketball history
            const tbody = document.getElementById('playtime-history-tbody');
            tbody.innerHTML = '';
            const statsTbody = document.getElementById('stats-history-tbody');
            if (statsTbody) statsTbody.innerHTML = '';

            // Load all saved games
            const games = gamesOverride || await StorageService.listGames();
            lastPlaytimeGamesCache = games;

            // Initialize stats for all current players
            const playerStats = {};
            const playerGameDetails = {}; // Store game-by-game details
            players.forEach(player => {
                playerStats[player.id] = {
                    name: player.name,
                    star: player.star,
                    totalQuarters: 0,
                    gamesPlayed: 0,
                    gamesAbsent: 0
                };
                playerGameDetails[player.id] = [];
            });

            // Process each game
            games.forEach(game => {
                if (!game.lineup || !game.metadata || !game.metadata.roster) {
                    return; // Skip invalid games
                }

                const gameRoster = game.metadata.roster || [];
                const presentPlayerIds = new Set(gameRoster.filter(p => p.present).map(p => String(p.id)));
                const absentPlayerIds = new Set(gameRoster.filter(p => !p.present).map(p => String(p.id)));
                const allPlayerIdsInGame = new Set(gameRoster.map(p => String(p.id)));

                // Count quarters for each player in this game
                const playerQuartersInGame = {};
                gameRoster.forEach(p => {
                    playerQuartersInGame[String(p.id)] = 0;
                });

                // Track positions per quarter for each player
                const playerPositionsByQuarter = {};
                gameRoster.forEach(p => {
                    playerPositionsByQuarter[String(p.id)] = {q1: null, q2: null, q3: null, q4: null, total: 0};
                });

                // Count quarters played and track positions
                for (let q = 0; q < 4; q++) {
                    if (game.lineup[q]) {
                        game.lineup[q].forEach(slot => {
                            if (slot && slot.playerId) {
                                const playerId = String(slot.playerId);
                                if (!playerQuartersInGame[playerId]) {
                                    playerQuartersInGame[playerId] = 0;
                                }
                                playerQuartersInGame[playerId]++;
                                
                                // Track position for this quarter
                                const quarterKey = ['q1', 'q2', 'q3', 'q4'][q];
                                if (playerPositionsByQuarter[playerId]) {
                                    playerPositionsByQuarter[playerId][quarterKey] = slot.position;
                                    playerPositionsByQuarter[playerId].total++;
                                }
                            }
                        });
                    }
                }

                // Update stats for players who were on the roster for this game
                allPlayerIdsInGame.forEach(playerId => {
                    const playerIdNum = parseInt(playerId);
                    if (playerStats[playerIdNum]) {
                        const quartersPlayed = playerQuartersInGame[playerId] || 0;
                        playerStats[playerIdNum].totalQuarters += quartersPlayed;
                        
                        if (presentPlayerIds.has(playerId)) {
                            playerStats[playerIdNum].gamesPlayed++;
                            
                            // Store game details for this player
                            playerGameDetails[playerIdNum].push({
                                opponent: game.metadata.opponent || 'Unknown',
                                date: game.metadata.gameDate || 'Unknown',
                                quarters: playerPositionsByQuarter[playerId] || {q1: null, q2: null, q3: null, q4: null, total: 0}
                            });
                        } else if (absentPlayerIds.has(playerId)) {
                            playerStats[playerIdNum].gamesAbsent++;
                        }
                    }
                });
            });

            // Create table rows
            const getPlaytimeValue = (stat) => {
                if (playtimeSort.key === 'name') return stat.name;
                if (playtimeSort.key === 'avgQuarters') {
                    return stat.gamesPlayed > 0 ? (stat.totalQuarters / stat.gamesPlayed) : 0;
                }
                return stat[playtimeSort.key] || 0;
            };

            const sortedPlayers = Object.values(playerStats).sort((a, b) => {
                const aVal = getPlaytimeValue(a);
                const bVal = getPlaytimeValue(b);
                if (playtimeSort.key === 'name') {
                    return playtimeSort.dir === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                }
                return playtimeSort.dir === 'asc' ? aVal - bVal : bVal - aVal;
            });

            sortedPlayers.forEach((stat, index) => {
                // Find player ID from stat - match by name and star status
                const matchingPlayer = players.find(p => p.name === stat.name && p.star === stat.star);
                const playerId = matchingPlayer ? matchingPlayer.id : null;
                const gameDetails = playerId ? (playerGameDetails[playerId] || []) : [];
                
                // Main row
                const row = document.createElement('tr');
                row.className = 'playtime-row';
                row.dataset.playerId = playerId || index;
                
                // Player name with accordion icon
                const nameCell = document.createElement('td');
                nameCell.className = 'player-name-col';
                nameCell.innerHTML = `<span class="accordion-icon">â–¶</span>${stat.name}${stat.star ? ' â­' : ''}`;
                row.appendChild(nameCell);

                // Total quarters
                const totalQuartersCell = document.createElement('td');
                totalQuartersCell.textContent = stat.totalQuarters;
                totalQuartersCell.style.textAlign = 'center';
                row.appendChild(totalQuartersCell);

                // Games played
                const gamesPlayedCell = document.createElement('td');
                gamesPlayedCell.textContent = stat.gamesPlayed;
                gamesPlayedCell.style.textAlign = 'center';
                row.appendChild(gamesPlayedCell);

                // Games absent
                const gamesAbsentCell = document.createElement('td');
                gamesAbsentCell.textContent = stat.gamesAbsent;
                gamesAbsentCell.style.textAlign = 'center';
                row.appendChild(gamesAbsentCell);

                // Average quarters per game
                const avgCell = document.createElement('td');
                if (stat.gamesPlayed > 0) {
                    const avg = (stat.totalQuarters / stat.gamesPlayed).toFixed(2);
                    avgCell.textContent = avg;
                } else {
                    avgCell.textContent = 'â€”';
                }
                avgCell.style.textAlign = 'center';
                avgCell.className = 'total-cell';
                row.appendChild(avgCell);

                // Make row clickable
                row.addEventListener('click', () => togglePlaytimeRow(row, playerId || index));

                tbody.appendChild(row);

                // Detail row
                const detailRow = document.createElement('tr');
                detailRow.className = 'playtime-detail-row';
                detailRow.dataset.playerId = playerId || index;
                
                const detailCell = document.createElement('td');
                detailCell.colSpan = 5;
                detailCell.className = 'playtime-detail-cell';
                
                if (gameDetails.length > 0) {
                    const detailTable = document.createElement('table');
                    detailTable.style.width = '100%';
                    detailTable.style.borderCollapse = 'collapse';
                    
                    // Header row
                    const headerRow = document.createElement('tr');
                    headerRow.style.backgroundColor = '#e0e0e0';
                    headerRow.style.fontWeight = 'bold';
                    ['Opponent', 'Date', 'Q1', 'Q2', 'Q3', 'Q4', 'Total'].forEach(text => {
                        const th = document.createElement('td');
                        th.textContent = text;
                        th.style.padding = '8px';
                        th.style.textAlign = text === 'Opponent' || text === 'Date' ? 'left' : 'center';
                        headerRow.appendChild(th);
                    });
                    detailTable.appendChild(headerRow);
                    
                    // Game rows
                    gameDetails.forEach(game => {
                        const gameRow = document.createElement('tr');
                        gameRow.style.borderBottom = '1px solid #ddd';
                        
                        // Opponent
                        const oppCell = document.createElement('td');
                        oppCell.textContent = game.opponent;
                        oppCell.style.padding = '8px';
                        gameRow.appendChild(oppCell);
                        
                        // Date
                        const dateCell = document.createElement('td');
                        dateCell.textContent = formatDate(game.date);
                        dateCell.style.padding = '8px';
                        gameRow.appendChild(dateCell);
                        
                        // Quarters
                        for (let q = 1; q <= 4; q++) {
                            const qCell = document.createElement('td');
                            const quarterKey = `q${q}`;
                            const position = game.quarters[quarterKey];
                            if (position) {
                                qCell.textContent = position;
                                qCell.className = 'position-cell';
                                qCell.style.padding = '8px';
                                qCell.style.textAlign = 'center';
                            } else {
                                qCell.textContent = 'â€”';
                                qCell.className = 'sit-cell';
                                qCell.style.padding = '8px';
                                qCell.style.textAlign = 'center';
                            }
                            gameRow.appendChild(qCell);
                        }
                        
                        // Total for this game
                        const totalCell = document.createElement('td');
                        totalCell.textContent = game.quarters.total || 0;
                        totalCell.className = 'total-cell';
                        totalCell.style.padding = '8px';
                        totalCell.style.textAlign = 'center';
                        gameRow.appendChild(totalCell);
                        
                        detailTable.appendChild(gameRow);
                    });
                    
                    detailCell.appendChild(detailTable);
                } else {
                    detailCell.textContent = 'No games played yet.';
                    detailCell.style.padding = '20px';
                    detailCell.style.color = '#666';
                }
                
                detailRow.appendChild(detailCell);
                tbody.appendChild(detailRow);
            });

            // Show message if no games
            if (games.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 40px; color: #666;">
                            No games saved yet. Start a game and save it to see playtime statistics.
                        </td>
                    </tr>
                `;
                if (statsTbody) {
                    statsTbody.innerHTML = `
                        <tr>
                            <td colspan="8" style="text-align: center; padding: 40px; color: #666;">
                                No games saved yet. Start a game and save it to see stats history.
                            </td>
                        </tr>
                    `;
                }
                return;
            }

            updatePlaytimeSortIndicators();
            // Render aggregated stats history table below
            lastStatsGamesCache = games;
            renderStatsHistory(games);
        }

        function renderStatsHistory(games) {
            const tbody = document.getElementById('stats-history-tbody');
            if (!tbody) return;
            tbody.innerHTML = '';

            // Initialize stats for all current players
            const statsTotals = {};
            const statsDetails = {};
            const statsGamesPlayedCounts = {};
            players.forEach(player => {
                statsTotals[player.id] = {
                    id: player.id,
                    name: player.name,
                    star: player.star,
                    points: 0,
                    assists: 0,
                    rebounds: 0,
                    blocks: 0,
                    steals: 0,
                    turnovers: 0
                };
                statsDetails[player.id] = [];
                statsGamesPlayedCounts[player.id] = 0;
            });

            // Aggregate stats across games
            games.forEach(game => {
                if (!game.metadata) return;

                const gameStats = game.metadata.playerStats || {};
                const gameRoster = game.metadata.roster || [];
                const gameDate = game.metadata.gameDate || game.metadata.savedAt;
                const opponent = game.metadata.opponent || 'Unknown';
                const hasLineup = Array.isArray(game.lineup) && game.lineup.length > 0;
                const playedMap = getPlayedMapForGame(game);
                const statsPlayedMap = hasLineup ? {} : (game.metadata.statsPlayed || {});

                const ensurePlayer = (pid, name, star) => {
                    if (!statsTotals[pid]) {
                        statsTotals[pid] = {
                            id: pid,
                            name: name || `Player ${pid}`,
                            star: !!star,
                            points: 0,
                            assists: 0,
                            rebounds: 0,
                            blocks: 0,
                            steals: 0,
                            turnovers: 0
                        };
                        statsDetails[pid] = [];
                        statsGamesPlayedCounts[pid] = 0;
                    }
                };

                // Track games played based on lineup (plus overrides)
                gameRoster.forEach(player => {
                    const pid = player.id;
                    ensurePlayer(pid, player.name, player.star);
                    const lineupPlayed = (playedMap[String(pid)] || 0) > 0;
                    const didPlay = lineupPlayed || !!statsPlayedMap[pid];
                    if (didPlay) {
                        statsGamesPlayedCounts[pid] += 1;
                    }
                });

                // Add stats totals and details
                Object.keys(gameStats).forEach(playerId => {
                    const pid = parseInt(playerId, 10);
                    const stats = gameStats[playerId];
                    const rosterPlayer = gameRoster.find(p => p.id === pid);
                    ensurePlayer(pid, rosterPlayer ? rosterPlayer.name : `Player ${playerId}`, rosterPlayer ? rosterPlayer.star : false);

                    statsTotals[pid].points += stats.points || 0;
                    statsTotals[pid].assists += stats.assists || 0;
                    statsTotals[pid].rebounds += stats.rebounds || 0;
                    statsTotals[pid].blocks += stats.blocks || 0;
                    statsTotals[pid].steals += stats.steals || 0;
                    statsTotals[pid].turnovers += stats.turnovers || 0;
                });

                // Add detail rows for all roster players (show DNP games even with zero stats)
                gameRoster.forEach(player => {
                    const pid = player.id;
                    ensurePlayer(pid, player.name, player.star);
                    const lineupPlayed = (playedMap[String(pid)] || 0) > 0;
                    const didPlay = lineupPlayed || !!statsPlayedMap[pid];
                    const stats = gameStats[pid] || {
                        points: 0,
                        assists: 0,
                        rebounds: 0,
                        blocks: 0,
                        steals: 0,
                        turnovers: 0
                    };
                    statsDetails[pid].push({
                        gameId: game.id,
                        opponent: opponent,
                        date: gameDate,
                        didPlay: didPlay,
                        lineupPlayed: lineupPlayed,
                        stats: {
                            points: stats.points || 0,
                            assists: stats.assists || 0,
                            rebounds: stats.rebounds || 0,
                            blocks: stats.blocks || 0,
                            steals: stats.steals || 0,
                            turnovers: stats.turnovers || 0
                        }
                    });
                });
            });

            const getGamesPlayed = (playerId) => {
                return statsGamesPlayedCounts[playerId] || 0;
            };

            const getStatValue = (stat, gamesPlayed, key) => {
                if (statsViewMode === 'per-game') {
                    return gamesPlayed > 0 ? (stat[key] / gamesPlayed) : 0;
                }
                return stat[key];
            };

            const sortedPlayers = Object.values(statsTotals).sort((a, b) => {
                const aGames = getGamesPlayed(a.id);
                const bGames = getGamesPlayed(b.id);
                const aVal = statsSort.key === 'name'
                    ? a.name
                    : statsSort.key === 'gamesPlayed'
                        ? aGames
                        : getStatValue(a, aGames, statsSort.key);
                const bVal = statsSort.key === 'name'
                    ? b.name
                    : statsSort.key === 'gamesPlayed'
                        ? bGames
                        : getStatValue(b, bGames, statsSort.key);

                if (statsSort.key === 'name') {
                    return statsSort.dir === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                }
                return statsSort.dir === 'asc' ? aVal - bVal : bVal - aVal;
            });

            const maxStats = sortedPlayers.reduce((acc, stat) => {
                const gamesPlayed = getGamesPlayed(stat.id);
                acc.points = Math.max(acc.points, getStatValue(stat, gamesPlayed, 'points'));
                acc.assists = Math.max(acc.assists, getStatValue(stat, gamesPlayed, 'assists'));
                acc.rebounds = Math.max(acc.rebounds, getStatValue(stat, gamesPlayed, 'rebounds'));
                acc.blocks = Math.max(acc.blocks, getStatValue(stat, gamesPlayed, 'blocks'));
                acc.steals = Math.max(acc.steals, getStatValue(stat, gamesPlayed, 'steals'));
                acc.turnovers = Math.max(acc.turnovers, getStatValue(stat, gamesPlayed, 'turnovers'));
                return acc;
            }, { points: 0, assists: 0, rebounds: 0, blocks: 0, steals: 0, turnovers: 0 });

            const applyLeaderClass = (cell, value, maxValue, isTurnover = false) => {
                if (maxValue > 0 && value === maxValue) {
                    cell.classList.add(isTurnover ? 'stat-leader-red' : 'stat-leader-green');
                }
            };

            sortedPlayers.forEach((stat, index) => {
                const playerId = stat.id || null;
                const details = playerId ? (statsDetails[playerId] || []) : [];
                const gamesPlayed = playerId ? getGamesPlayed(playerId) : 0;

                const row = document.createElement('tr');
                row.className = 'stats-history-row';
                row.dataset.playerId = playerId || index;

                const nameCell = document.createElement('td');
                nameCell.className = 'player-name-col';
                nameCell.innerHTML = `<span class="accordion-icon">â–¶</span>${stat.name}${stat.star ? ' â­' : ''}`;
                row.appendChild(nameCell);

                const gamesPlayedCell = document.createElement('td');
                gamesPlayedCell.textContent = gamesPlayed;
                gamesPlayedCell.style.textAlign = 'center';
                row.appendChild(gamesPlayedCell);

                const formatDisplayValue = (value) => {
                    if (statsViewMode === 'per-game') {
                        return value.toFixed(1);
                    }
                    return value;
                };

                const pointsValue = getStatValue(stat, gamesPlayed, 'points');
                const pointsCell = document.createElement('td');
                pointsCell.textContent = formatDisplayValue(pointsValue);
                pointsCell.style.textAlign = 'center';
                applyLeaderClass(pointsCell, pointsValue, maxStats.points);
                row.appendChild(pointsCell);

                const assistsValue = getStatValue(stat, gamesPlayed, 'assists');
                const assistsCell = document.createElement('td');
                assistsCell.textContent = formatDisplayValue(assistsValue);
                assistsCell.style.textAlign = 'center';
                applyLeaderClass(assistsCell, assistsValue, maxStats.assists);
                row.appendChild(assistsCell);

                const reboundsValue = getStatValue(stat, gamesPlayed, 'rebounds');
                const reboundsCell = document.createElement('td');
                reboundsCell.textContent = formatDisplayValue(reboundsValue);
                reboundsCell.style.textAlign = 'center';
                applyLeaderClass(reboundsCell, reboundsValue, maxStats.rebounds);
                row.appendChild(reboundsCell);

                const blocksValue = getStatValue(stat, gamesPlayed, 'blocks');
                const blocksCell = document.createElement('td');
                blocksCell.textContent = formatDisplayValue(blocksValue);
                blocksCell.style.textAlign = 'center';
                applyLeaderClass(blocksCell, blocksValue, maxStats.blocks);
                row.appendChild(blocksCell);

                const stealsValue = getStatValue(stat, gamesPlayed, 'steals');
                const stealsCell = document.createElement('td');
                stealsCell.textContent = formatDisplayValue(stealsValue);
                stealsCell.style.textAlign = 'center';
                applyLeaderClass(stealsCell, stealsValue, maxStats.steals);
                row.appendChild(stealsCell);

                const turnoversValue = getStatValue(stat, gamesPlayed, 'turnovers');
                const turnoversCell = document.createElement('td');
                turnoversCell.textContent = formatDisplayValue(turnoversValue);
                turnoversCell.style.textAlign = 'center';
                applyLeaderClass(turnoversCell, turnoversValue, maxStats.turnovers, true);
                row.appendChild(turnoversCell);

                row.addEventListener('click', () => toggleStatsHistoryRow(row, playerId || index));
                tbody.appendChild(row);

                const detailRow = document.createElement('tr');
                detailRow.className = 'stats-history-detail-row';
                detailRow.dataset.playerId = playerId || index;

                const detailCell = document.createElement('td');
                detailCell.colSpan = 8;
                detailCell.className = 'playtime-detail-cell';

                if (details.length > 0) {
                    const detailTable = document.createElement('table');
                    detailTable.style.width = '100%';
                    detailTable.style.borderCollapse = 'collapse';

                    const headerRow = document.createElement('tr');
                    headerRow.style.backgroundColor = '#e0e0e0';
                    headerRow.style.fontWeight = 'bold';
                    ['Opponent', 'Date', 'PTS', 'AST', 'REB', 'BLK', 'STL', 'TO', 'Edit'].forEach(text => {
                        const th = document.createElement('td');
                        th.textContent = text;
                        th.style.padding = '8px';
                        th.style.textAlign = text === 'Opponent' || text === 'Date' ? 'left' : 'center';
                        headerRow.appendChild(th);
                    });
                    detailTable.appendChild(headerRow);

                    details.forEach(game => {
                        const gameRow = document.createElement('tr');
                        gameRow.style.borderBottom = '1px solid #ddd';

                        const oppCell = document.createElement('td');
                        const totalStats = Object.values(game.stats || {}).reduce((sum, val) => sum + (val || 0), 0);
                        const showDnp = !game.lineupPlayed;
                        oppCell.innerHTML = `${escapeHtml(game.opponent)}${showDnp ? ' <span class="dnp-badge">DNP</span>' : ''}`;
                        oppCell.style.padding = '8px';
                        gameRow.appendChild(oppCell);

                        const dateCell = document.createElement('td');
                        dateCell.textContent = formatDate(game.date);
                        dateCell.style.padding = '8px';
                        gameRow.appendChild(dateCell);

                        const statValues = [
                            game.stats.points,
                            game.stats.assists,
                            game.stats.rebounds,
                            game.stats.blocks,
                            game.stats.steals,
                            game.stats.turnovers
                        ];

                        statValues.forEach(value => {
                            const statCell = document.createElement('td');
                            statCell.textContent = value;
                            statCell.style.padding = '8px';
                            statCell.style.textAlign = 'center';
                            gameRow.appendChild(statCell);
                        });

                        const editCell = document.createElement('td');
                        editCell.style.padding = '8px';
                        editCell.style.textAlign = 'center';
                        const editLink = document.createElement('a');
                        editLink.href = 'javascript:void(0)';
                        const showWarning = !game.lineupPlayed && totalStats > 0;
                        editLink.textContent = showWarning ? 'âš ï¸âœï¸' : 'âœï¸';
                        editLink.title = 'Edit stats';
                        editLink.style.color = '#004E89';
                        editLink.style.fontSize = '1.1rem';
                        editLink.style.fontWeight = '600';
                        editLink.onclick = () => openGameStatsEditor(game.gameId);
                        editCell.appendChild(editLink);
                        gameRow.appendChild(editCell);

                        detailTable.appendChild(gameRow);
                    });

                    detailCell.appendChild(detailTable);
                } else {
                    detailCell.innerHTML = '<div style="color: #666; padding: 10px;">No stats recorded for this player yet.</div>';
                }

                detailRow.appendChild(detailCell);
                tbody.appendChild(detailRow);
            });

            updateStatsSortIndicators();
        }

        // Initialize - load roster and start on roster page
        async function initializeApp() {
            // Run data migrations
            try {
                StorageService._migrateStatsOverridesToPlayed();
            } catch (error) {
                console.error('Migration failed:', error);
            }
            
            // Migrate existing data to default team
            migrateExistingDataToDefaultTeam();
            
            // Restore Blue Devils roster if missing
            restoreBlueDevilsRoster();
            
            // Check if we have a current team selected
            const currentTeam = await TeamService.getCurrentTeam();
            if (!currentTeam) {
                // No team selected, show team selection page
                navigateTo('team-selection-page');
            } else {
                // Team selected, show team info page as default
                await updateTeamDisplay();
                await loadRoster();
                navigateTo('team-info-page');
            }
        }
        
        // Close team selector when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('team-selector-dropdown');
            const navTitle = document.getElementById('nav-title');
            if (dropdown && navTitle && !navTitle.contains(e.target) && !dropdown.contains(e.target)) {
                closeTeamSelector();
            }
        });

        initializeApp();
        
        // Register Service Worker for PWA support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('[App] Service Worker registered:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    console.log('[App] New version available');
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('[App] Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
